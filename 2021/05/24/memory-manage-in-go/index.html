<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="go,golang,">










<meta name="description" content="为什么需要内存分配器？总说周知，内存作为一种相对稀缺的资源，在操作系统中以虚拟内存的形式来作为一种内存抽象提供给进程，这里可以简单地把它看做一个连续的地址集合{0, 1, 2, ..., M}，由栈空间、堆空间、代码片、数据片等地址空间段组合而成，如下图所示(出自CS:APP3e, Bryant and O’Hallaron的第9章第9节)  这里我们重点关注Heap（堆），堆是一块动态的虚拟内存">
<meta name="keywords" content="go,golang">
<meta property="og:type" content="article">
<meta property="og:title" content="Go语言内存分配的原理与实现">
<meta property="og:url" content="https://erenming.com/2021/05/24/memory-manage-in-go/index.html">
<meta property="og:site_name" content="Eren with you">
<meta property="og:description" content="为什么需要内存分配器？总说周知，内存作为一种相对稀缺的资源，在操作系统中以虚拟内存的形式来作为一种内存抽象提供给进程，这里可以简单地把它看做一个连续的地址集合{0, 1, 2, ..., M}，由栈空间、堆空间、代码片、数据片等地址空间段组合而成，如下图所示(出自CS:APP3e, Bryant and O’Hallaron的第9章第9节)  这里我们重点关注Heap（堆），堆是一块动态的虚拟内存">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://raw.githubusercontent.com/erenming/image-pool/master/blog/image-20210525231530967.png">
<meta property="og:image" content="https://raw.githubusercontent.com/erenming/image-pool/master/blog/go-mem-heapArena.png">
<meta property="og:updated_time" content="2021-06-15T10:54:26.404Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Go语言内存分配的原理与实现">
<meta name="twitter:description" content="为什么需要内存分配器？总说周知，内存作为一种相对稀缺的资源，在操作系统中以虚拟内存的形式来作为一种内存抽象提供给进程，这里可以简单地把它看做一个连续的地址集合{0, 1, 2, ..., M}，由栈空间、堆空间、代码片、数据片等地址空间段组合而成，如下图所示(出自CS:APP3e, Bryant and O’Hallaron的第9章第9节)  这里我们重点关注Heap（堆），堆是一块动态的虚拟内存">
<meta name="twitter:image" content="https://raw.githubusercontent.com/erenming/image-pool/master/blog/image-20210525231530967.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://erenming.com/2021/05/24/memory-manage-in-go/">





  <title>Go语言内存分配的原理与实现 | Eren with you</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Eren with you</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://erenming.com/2021/05/24/memory-manage-in-go/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Eren Ming">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eren with you">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Go语言内存分配的原理与实现</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-05-24T23:42:09+08:00">
                2021-05-24
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2021/05/24/memory-manage-in-go/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2021/05/24/memory-manage-in-go/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="为什么需要内存分配器？"><a href="#为什么需要内存分配器？" class="headerlink" title="为什么需要内存分配器？"></a>为什么需要内存分配器？</h1><p>总说周知，内存作为一种相对稀缺的资源，在操作系统中以<em>虚拟内存</em>的形式来作为一种内存抽象提供给进程，这里可以简单地把它看做一个连续的地址集合<code>{0, 1, 2, ..., M}</code>，由栈空间、堆空间、代码片、数据片等地址空间段组合而成，如下图所示(出自<a href="https://csapp.cs.cmu.edu/" target="_blank" rel="noopener">CS:APP3e, Bryant and O’Hallaron</a>的第9章第9节)</p>
<p><img src="https://raw.githubusercontent.com/erenming/image-pool/master/blog/image-20210525231530967.png" alt="image-20210525231530967" style="zoom:50%;"></p>
<p>这里我们重点关注Heap（堆），堆是一块动态的虚拟内存地址空间。在C语言中，我们通常使用<code>malloc</code>来申请内存以及使用<code>free</code>来释放内存，也许你想问，这样不就足够了吗？但是，这种手动的内存管理会带来很多问题，比如：</p>
<ol>
<li>给程序员带来额外的心智负担，必须得及时释放掉不再使用的内存空间，否则就很容易出现内存泄露</li>
<li>随着内存的不断申请与释放，会产生大量的<a href="https://en.wikipedia.org/wiki/Fragmentation_(computing" target="_blank" rel="noopener">内存碎片</a>)，这将大大降低内存的利用率</li>
</ol>
<p>因此，正确高效地管理内存空间是非常有必要的，常见的技术实现有Sequential allocation, Free-List allocation等。那么，在Go中，内存是如何被管理的呢？</p>
<blockquote>
<p>注：此为Go1.13.6的实现逻辑，随版本更替某些细节会有些许不同</p>
</blockquote>
<h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>Go的内存分配器是基于<a href="https://google.github.io/tcmalloc/design.html#spans" target="_blank" rel="noopener">TCMalloc</a>设计的，因此我建议你先行查阅，这将有利于理解接下来的内容。</p>
<p>大量工程经验证明，程序中的小对象占了绝大部分，且生命周期都较为短暂。因此，Go将内存划分为各种类别(Class)，并各自形成Free-List。相较于单一的Free-List分配器，分类后主要有以下优点：</p>
<ul>
<li><p>其一方面减少不必要的搜索时间，因为对象只需要在其所属类别的空闲链表中搜索即可</p>
</li>
<li><p>另一方面减少了内存碎片化，同一类别的空闲链表，每个对象分配的空间都是一样大小(不足则补齐)，因此该链表除非为空，否则总能分配空间，避免了内存碎片</p>
</li>
</ul>
<p>那么，Go内存分配器具体是如何实现的呢？接下来，我将以自顶向下的方式，从宏观到微观，层层拨开她的神秘面纱。</p>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>首先，介绍Go内存分配中相关的数据结构。其总体概览图如下所示：</p>
<p><img src="https://raw.githubusercontent.com/erenming/image-pool/master/blog/go-mem-heapArena.png" alt="go-mem-heapArena"></p>
<h3 id="heapArena"><a href="#heapArena" class="headerlink" title="heapArena"></a>heapArena</h3><p>在操作系统中，我们一般把堆看做是一块连续的虚拟内存空间。</p>
<p>Go将其划分为数个相同大小的连续空间块，称之<code>arena</code>，其中，heapArena则作为arena空间的管理单元，其结构如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> heapArena <span class="keyword">struct</span> &#123;</span><br><span class="line">  bitmap [heapArenaBitmapBytes]<span class="keyword">byte</span></span><br><span class="line">  spans [pagesPerArena]*mspan</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>bitmap: 表示arena区域中哪些地址保存了对象，哪些地址保存了指针</li>
<li>spans: 表示arenaz区域中哪些操作系统页(8K)属于哪些mspan</li>
</ul>
<h3 id="mheap"><a href="#mheap" class="headerlink" title="mheap"></a>mheap</h3><p>然后，则是核心角色mheap了，它是Go内存管理中的核心数据结构，作为全局唯一变量，其结构如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mheap <span class="keyword">struct</span> &#123;</span><br><span class="line">	free      mTreap</span><br><span class="line">  ...</span><br><span class="line">  allspans []*mspan</span><br><span class="line">  ...</span><br><span class="line">  arenas [<span class="number">1</span> &lt;&lt; arenaL1Bits]*[<span class="number">1</span> &lt;&lt; arenaL2Bits]*heapArena</span><br><span class="line">  ...</span><br><span class="line">  central [numSpanClasses]<span class="keyword">struct</span> &#123;</span><br><span class="line">		mcentral mcentral</span><br><span class="line">		pad      [cpu.CacheLinePadSize - unsafe.Sizeof(mcentral&#123;&#125;)%cpu.CacheLinePadSize]<span class="keyword">byte</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>free: 使用树堆的结构来保存各种类别的mspan</li>
<li>allspans: 用以记录了分配过了的mspan</li>
<li>arenas: 表示其覆盖的所有arena区域，通过虚拟内存地址计算得到下标索引</li>
<li>central: 表示其覆盖的所有mcentral，一共134个，对应67个类别</li>
</ul>
<h3 id="mcentral"><a href="#mcentral" class="headerlink" title="mcentral"></a>mcentral</h3><p>而<code>mcentral</code>充当<code>mspan</code>的中心管理员，负责管理某一类别的mspan，其结构如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mcentral <span class="keyword">struct</span> &#123;</span><br><span class="line">	lock      mutex</span><br><span class="line">	spanclass spanClass</span><br><span class="line">	nonempty  mSpanList</span><br><span class="line">	empty     mSpanList</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>lock: 全局互斥锁，因为多个线程会并发请求</li>
<li>spanclass：mspan类别</li>
<li>nonempty：mspan的双端链表，且其中至少有一个mspan包含空闲对象</li>
<li>empty：mspan的双端链表，但不确定其中的mspan是否包含空闲对象</li>
</ul>
<h3 id="mcache"><a href="#mcache" class="headerlink" title="mcache"></a>mcache</h3><p><code>mcache</code>充当mspan的线程本地缓存角色，其与线程处理器(P)一一绑定。</p>
<p>这样呢，当mcache有空闲mspan时，则无需向mcentral申请，因此可以避免诸多不必要的锁消耗。结构如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mcache <span class="keyword">struct</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  alloc [numSpanClasses]*mspan</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>alloc: 表示各个类别的mspan</li>
</ul>
<h3 id="mspan"><a href="#mspan" class="headerlink" title="mspan"></a>mspan</h3><p><code>mspan</code>作为虚拟内存的实际管理单元，管理着一片内存空间(npages个页)，其结构如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mspan <span class="keyword">struct</span> &#123;</span><br><span class="line">	next *mspan     <span class="comment">// 指向下一个mspan</span></span><br><span class="line">	prev *mspan     <span class="comment">// 指向前一个mspan</span></span><br><span class="line">  ...</span><br><span class="line">	npages    <span class="keyword">uintptr</span></span><br><span class="line">  freeindex <span class="keyword">uintptr</span></span><br><span class="line">  nelems    <span class="keyword">uintptr</span> <span class="comment">// 总对象个数</span></span><br><span class="line">  ...</span><br><span class="line">  allocBits  *gcBits</span><br><span class="line">	gcmarkBits *gcBits</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>next指针指向下一个mspan，prev指针指向前一个mspan，因此各个mspan彼此之间形成一个双端链表，并被runtime.mSpanList作为链表头。</li>
<li>npages：mspan所管理的页的数量</li>
<li>freeindex：空闲对象的起始位置，如果freeindex等于nelems时，则代表此mspan无空闲对象可分配了</li>
<li>allocBits：标记哪些元素已分配，哪些未分配。与freeindex结合，可跳过已分配的对象</li>
<li>gcmarkBits：标记哪些对象存活，每次GC结束时，将其设为allocBits</li>
</ul>
<p>通过上述对Go内存管理中各个关键数据结构的介绍，想必现在，我们已经对其有了一个大概的轮廓。接下来，让我们继续探究，看看Go具体是如何利用这些数据结构来实现高效的内存分配算法</p>
<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h2><p>内存分配算法，其主要函数为<code>runtime.mallocgc</code>，其基本步骤简述如下：</p>
<ul>
<li>判断待分配对象的大小</li>
<li>若对象小于maxTinySize（16B），且不为指针，则执行微对象分配算法</li>
<li>若对象小于maxSmallSize（32KB），则执行小对象分配算法</li>
<li>否则，则执行大对象分配算法</li>
</ul>
<p>在微对象以及小对象分配过程中，如果span中找不到足够的空闲空间，Go会触发层级的内存分配申请策略。其基本步骤如下：</p>
<ul>
<li>先从mcache寻找对应类别的span，若有空闲对象，则成功返回</li>
<li>若无，则向mcentral申请，分别从nonempty和empty中寻找匹配的span，若找到，则成功返回</li>
<li>若还未找到，则继续向mheap申请，从mheap.free中寻找，若找到，则成功返回</li>
<li>若未找到，则需扩容，从关联的arena中申请，若关联的arena中空间也不足，则向OS申请额外的arena</li>
<li>扩容完毕后，继续从mheap.free中寻找，若仍未找到，则抛出错误</li>
</ul>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h3 id="mallocgc函数"><a href="#mallocgc函数" class="headerlink" title="mallocgc函数"></a>mallocgc函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate an object of size bytes.</span></span><br><span class="line"><span class="comment">// Small objects are allocated from the per-P cache's free lists.</span></span><br><span class="line"><span class="comment">// Large objects (&gt; 32 kB) are allocated straight from the heap.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mallocgc</span><span class="params">(size <span class="keyword">uintptr</span>, typ *_type, needzero <span class="keyword">bool</span>)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> gcphase == _GCmarktermination &#123;</span><br><span class="line">		throw(<span class="string">"mallocgc called with gcphase == _GCmarktermination"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> size == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> unsafe.Pointer(&amp;zerobase)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> debug.sbrk != <span class="number">0</span> &#123;</span><br><span class="line">		align := <span class="keyword">uintptr</span>(<span class="number">16</span>)</span><br><span class="line">		<span class="keyword">if</span> typ != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// TODO(austin): This should be just</span></span><br><span class="line">			<span class="comment">//   align = uintptr(typ.align)</span></span><br><span class="line">			<span class="comment">// but that's only 4 on 32-bit platforms,</span></span><br><span class="line">			<span class="comment">// even if there's a uint64 field in typ (see #599).</span></span><br><span class="line">			<span class="comment">// This causes 64-bit atomic accesses to panic.</span></span><br><span class="line">			<span class="comment">// Hence, we use stricter alignment that matches</span></span><br><span class="line">			<span class="comment">// the normal allocator better.</span></span><br><span class="line">			<span class="keyword">if</span> size&amp;<span class="number">7</span> == <span class="number">0</span> &#123;</span><br><span class="line">				align = <span class="number">8</span></span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> size&amp;<span class="number">3</span> == <span class="number">0</span> &#123;</span><br><span class="line">				align = <span class="number">4</span></span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> size&amp;<span class="number">1</span> == <span class="number">0</span> &#123;</span><br><span class="line">				align = <span class="number">2</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				align = <span class="number">1</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> persistentalloc(size, align, &amp;memstats.other_sys)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// assistG is the G to charge for this allocation, or nil if</span></span><br><span class="line">	<span class="comment">// GC is not currently active.</span></span><br><span class="line">	<span class="keyword">var</span> assistG *g</span><br><span class="line">	<span class="keyword">if</span> gcBlackenEnabled != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// Charge the current user G for this allocation.</span></span><br><span class="line">		assistG = getg()</span><br><span class="line">		<span class="keyword">if</span> assistG.m.curg != <span class="literal">nil</span> &#123;</span><br><span class="line">			assistG = assistG.m.curg</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Charge the allocation against the G. We'll account</span></span><br><span class="line">		<span class="comment">// for internal fragmentation at the end of mallocgc.</span></span><br><span class="line">		assistG.gcAssistBytes -= <span class="keyword">int64</span>(size)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> assistG.gcAssistBytes &lt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// This G is in debt. Assist the GC to correct</span></span><br><span class="line">			<span class="comment">// this before allocating. This must happen</span></span><br><span class="line">			<span class="comment">// before disabling preemption.</span></span><br><span class="line">			gcAssistAlloc(assistG)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Set mp.mallocing to keep from being preempted by GC.</span></span><br><span class="line">	mp := acquirem()</span><br><span class="line">	<span class="keyword">if</span> mp.mallocing != <span class="number">0</span> &#123;</span><br><span class="line">		throw(<span class="string">"malloc deadlock"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> mp.gsignal == getg() &#123;</span><br><span class="line">		throw(<span class="string">"malloc during signal"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	mp.mallocing = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	shouldhelpgc := <span class="literal">false</span></span><br><span class="line">	dataSize := size</span><br><span class="line">	c := gomcache()</span><br><span class="line">	<span class="keyword">var</span> x unsafe.Pointer</span><br><span class="line">	noscan := typ == <span class="literal">nil</span> || typ.ptrdata == <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> size &lt;= maxSmallSize &#123;</span><br><span class="line">		<span class="keyword">if</span> noscan &amp;&amp; size &lt; maxTinySize &#123; <span class="comment">// 分配微对象</span></span><br><span class="line">			<span class="comment">// Go将多个微对象放置在一个单独的内存块中（这里是16 bytes），当内存块中所有的</span></span><br><span class="line">			<span class="comment">// 对象都不可达后，则该内存块为空闲内存块。</span></span><br><span class="line">			<span class="comment">// Tiny allocator.</span></span><br><span class="line">			<span class="comment">//</span></span><br><span class="line">			<span class="comment">// Tiny allocator combines several tiny allocation requests</span></span><br><span class="line">			<span class="comment">// into a single memory block. The resulting memory block</span></span><br><span class="line">			<span class="comment">// is freed when all subobjects are unreachable. The subobjects</span></span><br><span class="line">			<span class="comment">// must be noscan (don't have pointers), this ensures that</span></span><br><span class="line">			<span class="comment">// the amount of potentially wasted memory is bounded.</span></span><br><span class="line">			<span class="comment">//</span></span><br><span class="line">			<span class="comment">// Size of the memory block used for combining (maxTinySize) is tunable.</span></span><br><span class="line">			<span class="comment">// Current setting is 16 bytes, which relates to 2x worst case memory</span></span><br><span class="line">			<span class="comment">// wastage (when all but one subobjects are unreachable).</span></span><br><span class="line">			<span class="comment">// 8 bytes would result in no wastage at all, but provides less</span></span><br><span class="line">			<span class="comment">// opportunities for combining.</span></span><br><span class="line">			<span class="comment">// 32 bytes provides more opportunities for combining,</span></span><br><span class="line">			<span class="comment">// but can lead to 4x worst case wastage.</span></span><br><span class="line">			<span class="comment">// The best case winning is 8x regardless of block size.</span></span><br><span class="line">			<span class="comment">//</span></span><br><span class="line">			<span class="comment">// Objects obtained from tiny allocator must not be freed explicitly.</span></span><br><span class="line">			<span class="comment">// So when an object will be freed explicitly, we ensure that</span></span><br><span class="line">			<span class="comment">// its size &gt;= maxTinySize.</span></span><br><span class="line">			<span class="comment">//</span></span><br><span class="line">			<span class="comment">// SetFinalizer has a special case for objects potentially coming</span></span><br><span class="line">			<span class="comment">// from tiny allocator, it such case it allows to set finalizers</span></span><br><span class="line">			<span class="comment">// for an inner byte of a memory block.</span></span><br><span class="line">			<span class="comment">//</span></span><br><span class="line">			<span class="comment">// The main targets of tiny allocator are small strings and</span></span><br><span class="line">			<span class="comment">// standalone escaping variables. On a json benchmark</span></span><br><span class="line">			<span class="comment">// the allocator reduces number of allocations by ~12% and</span></span><br><span class="line">			<span class="comment">// reduces heap size by ~20%.</span></span><br><span class="line">			off := c.tinyoffset</span><br><span class="line">			<span class="comment">// Align tiny pointer for required (conservative) alignment.</span></span><br><span class="line">			<span class="keyword">if</span> size&amp;<span class="number">7</span> == <span class="number">0</span> &#123;</span><br><span class="line">				off = round(off, <span class="number">8</span>)</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> size&amp;<span class="number">3</span> == <span class="number">0</span> &#123;</span><br><span class="line">				off = round(off, <span class="number">4</span>)</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> size&amp;<span class="number">1</span> == <span class="number">0</span> &#123;</span><br><span class="line">				off = round(off, <span class="number">2</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 如果内存块有足够的空间，则直接进行分配</span></span><br><span class="line">			<span class="keyword">if</span> off+size &lt;= maxTinySize &amp;&amp; c.tiny != <span class="number">0</span> &#123;</span><br><span class="line">				<span class="comment">// The object fits into existing tiny block.</span></span><br><span class="line">				x = unsafe.Pointer(c.tiny + off)</span><br><span class="line">				c.tinyoffset = off + size</span><br><span class="line">				c.local_tinyallocs++</span><br><span class="line">				mp.mallocing = <span class="number">0</span></span><br><span class="line">				releasem(mp)</span><br><span class="line">				<span class="keyword">return</span> x</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 否则，额外再申请一块maxTinySize大小内存</span></span><br><span class="line">			<span class="comment">// Allocate a new maxTinySize block.</span></span><br><span class="line">			span := c.alloc[tinySpanClass] <span class="comment">// tinySpanClass = 5 // 101</span></span><br><span class="line">			v := nextFreeFast(span)</span><br><span class="line">			<span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">				v, _, shouldhelpgc = c.nextFree(tinySpanClass)</span><br><span class="line">			&#125;</span><br><span class="line">			x = unsafe.Pointer(v)</span><br><span class="line">			(*[<span class="number">2</span>]<span class="keyword">uint64</span>)(x)[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">			(*[<span class="number">2</span>]<span class="keyword">uint64</span>)(x)[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">			<span class="comment">// See if we need to replace the existing tiny block with the new one</span></span><br><span class="line">			<span class="comment">// based on amount of remaining free space.</span></span><br><span class="line">			<span class="keyword">if</span> size &lt; c.tinyoffset || c.tiny == <span class="number">0</span> &#123;</span><br><span class="line">				c.tiny = <span class="keyword">uintptr</span>(x)</span><br><span class="line">				c.tinyoffset = size</span><br><span class="line">			&#125;</span><br><span class="line">			size = maxTinySize</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123; <span class="comment">// 分配小对象</span></span><br><span class="line">			<span class="comment">// maxTinySize(16B) &lt; size &lt;= maxSmallSize(32K)，则为小对象</span></span><br><span class="line">			<span class="comment">// 通过size得到其所属的大小类别sizeclass</span></span><br><span class="line">			<span class="keyword">var</span> sizeclass <span class="keyword">uint8</span></span><br><span class="line">			<span class="keyword">if</span> size &lt;= smallSizeMax<span class="number">-8</span> &#123;</span><br><span class="line">				sizeclass = size_to_class8[(size+smallSizeDiv<span class="number">-1</span>)/smallSizeDiv]</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				sizeclass = size_to_class128[(size-smallSizeMax+largeSizeDiv<span class="number">-1</span>)/largeSizeDiv]</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 通过sizeclass得到实际size</span></span><br><span class="line">			size = <span class="keyword">uintptr</span>(class_to_size[sizeclass])</span><br><span class="line">			spc := makeSpanClass(sizeclass, noscan)</span><br><span class="line">			span := c.alloc[spc]</span><br><span class="line">			<span class="comment">// 尝试从span中获取空闲空间</span></span><br><span class="line">			v := nextFreeFast(span)</span><br><span class="line">			<span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">				<span class="comment">// 如未获取到，则向上一级(mcache)申请</span></span><br><span class="line">				v, span, shouldhelpgc = c.nextFree(spc)</span><br><span class="line">			&#125;</span><br><span class="line">			x = unsafe.Pointer(v)</span><br><span class="line">			<span class="keyword">if</span> needzero &amp;&amp; span.needzero != <span class="number">0</span> &#123;</span><br><span class="line">				memclrNoHeapPointers(unsafe.Pointer(v), size)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123; <span class="comment">// 分配大对象</span></span><br><span class="line">		<span class="keyword">var</span> s *mspan</span><br><span class="line">		shouldhelpgc = <span class="literal">true</span></span><br><span class="line">		systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="comment">// 直接从系统栈上调用largeAlloc</span></span><br><span class="line">			s = largeAlloc(size, needzero, noscan)</span><br><span class="line">		&#125;)</span><br><span class="line">		<span class="comment">// 此时span上只有一个对象</span></span><br><span class="line">		s.freeindex = <span class="number">1</span></span><br><span class="line">		s.allocCount = <span class="number">1</span></span><br><span class="line">		x = unsafe.Pointer(s.base())</span><br><span class="line">		size = s.elemsize</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> scanSize <span class="keyword">uintptr</span></span><br><span class="line">	<span class="keyword">if</span> !noscan &#123;</span><br><span class="line">		<span class="comment">// If allocating a defer+arg block, now that we've picked a malloc size</span></span><br><span class="line">		<span class="comment">// large enough to hold everything, cut the "asked for" size down to</span></span><br><span class="line">		<span class="comment">// just the defer header, so that the GC bitmap will record the arg block</span></span><br><span class="line">		<span class="comment">// as containing nothing at all (as if it were unused space at the end of</span></span><br><span class="line">		<span class="comment">// a malloc block caused by size rounding).</span></span><br><span class="line">		<span class="comment">// The defer arg areas are scanned as part of scanstack.</span></span><br><span class="line">		<span class="keyword">if</span> typ == deferType &#123;</span><br><span class="line">			dataSize = unsafe.Sizeof(_defer&#123;&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">		heapBitsSetType(<span class="keyword">uintptr</span>(x), size, dataSize, typ)</span><br><span class="line">		<span class="keyword">if</span> dataSize &gt; typ.size &#123;</span><br><span class="line">			<span class="comment">// Array allocation. If there are any</span></span><br><span class="line">			<span class="comment">// pointers, GC has to scan to the last</span></span><br><span class="line">			<span class="comment">// element.</span></span><br><span class="line">			<span class="keyword">if</span> typ.ptrdata != <span class="number">0</span> &#123;</span><br><span class="line">				scanSize = dataSize - typ.size + typ.ptrdata</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			scanSize = typ.ptrdata</span><br><span class="line">		&#125;</span><br><span class="line">		c.local_scan += scanSize</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Ensure that the stores above that initialize x to</span></span><br><span class="line">	<span class="comment">// type-safe memory and set the heap bits occur before</span></span><br><span class="line">	<span class="comment">// the caller can make x observable to the garbage</span></span><br><span class="line">	<span class="comment">// collector. Otherwise, on weakly ordered machines,</span></span><br><span class="line">	<span class="comment">// the garbage collector could follow a pointer to x,</span></span><br><span class="line">	<span class="comment">// but see uninitialized memory or stale heap bits.</span></span><br><span class="line">	publicationBarrier()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Allocate black during GC.</span></span><br><span class="line">	<span class="comment">// All slots hold nil so no scanning is needed.</span></span><br><span class="line">	<span class="comment">// This may be racing with GC so do it atomically if there can be</span></span><br><span class="line">	<span class="comment">// a race marking the bit.</span></span><br><span class="line">	<span class="keyword">if</span> gcphase != _GCoff &#123;</span><br><span class="line">		gcmarknewobject(<span class="keyword">uintptr</span>(x), size, scanSize)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		racemalloc(x, size)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> msanenabled &#123;</span><br><span class="line">		msanmalloc(x, size)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mp.mallocing = <span class="number">0</span></span><br><span class="line">	releasem(mp)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> debug.allocfreetrace != <span class="number">0</span> &#123;</span><br><span class="line">		tracealloc(x, size, typ)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> rate := MemProfileRate; rate &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> rate != <span class="number">1</span> &amp;&amp; size &lt; c.next_sample &#123;</span><br><span class="line">			c.next_sample -= size</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			mp := acquirem()</span><br><span class="line">			profilealloc(mp, x, size)</span><br><span class="line">			releasem(mp)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> assistG != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Account for internal fragmentation in the assist</span></span><br><span class="line">		<span class="comment">// debt now that we know it.</span></span><br><span class="line">		assistG.gcAssistBytes -= <span class="keyword">int64</span>(size - dataSize)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> shouldhelpgc &#123;</span><br><span class="line">		<span class="keyword">if</span> t := (gcTrigger&#123;kind: gcTriggerHeap&#125;); t.test() &#123;</span><br><span class="line">			gcStart(t)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有两个重要的函数，分别为nextFreeFast和nextFree函数</p>
<h4 id="nextFreeFast函数"><a href="#nextFreeFast函数" class="headerlink" title="nextFreeFast函数"></a>nextFreeFast函数</h4><p>尝试从span中获取空闲空间，根据bitmap mspan.allocCache来寻找空闲空间</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nextFreeFast returns the next free object if one is quickly available.</span></span><br><span class="line"><span class="comment">// Otherwise it returns 0.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nextFreeFast</span><span class="params">(s *mspan)</span> <span class="title">gclinkptr</span></span> &#123;</span><br><span class="line">	theBit := sys.Ctz64(s.allocCache) <span class="comment">// Is there a free object in the allocCache?</span></span><br><span class="line">	<span class="keyword">if</span> theBit &lt; <span class="number">64</span> &#123;</span><br><span class="line">		result := s.freeindex + <span class="keyword">uintptr</span>(theBit)</span><br><span class="line">    <span class="comment">// 若还有空闲页</span></span><br><span class="line">		<span class="keyword">if</span> result &lt; s.nelems &#123;</span><br><span class="line">			freeidx := result + <span class="number">1</span></span><br><span class="line">			<span class="keyword">if</span> freeidx%<span class="number">64</span> == <span class="number">0</span> &amp;&amp; freeidx != s.nelems &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">			&#125;</span><br><span class="line">			s.allocCache &gt;&gt;= <span class="keyword">uint</span>(theBit + <span class="number">1</span>)</span><br><span class="line">			s.freeindex = freeidx</span><br><span class="line">			s.allocCount++</span><br><span class="line">			<span class="keyword">return</span> gclinkptr(result*s.elemsize + s.base())</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="mcache-nextFree函数"><a href="#mcache-nextFree函数" class="headerlink" title="mcache.nextFree函数"></a>mcache.nextFree函数</h4><p>再次尝试从span中获取空闲空间，如无空闲空间则调用refill函数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nextFree returns the next free object from the cached span if one is available.</span></span><br><span class="line"><span class="comment">// Otherwise it refills the cache with a span with an available object and</span></span><br><span class="line"><span class="comment">// returns that object along with a flag indicating that this was a heavy</span></span><br><span class="line"><span class="comment">// weight allocation. If it is a heavy weight allocation the caller must</span></span><br><span class="line"><span class="comment">// determine whether a new GC cycle needs to be started or if the GC is active</span></span><br><span class="line"><span class="comment">// whether this goroutine needs to assist the GC.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Must run in a non-preemptible context since otherwise the owner of</span></span><br><span class="line"><span class="comment">// c could change.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *mcache)</span> <span class="title">nextFree</span><span class="params">(spc spanClass)</span> <span class="params">(v gclinkptr, s *mspan, shouldhelpgc <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	s = c.alloc[spc] <span class="comment">// 获取mspan</span></span><br><span class="line">	shouldhelpgc = <span class="literal">false</span></span><br><span class="line">	freeIndex := s.nextFreeIndex()</span><br><span class="line">  <span class="comment">// mspan已无空闲空间</span></span><br><span class="line">	<span class="keyword">if</span> freeIndex == s.nelems &#123;</span><br><span class="line">		<span class="comment">// The span is full.</span></span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">uintptr</span>(s.allocCount) != s.nelems &#123;</span><br><span class="line">			<span class="built_in">println</span>(<span class="string">"runtime: s.allocCount="</span>, s.allocCount, <span class="string">"s.nelems="</span>, s.nelems)</span><br><span class="line">			throw(<span class="string">"s.allocCount != s.nelems &amp;&amp; freeIndex == s.nelems"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="comment">// 额外再申请一个空闲mspan</span></span><br><span class="line">		c.refill(spc)</span><br><span class="line">		shouldhelpgc = <span class="literal">true</span></span><br><span class="line">		s = c.alloc[spc]</span><br><span class="line"></span><br><span class="line">		freeIndex = s.nextFreeIndex()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> freeIndex &gt;= s.nelems &#123;</span><br><span class="line">		throw(<span class="string">"freeIndex is not valid"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算mspan地址</span></span><br><span class="line">	v = gclinkptr(freeIndex*s.elemsize + s.base())</span><br><span class="line">	s.allocCount++</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">uintptr</span>(s.allocCount) &gt; s.nelems &#123;</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">"s.allocCount="</span>, s.allocCount, <span class="string">"s.nelems="</span>, s.nelems)</span><br><span class="line">		throw(<span class="string">"s.allocCount &gt; s.nelems"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="mcache-refill函数"><a href="#mcache-refill函数" class="headerlink" title="mcache.refill函数"></a>mcache.refill函数</h4><p>refill函数尝试从mcentral中获取span，并回填到mcache中，替换掉原先的span。(TODO: 原先的span要怎么办呢？不管了吗？)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// refill acquires a new span of span class spc for c. This span will</span></span><br><span class="line"><span class="comment">// have at least one free object. The current span in c must be full.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Must run in a non-preemptible context since otherwise the owner of</span></span><br><span class="line"><span class="comment">// c could change.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *mcache)</span> <span class="title">refill</span><span class="params">(spc spanClass)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Return the current cached span to the central lists.</span></span><br><span class="line">	s := c.alloc[spc]</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">uintptr</span>(s.allocCount) != s.nelems &#123;</span><br><span class="line">		throw(<span class="string">"refill of span with free space remaining"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> s != &amp;emptymspan &#123;</span><br><span class="line">		<span class="comment">// Mark this span as no longer cached.</span></span><br><span class="line">		<span class="keyword">if</span> s.sweepgen != mheap_.sweepgen+<span class="number">3</span> &#123;</span><br><span class="line">			throw(<span class="string">"bad sweepgen in refill"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		atomic.Store(&amp;s.sweepgen, mheap_.sweepgen)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从mcentral中获取新的mspan</span></span><br><span class="line">	<span class="comment">// Get a new cached span from the central lists.</span></span><br><span class="line">	s = mheap_.central[spc].mcentral.cacheSpan()</span><br><span class="line">	<span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">		throw(<span class="string">"out of memory"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">uintptr</span>(s.allocCount) == s.nelems &#123;</span><br><span class="line">		throw(<span class="string">"span has no free space"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Indicate that this span is cached and prevent asynchronous</span></span><br><span class="line">	<span class="comment">// sweeping in the next sweep phase.</span></span><br><span class="line">	s.sweepgen = mheap_.sweepgen + <span class="number">3</span></span><br><span class="line">	<span class="comment">// 回填进mcache</span></span><br><span class="line">	c.alloc[spc] = s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="mcentral-cacheSpan函数"><a href="#mcentral-cacheSpan函数" class="headerlink" title="mcentral.cacheSpan函数"></a>mcentral.cacheSpan函数</h4><p>该函数尝试从mecentral中获取有空闲空间的span，若无，则从mheap中获取</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate a span to use in an mcache.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *mcentral)</span> <span class="title">cacheSpan</span><span class="params">()</span> *<span class="title">mspan</span></span> &#123;</span><br><span class="line">	<span class="comment">// Deduct credit for this span allocation and sweep if necessary.</span></span><br><span class="line">	spanBytes := <span class="keyword">uintptr</span>(class_to_allocnpages[c.spanclass.sizeclass()]) * _PageSize</span><br><span class="line">	deductSweepCredit(spanBytes, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">	lock(&amp;c.lock)</span><br><span class="line">	traceDone := <span class="literal">false</span></span><br><span class="line">	<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">		traceGCSweepStart()</span><br><span class="line">	&#125;</span><br><span class="line">	sg := mheap_.sweepgen</span><br><span class="line">retry:</span><br><span class="line">	<span class="keyword">var</span> s *mspan</span><br><span class="line">  <span class="comment">// 先尝试从nonempty中分配</span></span><br><span class="line">	<span class="keyword">for</span> s = c.nonempty.first; s != <span class="literal">nil</span>; s = s.next &#123;</span><br><span class="line">    <span class="comment">// 若span为待清除状态，且能修改为正在清除的状态</span></span><br><span class="line">		<span class="keyword">if</span> s.sweepgen == sg<span class="number">-2</span> &amp;&amp; atomic.Cas(&amp;s.sweepgen, sg<span class="number">-2</span>, sg<span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="comment">// 状态修改成功，则将其移至empty</span></span><br><span class="line">			c.nonempty.remove(s)</span><br><span class="line">			c.empty.insertBack(s)</span><br><span class="line">			unlock(&amp;c.lock)</span><br><span class="line">			s.sweep(<span class="literal">true</span>)</span><br><span class="line">      <span class="comment">// 清理后，跳转到havespan</span></span><br><span class="line">			<span class="keyword">goto</span> havespan</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="comment">// span处于正在清除状态，则跳过</span></span><br><span class="line">		<span class="keyword">if</span> s.sweepgen == sg<span class="number">-1</span> &#123;</span><br><span class="line">			<span class="comment">// the span is being swept by background sweeper, skip</span></span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">    <span class="comment">// 此时，span不在需要清理，因此直接分配之</span></span><br><span class="line">		<span class="comment">// we have a nonempty span that does not require sweeping, allocate from it</span></span><br><span class="line">		c.nonempty.remove(s)</span><br><span class="line">		c.empty.insertBack(s)</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="keyword">goto</span> havespan</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 再尝试从empty中分配</span></span><br><span class="line">	<span class="keyword">for</span> s = c.empty.first; s != <span class="literal">nil</span>; s = s.next &#123;</span><br><span class="line">    <span class="comment">// 若span为待清除状态，且能修改为正在清除的状态</span></span><br><span class="line">		<span class="keyword">if</span> s.sweepgen == sg<span class="number">-2</span> &amp;&amp; atomic.Cas(&amp;s.sweepgen, sg<span class="number">-2</span>, sg<span class="number">-1</span>) &#123;</span><br><span class="line">			<span class="comment">// we have an empty span that requires sweeping,</span></span><br><span class="line">			<span class="comment">// sweep it and see if we can free some space in it</span></span><br><span class="line">			c.empty.remove(s)</span><br><span class="line">			<span class="comment">// swept spans are at the end of the list</span></span><br><span class="line">			c.empty.insertBack(s)</span><br><span class="line">			unlock(&amp;c.lock)</span><br><span class="line">			s.sweep(<span class="literal">true</span>)</span><br><span class="line">			freeIndex := s.nextFreeIndex()</span><br><span class="line">      <span class="comment">// 清理后判断是否有空闲对象</span></span><br><span class="line">			<span class="keyword">if</span> freeIndex != s.nelems &#123;</span><br><span class="line">        <span class="comment">// 若有，则分配之</span></span><br><span class="line">				s.freeindex = freeIndex</span><br><span class="line">				<span class="keyword">goto</span> havespan</span><br><span class="line">			&#125;</span><br><span class="line">			lock(&amp;c.lock)</span><br><span class="line">			<span class="comment">// the span is still empty after sweep</span></span><br><span class="line">			<span class="comment">// it is already in the empty list, so just retry</span></span><br><span class="line">			<span class="keyword">goto</span> retry</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> s.sweepgen == sg<span class="number">-1</span> &#123;</span><br><span class="line">			<span class="comment">// the span is being swept by background sweeper, skip</span></span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">    <span class="comment">// 已经找不到有未分配对象的span了</span></span><br><span class="line">		<span class="comment">// already swept empty span,</span></span><br><span class="line">		<span class="comment">// all subsequent ones must also be either swept or in process of sweeping</span></span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">		traceGCSweepDone()</span><br><span class="line">		traceDone = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	unlock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用c.grow()，尝试从mheap中申请span</span></span><br><span class="line">	<span class="comment">// Replenish central list if empty.</span></span><br><span class="line">	s = c.grow()</span><br><span class="line">	<span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	lock(&amp;c.lock)</span><br><span class="line">	c.empty.insertBack(s)</span><br><span class="line">	unlock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// At this point s is a non-empty span, queued at the end of the empty list,</span></span><br><span class="line">	<span class="comment">// c is unlocked.</span></span><br><span class="line">havespan:</span><br><span class="line">	<span class="keyword">if</span> trace.enabled &amp;&amp; !traceDone &#123;</span><br><span class="line">		traceGCSweepDone()</span><br><span class="line">	&#125;</span><br><span class="line">	n := <span class="keyword">int</span>(s.nelems) - <span class="keyword">int</span>(s.allocCount)</span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">0</span> || s.freeindex == s.nelems || <span class="keyword">uintptr</span>(s.allocCount) == s.nelems &#123;</span><br><span class="line">		throw(<span class="string">"span has no free objects"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Assume all objects from this span will be allocated in the</span></span><br><span class="line">	<span class="comment">// mcache. If it gets uncached, we'll adjust this.</span></span><br><span class="line">	atomic.Xadd64(&amp;c.nmalloc, <span class="keyword">int64</span>(n))</span><br><span class="line">	usedBytes := <span class="keyword">uintptr</span>(s.allocCount) * s.elemsize</span><br><span class="line">	atomic.Xadd64(&amp;memstats.heap_live, <span class="keyword">int64</span>(spanBytes)-<span class="keyword">int64</span>(usedBytes))</span><br><span class="line">	<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">		<span class="comment">// heap_live changed.</span></span><br><span class="line">		traceHeapAlloc()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> gcBlackenEnabled != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// heap_live changed.</span></span><br><span class="line">		gcController.revise()</span><br><span class="line">	&#125;</span><br><span class="line">	freeByteBase := s.freeindex &amp;^ (<span class="number">64</span> - <span class="number">1</span>)</span><br><span class="line">	whichByte := freeByteBase / <span class="number">8</span></span><br><span class="line">	<span class="comment">// Init alloc bits cache.</span></span><br><span class="line">	s.refillAllocCache(whichByte)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Adjust the allocCache so that s.freeindex corresponds to the low bit in</span></span><br><span class="line">	<span class="comment">// s.allocCache.</span></span><br><span class="line">	s.allocCache &gt;&gt;= s.freeindex % <span class="number">64</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="mcentral-grow函数"><a href="#mcentral-grow函数" class="headerlink" title="mcentral.grow函数"></a>mcentral.grow函数</h4><p>根据mcentral的span类别，尝试从mheap中申请一个新的span</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// grow allocates a new empty span from the heap and initializes it for c's size class.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *mcentral)</span> <span class="title">grow</span><span class="params">()</span> *<span class="title">mspan</span></span> &#123;</span><br><span class="line">  <span class="comment">// 根据mcentral的span类别计算申请的span页数和大小</span></span><br><span class="line">	npages := <span class="keyword">uintptr</span>(class_to_allocnpages[c.spanclass.sizeclass()])</span><br><span class="line">	size := <span class="keyword">uintptr</span>(class_to_size[c.spanclass.sizeclass()])</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从mheap中申请一个新的span</span></span><br><span class="line">	s := mheap_.alloc(npages, c.spanclass, <span class="literal">false</span>, <span class="literal">true</span>)</span><br><span class="line">	<span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算可保存的元素个数</span></span><br><span class="line">	<span class="comment">// Use division by multiplication and shifts to quickly compute:</span></span><br><span class="line">	<span class="comment">// n := (npages &lt;&lt; _PageShift) / size</span></span><br><span class="line">	n := (npages &lt;&lt; _PageShift) &gt;&gt; s.divShift * <span class="keyword">uintptr</span>(s.divMul) &gt;&gt; s.divShift2</span><br><span class="line">	s.limit = s.base() + size*n</span><br><span class="line">	heapBitsForAddr(s.base()).initSpan(s)</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="mheap-alloc函数"><a href="#mheap-alloc函数" class="headerlink" title="mheap.alloc函数"></a>mheap.alloc函数</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// alloc allocates a new span of npage pages from the GC'd heap.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Either large must be true or spanclass must indicates the span's</span></span><br><span class="line"><span class="comment">// size class and scannability.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If needzero is true, the memory for the returned span will be zeroed.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span> <span class="title">alloc</span><span class="params">(npage <span class="keyword">uintptr</span>, spanclass spanClass, large <span class="keyword">bool</span>, needzero <span class="keyword">bool</span>)</span> *<span class="title">mspan</span></span> &#123;</span><br><span class="line">	<span class="comment">// Don't do any operations that lock the heap on the G stack.</span></span><br><span class="line">	<span class="comment">// It might trigger stack growth, and the stack growth code needs</span></span><br><span class="line">	<span class="comment">// to be able to allocate heap.</span></span><br><span class="line">	<span class="keyword">var</span> s *mspan</span><br><span class="line">	systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 在系统栈上调用mheap.alloc_m</span></span><br><span class="line">		s = h.alloc_m(npage, spanclass, large)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> s != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> needzero &amp;&amp; s.needzero != <span class="number">0</span> &#123;</span><br><span class="line">			memclrNoHeapPointers(unsafe.Pointer(s.base()), s.npages&lt;&lt;_PageShift)</span><br><span class="line">		&#125;</span><br><span class="line">		s.needzero = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="mheap-alloc-m"><a href="#mheap-alloc-m" class="headerlink" title="mheap.alloc_m"></a>mheap.alloc_m</h4><p>锁住mheap，并调用allocSpanLocked分配span</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// alloc_m is the internal implementation of mheap.alloc.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// alloc_m must run on the system stack because it locks the heap, so</span></span><br><span class="line"><span class="comment">// any stack growth during alloc_m would self-deadlock.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//go:systemstack</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span> <span class="title">alloc_m</span><span class="params">(npage <span class="keyword">uintptr</span>, spanclass spanClass, large <span class="keyword">bool</span>)</span> *<span class="title">mspan</span></span> &#123;</span><br><span class="line">	_g_ := getg()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 为防止堆增长过快，在分配n页空间前，先回收至少n页空间</span></span><br><span class="line">	<span class="comment">// To prevent excessive heap growth, before allocating n pages</span></span><br><span class="line">	<span class="comment">// we need to sweep and reclaim at least n pages.</span></span><br><span class="line">	<span class="keyword">if</span> h.sweepdone == <span class="number">0</span> &#123;</span><br><span class="line">		h.reclaim(npage)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	lock(&amp;h.lock)</span><br><span class="line">  <span class="comment">// 更新mcache上的统计信息到中心memstats</span></span><br><span class="line">	<span class="comment">// transfer stats from cache to global</span></span><br><span class="line">	memstats.heap_scan += <span class="keyword">uint64</span>(_g_.m.mcache.local_scan)</span><br><span class="line">	_g_.m.mcache.local_scan = <span class="number">0</span></span><br><span class="line">	memstats.tinyallocs += <span class="keyword">uint64</span>(_g_.m.mcache.local_tinyallocs)</span><br><span class="line">	_g_.m.mcache.local_tinyallocs = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 申请span，allocSpanLocked要求堆已上锁</span></span><br><span class="line">	s := h.allocSpanLocked(npage, &amp;memstats.heap_inuse)</span><br><span class="line">	<span class="keyword">if</span> s != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Record span info, because gc needs to be</span></span><br><span class="line">		<span class="comment">// able to map interior pointer to containing span.</span></span><br><span class="line">		atomic.Store(&amp;s.sweepgen, h.sweepgen)</span><br><span class="line">		h.sweepSpans[h.sweepgen/<span class="number">2</span>%<span class="number">2</span>].push(s) <span class="comment">// Add to swept in-use list.</span></span><br><span class="line">		s.state = mSpanInUse</span><br><span class="line">		s.allocCount = <span class="number">0</span></span><br><span class="line">		s.spanclass = spanclass</span><br><span class="line">		<span class="keyword">if</span> sizeclass := spanclass.sizeclass(); sizeclass == <span class="number">0</span> &#123;</span><br><span class="line">			s.elemsize = s.npages &lt;&lt; _PageShift</span><br><span class="line">			s.divShift = <span class="number">0</span></span><br><span class="line">			s.divMul = <span class="number">0</span></span><br><span class="line">			s.divShift2 = <span class="number">0</span></span><br><span class="line">			s.baseMask = <span class="number">0</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			s.elemsize = <span class="keyword">uintptr</span>(class_to_size[sizeclass])</span><br><span class="line">			m := &amp;class_to_divmagic[sizeclass]</span><br><span class="line">			s.divShift = m.shift</span><br><span class="line">			s.divMul = m.mul</span><br><span class="line">			s.divShift2 = m.shift2</span><br><span class="line">			s.baseMask = m.baseMask</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Mark in-use span in arena page bitmap.</span></span><br><span class="line">		arena, pageIdx, pageMask := pageIndexOf(s.base())</span><br><span class="line">		arena.pageInUse[pageIdx] |= pageMask</span><br><span class="line"></span><br><span class="line">		<span class="comment">// update stats, sweep lists</span></span><br><span class="line">		h.pagesInUse += <span class="keyword">uint64</span>(npage)</span><br><span class="line">		<span class="keyword">if</span> large &#123;</span><br><span class="line">      <span class="comment">// 如果是大对象，则更新大对象相关统计信息</span></span><br><span class="line">			memstats.heap_objects++</span><br><span class="line">			mheap_.largealloc += <span class="keyword">uint64</span>(s.elemsize)</span><br><span class="line">			mheap_.nlargealloc++</span><br><span class="line">			atomic.Xadd64(&amp;memstats.heap_live, <span class="keyword">int64</span>(npage&lt;&lt;_PageShift))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// heap_scan and heap_live were updated.</span></span><br><span class="line">	<span class="keyword">if</span> gcBlackenEnabled != <span class="number">0</span> &#123;</span><br><span class="line">		gcController.revise()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">		traceHeapAlloc()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// h.spans is accessed concurrently without synchronization</span></span><br><span class="line">	<span class="comment">// from other threads. Hence, there must be a store/store</span></span><br><span class="line">	<span class="comment">// barrier here to ensure the writes to h.spans above happen</span></span><br><span class="line">	<span class="comment">// before the caller can publish a pointer p to an object</span></span><br><span class="line">	<span class="comment">// allocated from s. As soon as this happens, the garbage</span></span><br><span class="line">	<span class="comment">// collector running on another processor could read p and</span></span><br><span class="line">	<span class="comment">// look up s in h.spans. The unlock acts as the barrier to</span></span><br><span class="line">	<span class="comment">// order these writes. On the read side, the data dependency</span></span><br><span class="line">	<span class="comment">// between p and the index in h.spans orders the reads.</span></span><br><span class="line">	unlock(&amp;h.lock)</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="mheap-allocSpanLocked"><a href="#mheap-allocSpanLocked" class="headerlink" title="mheap.allocSpanLocked"></a>mheap.allocSpanLocked</h4><p>尝试从mheap.free中寻找匹配的span，若未找到则向OS申请</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocates a span of the given size.  h must be locked.</span></span><br><span class="line"><span class="comment">// The returned span has been removed from the</span></span><br><span class="line"><span class="comment">// free structures, but its state is still mSpanFree.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span> <span class="title">allocSpanLocked</span><span class="params">(npage <span class="keyword">uintptr</span>, stat *<span class="keyword">uint64</span>)</span> *<span class="title">mspan</span></span> &#123;</span><br><span class="line">  <span class="comment">// 尝试从mheap.free中找到匹配的span</span></span><br><span class="line">	t := h.free.find(npage)</span><br><span class="line">	<span class="keyword">if</span> t.valid() &#123;</span><br><span class="line">		<span class="keyword">goto</span> HaveSpan</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// 若未找到，则向OS申请npage内存</span></span><br><span class="line">	<span class="keyword">if</span> !h.grow(npage) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// 再尝试从mheap.free寻找匹配的span</span></span><br><span class="line">	t = h.free.find(npage)</span><br><span class="line">	<span class="keyword">if</span> t.valid() &#123;</span><br><span class="line">		<span class="keyword">goto</span> HaveSpan</span><br><span class="line">	&#125;</span><br><span class="line">	throw(<span class="string">"grew heap, but no adequate free span found"</span>)</span><br><span class="line"></span><br><span class="line">HaveSpan:</span><br><span class="line">	s := t.span()</span><br><span class="line">	<span class="keyword">if</span> s.state != mSpanFree &#123;</span><br><span class="line">		throw(<span class="string">"candidate mspan for allocation is not free"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// First, subtract any memory that was released back to</span></span><br><span class="line">	<span class="comment">// the OS from s. We will add back what's left if necessary.</span></span><br><span class="line">	memstats.heap_released -= <span class="keyword">uint64</span>(s.released())</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> s.npages == npage &#123;</span><br><span class="line">		h.free.erase(t)</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> s.npages &gt; npage &#123;</span><br><span class="line">    <span class="comment">// 若得到的span空间大于npage，则用多余的空间生成一个新的span，并置于mheap.free中</span></span><br><span class="line">		<span class="comment">// Trim off the lower bits and make that our new span.</span></span><br><span class="line">		<span class="comment">// Do this in-place since this operation does not</span></span><br><span class="line">		<span class="comment">// affect the original span's location in the treap.</span></span><br><span class="line">		n := (*mspan)(h.spanalloc.alloc())</span><br><span class="line">		h.free.mutate(t, <span class="function"><span class="keyword">func</span><span class="params">(s *mspan)</span></span> &#123;</span><br><span class="line">			n.init(s.base(), npage)</span><br><span class="line">			s.npages -= npage</span><br><span class="line">			s.startAddr = s.base() + npage*pageSize</span><br><span class="line">			h.setSpan(s.base()<span class="number">-1</span>, n)</span><br><span class="line">			h.setSpan(s.base(), s)</span><br><span class="line">			h.setSpan(n.base(), n)</span><br><span class="line">			n.needzero = s.needzero</span><br><span class="line">			<span class="comment">// n may not be big enough to actually be scavenged, but that's fine.</span></span><br><span class="line">			<span class="comment">// We still want it to appear to be scavenged so that we can do the</span></span><br><span class="line">			<span class="comment">// right bookkeeping later on in this function (i.e. sysUsed).</span></span><br><span class="line">			n.scavenged = s.scavenged</span><br><span class="line">			<span class="comment">// Check if s is still scavenged.</span></span><br><span class="line">			<span class="keyword">if</span> s.scavenged &#123;</span><br><span class="line">				start, end := s.physPageBounds()</span><br><span class="line">				<span class="keyword">if</span> start &lt; end &#123;</span><br><span class="line">					memstats.heap_released += <span class="keyword">uint64</span>(end - start)</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					s.scavenged = <span class="literal">false</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;)</span><br><span class="line">		s = n</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		throw(<span class="string">"candidate mspan for allocation is too small"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// "Unscavenge" s only AFTER splitting so that</span></span><br><span class="line">	<span class="comment">// we only sysUsed whatever we actually need.</span></span><br><span class="line">	<span class="keyword">if</span> s.scavenged &#123;</span><br><span class="line">		<span class="comment">// sysUsed all the pages that are actually available</span></span><br><span class="line">		<span class="comment">// in the span. Note that we don't need to decrement</span></span><br><span class="line">		<span class="comment">// heap_released since we already did so earlier.</span></span><br><span class="line">		sysUsed(unsafe.Pointer(s.base()), s.npages&lt;&lt;_PageShift)</span><br><span class="line">		s.scavenged = <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新heapArena中的span信息</span></span><br><span class="line">	h.setSpans(s.base(), npage, s)</span><br><span class="line"></span><br><span class="line">	*stat += <span class="keyword">uint64</span>(npage &lt;&lt; _PageShift)</span><br><span class="line">	memstats.heap_idle -= <span class="keyword">uint64</span>(npage &lt;&lt; _PageShift)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> s.inList() &#123;</span><br><span class="line">		throw(<span class="string">"still in list"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="mheap-grow"><a href="#mheap-grow" class="headerlink" title="mheap.grow"></a>mheap.grow</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Try to add at least npage pages of memory to the heap,</span></span><br><span class="line"><span class="comment">// returning whether it worked.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// h must be locked.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span> <span class="title">grow</span><span class="params">(npage <span class="keyword">uintptr</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	ask := npage &lt;&lt; _PageShift</span><br><span class="line"></span><br><span class="line">	nBase := round(h.curArena.base+ask, physPageSize)</span><br><span class="line">	<span class="keyword">if</span> nBase &gt; h.curArena.end &#123;</span><br><span class="line">    <span class="comment">// 当前arena未有足够的空间，则需要额外分配更多的arena空间</span></span><br><span class="line">		<span class="comment">// Not enough room in the current arena. Allocate more</span></span><br><span class="line">		<span class="comment">// arena space. This may not be contiguous with the</span></span><br><span class="line">		<span class="comment">// current arena, so we have to request the full ask.</span></span><br><span class="line">    <span class="comment">// 从OS中申请arena空间</span></span><br><span class="line">		av, asize := h.sysAlloc(ask)</span><br><span class="line">		<span class="keyword">if</span> av == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">"runtime: out of memory: cannot allocate "</span>, ask, <span class="string">"-byte block ("</span>, memstats.heap_sys, <span class="string">" in use)\n"</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">uintptr</span>(av) == h.curArena.end &#123;</span><br><span class="line">      <span class="comment">// 若新分配的arena紧接着当前arean，则直接append到原arena后面</span></span><br><span class="line">			<span class="comment">// The new space is contiguous with the old</span></span><br><span class="line">			<span class="comment">// space, so just extend the current space.</span></span><br><span class="line">			h.curArena.end = <span class="keyword">uintptr</span>(av) + asize</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 若并非紧挨着，则将多余的空间，生成成span插入mheap.free</span></span><br><span class="line">			<span class="comment">// The new space is discontiguous. Track what</span></span><br><span class="line">			<span class="comment">// remains of the current space and switch to</span></span><br><span class="line">			<span class="comment">// the new space. This should be rare.</span></span><br><span class="line">			<span class="keyword">if</span> size := h.curArena.end - h.curArena.base; size != <span class="number">0</span> &#123;</span><br><span class="line">				h.growAddSpan(unsafe.Pointer(h.curArena.base), size)</span><br><span class="line">			&#125;</span><br><span class="line">      <span class="comment">// 切换到新的arena空间</span></span><br><span class="line">			<span class="comment">// Switch to the new space.</span></span><br><span class="line">			h.curArena.base = <span class="keyword">uintptr</span>(av)</span><br><span class="line">			h.curArena.end = <span class="keyword">uintptr</span>(av) + asize</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// The memory just allocated counts as both released</span></span><br><span class="line">		<span class="comment">// and idle, even though it's not yet backed by spans.</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">// The allocation is always aligned to the heap arena</span></span><br><span class="line">		<span class="comment">// size which is always &gt; physPageSize, so its safe to</span></span><br><span class="line">		<span class="comment">// just add directly to heap_released. Coalescing, if</span></span><br><span class="line">		<span class="comment">// possible, will also always be correct in terms of</span></span><br><span class="line">		<span class="comment">// accounting, because s.base() must be a physical</span></span><br><span class="line">		<span class="comment">// page boundary.</span></span><br><span class="line">		memstats.heap_released += <span class="keyword">uint64</span>(asize)</span><br><span class="line">		memstats.heap_idle += <span class="keyword">uint64</span>(asize)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Recalculate nBase</span></span><br><span class="line">		nBase = round(h.curArena.base+ask, physPageSize)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 分配nBase-v大小的空间，生成span并回填mheap.free</span></span><br><span class="line">	<span class="comment">// Grow into the current arena.</span></span><br><span class="line">	v := h.curArena.base</span><br><span class="line">	h.curArena.base = nBase</span><br><span class="line">	h.growAddSpan(unsafe.Pointer(v), nBase-v)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="mheap-growAddSpan"><a href="#mheap-growAddSpan" class="headerlink" title="mheap.growAddSpan"></a>mheap.growAddSpan</h4><p>根据新的空间创建新的span，回填入mheap.free中</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// growAddSpan adds a free span when the heap grows into [v, v+size).</span></span><br><span class="line"><span class="comment">// This memory must be in the Prepared state (not Ready).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// h must be locked.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span> <span class="title">growAddSpan</span><span class="params">(v unsafe.Pointer, size <span class="keyword">uintptr</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Scavenge some pages to make up for the virtual memory space</span></span><br><span class="line">	<span class="comment">// we just allocated, but only if we need to.</span></span><br><span class="line">	h.scavengeIfNeededLocked(size)</span><br><span class="line"></span><br><span class="line">	s := (*mspan)(h.spanalloc.alloc())</span><br><span class="line">	s.init(<span class="keyword">uintptr</span>(v), size/pageSize)</span><br><span class="line">	h.setSpans(s.base(), s.npages, s)</span><br><span class="line">	s.state = mSpanFree</span><br><span class="line">	<span class="comment">// [v, v+size) is always in the Prepared state. The new span</span></span><br><span class="line">	<span class="comment">// must be marked scavenged so the allocator transitions it to</span></span><br><span class="line">	<span class="comment">// Ready when allocating from it.</span></span><br><span class="line">	s.scavenged = <span class="literal">true</span></span><br><span class="line">	<span class="comment">// This span is both released and idle, but grow already</span></span><br><span class="line">	<span class="comment">// updated both memstats.</span></span><br><span class="line">	h.coalesce(s)</span><br><span class="line">	h.free.insert(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="学到了什么"><a href="#学到了什么" class="headerlink" title="学到了什么"></a>学到了什么</h1><ul>
<li>本地线程缓存，提高性能：通过mcache缓存小对象的span，并优先在mcache中分配，避免锁损耗</li>
<li>无处不在的<a href="https://www.jianshu.com/p/6082a2f7df8e" target="_blank" rel="noopener">BitMap</a>应用场景：通过二进制位来映射对象，例如mspan.allocBits用以表示对象是否分配</li>
<li>多层级的分配策略：自低向上，性能损耗越来越高，频繁度则由高到低，因此也能有效提高性能。思想上类似CPU中的多级缓存</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文主要介绍了Go内存分配中的一些重要组件以及分配算法。可以看到，其主要思想还是基于TCMalloc的策略，将对象根据大小分类，并使用不同的分配策略。此外，还采用逐层的内存申请策略，大大提高了内存分配性能。</p>
<p>此外，在分配过程中，穿插了各种GC相关的代码，因此Go的内存分配是与GC紧密相连的，这我将在GC篇中详解。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://google.github.io/tcmalloc/" target="_blank" rel="noopener">https://google.github.io/tcmalloc/</a></li>
<li><a href="http://goog-perftools.sourceforge.net/doc/tcmalloc.html" target="_blank" rel="noopener">http://goog-perftools.sourceforge.net/doc/tcmalloc.html</a></li>
<li><a href="https://medium.com/@ankur_anand/a-visual-guide-to-golang-memory-allocator-from-ground-up-e132258453ed" target="_blank" rel="noopener">https://medium.com/@ankur_anand/a-visual-guide-to-golang-memory-allocator-from-ground-up-e132258453ed</a></li>
<li><a href="https://www.cnblogs.com/zkweb/p/7880099.html" target="_blank" rel="noopener">https://www.cnblogs.com/zkweb/p/7880099.html</a></li>
<li><a href="https://www.cnblogs.com/luozhiyun/p/14349331.html" target="_blank" rel="noopener">https://www.cnblogs.com/luozhiyun/p/14349331.html</a></li>
<li><a href="https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-memory-allocator/" target="_blank" rel="noopener">https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-memory-allocator/</a></li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/go/" rel="tag"># go</a>
          
            <a href="/tags/golang/" rel="tag"># golang</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/01/09/memory-optimize-best-practice-for-golang/" rel="next" title="Golang内存优化实践指南">
                <i class="fa fa-chevron-left"></i> Golang内存优化实践指南
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Eren Ming</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/erenming" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:erenming233@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#为什么需要内存分配器？"><span class="nav-number">1.</span> <span class="nav-text">为什么需要内存分配器？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#实现原理"><span class="nav-number">2.</span> <span class="nav-text">实现原理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数据结构"><span class="nav-number">3.</span> <span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#heapArena"><span class="nav-number">3.0.1.</span> <span class="nav-text">heapArena</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mheap"><span class="nav-number">3.0.2.</span> <span class="nav-text">mheap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mcentral"><span class="nav-number">3.0.3.</span> <span class="nav-text">mcentral</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mcache"><span class="nav-number">3.0.4.</span> <span class="nav-text">mcache</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mspan"><span class="nav-number">3.0.5.</span> <span class="nav-text">mspan</span></a></li></ol></li></ol><li class="nav-item nav-level-1"><a class="nav-link" href="#算法"><span class="nav-number">4.</span> <span class="nav-text">算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#分配内存"><span class="nav-number">4.1.</span> <span class="nav-text">分配内存</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#源码分析"><span class="nav-number">5.</span> <span class="nav-text">源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#mallocgc函数"><span class="nav-number">5.0.1.</span> <span class="nav-text">mallocgc函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#nextFreeFast函数"><span class="nav-number">5.0.1.1.</span> <span class="nav-text">nextFreeFast函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mcache-nextFree函数"><span class="nav-number">5.0.1.2.</span> <span class="nav-text">mcache.nextFree函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mcache-refill函数"><span class="nav-number">5.0.1.3.</span> <span class="nav-text">mcache.refill函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mcentral-cacheSpan函数"><span class="nav-number">5.0.1.4.</span> <span class="nav-text">mcentral.cacheSpan函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mcentral-grow函数"><span class="nav-number">5.0.1.5.</span> <span class="nav-text">mcentral.grow函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mheap-alloc函数"><span class="nav-number">5.0.1.6.</span> <span class="nav-text">mheap.alloc函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mheap-alloc-m"><span class="nav-number">5.0.1.7.</span> <span class="nav-text">mheap.alloc_m</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mheap-allocSpanLocked"><span class="nav-number">5.0.1.8.</span> <span class="nav-text">mheap.allocSpanLocked</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mheap-grow"><span class="nav-number">5.0.1.9.</span> <span class="nav-text">mheap.grow</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mheap-growAddSpan"><span class="nav-number">5.0.1.10.</span> <span class="nav-text">mheap.growAddSpan</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#学到了什么"><span class="nav-number">6.</span> <span class="nav-text">学到了什么</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#总结"><span class="nav-number">7.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考"><span class="nav-number">8.</span> <span class="nav-text">参考</span></a></li></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  #<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Eren Ming</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://erenming.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'https://erenming.com/2021/05/24/memory-manage-in-go/';
          this.page.identifier = '2021/05/24/memory-manage-in-go/';
          this.page.title = 'Go语言内存分配的原理与实现';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://erenming.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  














  





  

  

  

  
  

  

  

  

</body>
</html>
