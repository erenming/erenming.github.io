<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[刷题总结]二分搜索 | Nothing Special</title><meta name=keywords content="Algorithm"><meta name=description content="二分搜索算法，又称折半搜索，是一种通过寻找中点并不断减半搜索范围的算法，时间复杂度为O(logN)，其算法流程大致如下所述：
 首先，其必须作用于有序数组上，找到中点并与目标值进行比较 若目标值比中点小，则将搜索范围缩小为左半数组；反之则将搜索范围缩小为右半数组 重复1，2步骤，直到终点与目标值相等  二分搜索的算法流程看起来很简单，然而实际的题目可能会有各种变化和细节，因此写好一个二分搜索算法并不简单。
在我看来，二分搜索的关键点在于问题的划分点以及子集的选择，而这两块也最容易产生变体：
  有序性变体：目标序列并非严格有序，或者说有序性需要你自行构造
  二分选择变体：左右子集的选择算法往往不尽相同
  此外，我们需要特别注意细节，因此编写中应当尽量使用else if而非else，力求覆盖到每种case
框架 func search(nums []int, target int) int {  lo, hi := 0, n-1  for less(lo, hi) {  mid := getmid(lo, hi)  if equalcase(mid, target) {  // 1. 先考虑相等情况  } else if lesscase(target, mid) {  // 2. 再考虑其他情况  } else if ...  } } 题目详解 33."><meta name=author content="erenming"><link rel=canonical href=https://erenming.github.io/posts/algorithm-binary-search/><link crossorigin=anonymous href=/assets/css/stylesheet.min.ec8da366ca2fb647537ccb7a8f6fa5b4e9cd3c7a0d3171dd2d3baad1e49c8bfc.css integrity="sha256-7I2jZsovtkdTfMt6j2+ltOnNPHoNMXHdLTuq0eSci/w=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.2840b7fccd34145847db71a290569594bdbdb00047097f75d6495d162f5d7dff.js integrity="sha256-KEC3/M00FFhH23GikFaVlL29sABHCX911kldFi9dff8=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://erenming.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://erenming.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://erenming.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://erenming.github.io/apple-touch-icon.png><link rel=mask-icon href=https://erenming.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://erenming.github.io/posts/algorithm-binary-search/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="[刷题总结]二分搜索"><meta property="og:description" content="二分搜索算法，又称折半搜索，是一种通过寻找中点并不断减半搜索范围的算法，时间复杂度为O(logN)，其算法流程大致如下所述：
 首先，其必须作用于有序数组上，找到中点并与目标值进行比较 若目标值比中点小，则将搜索范围缩小为左半数组；反之则将搜索范围缩小为右半数组 重复1，2步骤，直到终点与目标值相等  二分搜索的算法流程看起来很简单，然而实际的题目可能会有各种变化和细节，因此写好一个二分搜索算法并不简单。
在我看来，二分搜索的关键点在于问题的划分点以及子集的选择，而这两块也最容易产生变体：
  有序性变体：目标序列并非严格有序，或者说有序性需要你自行构造
  二分选择变体：左右子集的选择算法往往不尽相同
  此外，我们需要特别注意细节，因此编写中应当尽量使用else if而非else，力求覆盖到每种case
框架 func search(nums []int, target int) int {  lo, hi := 0, n-1  for less(lo, hi) {  mid := getmid(lo, hi)  if equalcase(mid, target) {  // 1. 先考虑相等情况  } else if lesscase(target, mid) {  // 2. 再考虑其他情况  } else if ...  } } 题目详解 33."><meta property="og:type" content="article"><meta property="og:url" content="https://erenming.github.io/posts/algorithm-binary-search/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-11-04T13:27:25+08:00"><meta property="article:modified_time" content="2022-11-04T13:27:25+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="[刷题总结]二分搜索"><meta name=twitter:description content="二分搜索算法，又称折半搜索，是一种通过寻找中点并不断减半搜索范围的算法，时间复杂度为O(logN)，其算法流程大致如下所述：
 首先，其必须作用于有序数组上，找到中点并与目标值进行比较 若目标值比中点小，则将搜索范围缩小为左半数组；反之则将搜索范围缩小为右半数组 重复1，2步骤，直到终点与目标值相等  二分搜索的算法流程看起来很简单，然而实际的题目可能会有各种变化和细节，因此写好一个二分搜索算法并不简单。
在我看来，二分搜索的关键点在于问题的划分点以及子集的选择，而这两块也最容易产生变体：
  有序性变体：目标序列并非严格有序，或者说有序性需要你自行构造
  二分选择变体：左右子集的选择算法往往不尽相同
  此外，我们需要特别注意细节，因此编写中应当尽量使用else if而非else，力求覆盖到每种case
框架 func search(nums []int, target int) int {  lo, hi := 0, n-1  for less(lo, hi) {  mid := getmid(lo, hi)  if equalcase(mid, target) {  // 1. 先考虑相等情况  } else if lesscase(target, mid) {  // 2. 再考虑其他情况  } else if ...  } } 题目详解 33."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://erenming.github.io/posts/"},{"@type":"ListItem","position":2,"name":"[刷题总结]二分搜索","item":"https://erenming.github.io/posts/algorithm-binary-search/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[刷题总结]二分搜索","name":"[刷题总结]二分搜索","description":"二分搜索算法，又称折半搜索，是一种通过寻找中点并不断减半搜索范围的算法，时间复杂度为O(logN)，其算法流程大致如下所述：\n 首先，其必须作用于有序数组上，找到中点并与目标值进行比较 若目标值比中点小，则将搜索范围缩小为左半数组；反之则将搜索范围缩小为右半数组 重复1，2步骤，直到终点与目标值相等  二分搜索的算法流程看起来很简单，然而实际的题目可能会有各种变化和细节，因此写好一个二分搜索算法并不简单。\n在我看来，二分搜索的关键点在于问题的划分点以及子集的选择，而这两块也最容易产生变体：\n  有序性变体：目标序列并非严格有序，或者说有序性需要你自行构造\n  二分选择变体：左右子集的选择算法往往不尽相同\n  此外，我们需要特别注意细节，因此编写中应当尽量使用else if而非else，力求覆盖到每种case\n框架 func search(nums []int, target int) int {  lo, hi := 0, n-1  for less(lo, hi) {  mid := getmid(lo, hi)  if equalcase(mid, target) {  // 1. 先考虑相等情况  } else if lesscase(target, mid) {  // 2. 再考虑其他情况  } else if ...  } } 题目详解 33.","keywords":["Algorithm"],"articleBody":"二分搜索算法，又称折半搜索，是一种通过寻找中点并不断减半搜索范围的算法，时间复杂度为O(logN)，其算法流程大致如下所述：\n 首先，其必须作用于有序数组上，找到中点并与目标值进行比较 若目标值比中点小，则将搜索范围缩小为左半数组；反之则将搜索范围缩小为右半数组 重复1，2步骤，直到终点与目标值相等  二分搜索的算法流程看起来很简单，然而实际的题目可能会有各种变化和细节，因此写好一个二分搜索算法并不简单。\n在我看来，二分搜索的关键点在于问题的划分点以及子集的选择，而这两块也最容易产生变体：\n  有序性变体：目标序列并非严格有序，或者说有序性需要你自行构造\n  二分选择变体：左右子集的选择算法往往不尽相同\n  此外，我们需要特别注意细节，因此编写中应当尽量使用else if而非else，力求覆盖到每种case\n框架 func search(nums []int, target int) int {  lo, hi := 0, n-1  for less(lo, hi) {  mid := getmid(lo, hi)  if equalcase(mid, target) {  // 1. 先考虑相等情况  } else if lesscase(target, mid) {  // 2. 再考虑其他情况  } else if ...  } } 题目详解 33. 搜索旋转排序数组 有序性变体\n此题题意为在一个旋转的有序数组中搜索目标值的下标，此题的关键在于选边，因为有且仅有左边严格有序或右边严格有序。\nfunc search(nums []int, target int) int { \tn := len(nums) \tlo, hi := 0, n-1 \tfor lo  hi { \tmid := lo + (hi-lo)/2 \tif nums[mid] == target { \treturn mid \t} else if nums[lo]  nums[mid] { // 左边严格有序 \tif nums[lo]  target \u0026\u0026 target nums[mid] { // 目标值在左边序列 \thi = mid - 1 // 搜索左边序列 \t} else { \tlo = mid + 1 // 否则搜索右边序列 \t} \t} else { // 右边严格有序 \tif nums[hi] = target \u0026\u0026 target  nums[mid] { // 目标值在右边序列 \tlo = mid + 1 // 搜素右边序列 \t} else { \thi = mid - 1 // 否则搜索左边序列 \t} \t} \t} \treturn -1 } 162. 寻找峰值 此题存在有序性变体，二分选择条件变体。\n有序性：局部有序\n二分选择：通过比较相邻两元素的大小，来判断峰值所在的子序列\nfunc findPeakElement(nums []int) int { \tn := len(nums) \tlo, hi := 0, n-1 \tfor lo hi { \tmid := lo + (hi-lo)/2 \tif nums[mid]  nums[mid+1] { // 说明是上坡，峰值在右侧 \tlo = mid + 1 \t} else { // 说明是下坡，峰值在左侧 \thi = mid \t} \t} \treturn lo } 209. 长度最小的子数组 此题存在有序性变体。nums为正整数序列，因此其前缀和序列为单调非减序列，我们构造前缀和序列sums。\ntarget满足当j  i 时，sums[j] - sums[i] = target\n func minSubArrayLen(target int, nums []int) int { \tn := len(nums) \t// sums为前缀和序列  // sums[i]表示长度为i的前缀和 \tsums := make([]int, n+1) \tfor i := 1; i sums); i++ { \tsums[i] = nums[i-1] + sums[i-1] \t} \tres := math.MaxInt64 \tfor i := 0; i n+1; i++ { \tneed := target + sums[i] // 根据公式，我们需要通过二分法查找sums[idx]=need的下标 \tlo, hi := i+1, n \tk := i \tfor lo  hi { \tmid := lo + (hi-lo)/2 \tif need == sums[mid] { // 等于need时，由于是查找最小序列，因此取左边序列 \tk = mid // 更新下标k \thi = mid - 1 \t} else if need sums[mid] { // 小于need时，查找左边序列 \tk = mid // 更新下标k \thi = mid - 1 \t} else { // 大于need时，查找右边序列 \tlo = mid + 1 \t} \t} \tif k  i { // 找到对应下标时，更新res \tres = min(res, k-i) \t} \t} \tif res == math.MaxInt64 { \treturn 0 \t} \treturn res }  func min(x, y int) int { \tif x y { \treturn x \t} \treturn y } 287. 寻找重复数 此题需要对鸽笼原理有所了解，同时存在有序性变体和二分选择变体。根据鸽笼原理，我们可以知道，对于x，1这是因为nums中的数除了重复数都跟[1…n]中的数一一对应，重复数在左侧则会使得中位数右移，重复数在右侧则会使中位数左移。\n对于[1..n]序列来说，我们分析可得:\n 对于重复数位于左侧：[1, 2, 2, 3, 4, 5]，mid为3，右移了一位\n对于重复数位于右侧：[1, 2, 3, 4, 5, 5]，mid为3，左移了一位\n func findDuplicate(nums []int) int { \tlo, hi := 1, len(nums)-1 // 这里搜索的是[1..n]的有序序列 \tfor lo hi { \tmid := lo + (hi-lo)/2 \tcnt := 0 \tfor _, item := range nums { \tif item  mid { \tcnt++ \t} \t} \tif cnt  mid { \thi = mid \t} else if cnt == mid { // 相等时，重复数在右侧 \tlo = mid+1 \t} else { \tlo = mid+1 \t} \t} \treturn lo } 540. 有序数组中的单一元素 此题存在二分选择变体，根据有序序列的下标性质\n 若mid为偶数，且nums[mid] == nums[mid+1]，则单一元素在右边，否则在左边 若mid为奇数，且nums[mid] == nums[mid+1]，则单一元素在左边，否则在右边   func singleNonDuplicate(nums []int) int { \tn := len(nums) \tlo, hi := 0, n-1 \tfor lo hi { \tmid := lo + (hi-lo)/2 \tif nums[mid] == nums[mid+1] { \tif mid%2 == 1 { \thi = mid - 1 \t} else { \tlo = mid \t} \t} else { \tif mid%2 == 1 { \tlo = mid + 1 \t} else { \thi = mid \t} \t} \t} \treturn nums[hi] } 参考  https://en.wikipedia.org/wiki/Binary_search_algorithm https://www.cnblogs.com/kyoner/p/11080078.html  ","wordCount":"560","inLanguage":"zh","datePublished":"2022-11-04T13:27:25+08:00","dateModified":"2022-11-04T13:27:25+08:00","author":{"@type":"Person","name":"erenming"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://erenming.github.io/posts/algorithm-binary-search/"},"publisher":{"@type":"Organization","name":"Nothing Special","logo":{"@type":"ImageObject","url":"https://erenming.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://erenming.github.io/ accesskey=h title="Nothing Special (Alt + H)">Nothing Special</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://erenming.github.io/en/ title=English aria-label=English>En</a></li></ul></span></div><ul id=menu><li><a href=https://erenming.github.io/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://erenming.github.io/archives/ title=归档><span>归档</span></a></li><li><a href=https://erenming.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://erenming.github.io/readings/ title=书单><span>书单</span></a></li><li><a href=https://erenming.github.io/about/ title=关于><span>关于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>[刷题总结]二分搜索</h1><div class=post-meta><span title="2022-11-04 13:27:25 +0800 +0800">十一月 4, 2022</span>&nbsp;·&nbsp;3 分钟&nbsp;·&nbsp;erenming</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e6%a1%86%e6%9e%b6 aria-label=框架>框架</a></li><li><a href=#%e9%a2%98%e7%9b%ae%e8%af%a6%e8%a7%a3 aria-label=题目详解>题目详解</a><ul><li><a href=#33-%e6%90%9c%e7%b4%a2%e6%97%8b%e8%bd%ac%e6%8e%92%e5%ba%8f%e6%95%b0%e7%bb%84httpsleetcodecnproblemssearch-in-rotated-sorted-arraydescription aria-label="33. 搜索旋转排序数组"><a href=https://leetcode.cn/problems/search-in-rotated-sorted-array/description/>33. 搜索旋转排序数组</a></a></li><li><a href=#162-%e5%af%bb%e6%89%be%e5%b3%b0%e5%80%bchttpsleetcodecnproblemsfind-peak-elementdescription aria-label="162. 寻找峰值"><a href=https://leetcode.cn/problems/find-peak-element/description/>162. 寻找峰值</a></a></li><li><a href=#209-%e9%95%bf%e5%ba%a6%e6%9c%80%e5%b0%8f%e7%9a%84%e5%ad%90%e6%95%b0%e7%bb%84httpsleetcodecnproblemsminimum-size-subarray-sumdescription aria-label="209. 长度最小的子数组"><a href=https://leetcode.cn/problems/minimum-size-subarray-sum/description/>209. 长度最小的子数组</a></a></li><li><a href=#287-%e5%af%bb%e6%89%be%e9%87%8d%e5%a4%8d%e6%95%b0httpsleetcodecnproblemsfind-the-duplicate-numberdescription aria-label="287. 寻找重复数"><a href=https://leetcode.cn/problems/find-the-duplicate-number/description/>287. 寻找重复数</a></a></li><li><a href=#540-%e6%9c%89%e5%ba%8f%e6%95%b0%e7%bb%84%e4%b8%ad%e7%9a%84%e5%8d%95%e4%b8%80%e5%85%83%e7%b4%a0httpsleetcodecnproblemssingle-element-in-a-sorted-arraydescription aria-label="540. 有序数组中的单一元素"><a href=https://leetcode.cn/problems/single-element-in-a-sorted-array/description/>540. 有序数组中的单一元素</a></a></li></ul></li><li><a href=#%e5%8f%82%e8%80%83 aria-label=参考>参考</a></li></ul></div></details></div><div class=post-content><p>二分搜索算法，又称折半搜索，是一种通过寻找中点并不断减半搜索范围的算法，时间复杂度为<code>O(logN)</code>，其算法流程大致如下所述：</p><ol><li>首先，其必须作用于有序数组上，找到<strong>中点</strong>并与目标值进行比较</li><li>若目标值比中点小，则将搜索范围缩小为左半数组；反之则将搜索范围缩小为右半数组</li><li>重复1，2步骤，直到终点与目标值相等</li></ol><p>二分搜索的算法流程看起来很简单，然而实际的题目可能会有各种变化和细节，因此写好一个二分搜索算法并不简单。</p><p>在我看来，二分搜索的关键点在于问题的<strong>划分点</strong>以及<strong>子集的选择</strong>，而这两块也最容易产生变体：</p><ul><li><p>有序性变体：目标序列并非严格有序，或者说有序性需要你自行构造</p></li><li><p>二分选择变体：左右子集的选择算法往往不尽相同</p></li></ul><p>此外，我们需要特别<strong>注意细节</strong>，因此编写中应当尽量使用<code>else if</code>而非<code>else</code>，力求覆盖到每种case</p><h1 id=框架>框架<a hidden class=anchor aria-hidden=true href=#框架>#</a></h1><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>search</span>(<span style=color:#a6e22e>nums</span> []<span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>target</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>lo</span>, <span style=color:#a6e22e>hi</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>, <span style=color:#a6e22e>n</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>less</span>(<span style=color:#a6e22e>lo</span>, <span style=color:#a6e22e>hi</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>mid</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getmid</span>(<span style=color:#a6e22e>lo</span>, <span style=color:#a6e22e>hi</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>equalcase</span>(<span style=color:#a6e22e>mid</span>, <span style=color:#a6e22e>target</span>) {
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 1. 先考虑相等情况
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>lesscase</span>(<span style=color:#a6e22e>target</span>, <span style=color:#a6e22e>mid</span>) {
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 2. 再考虑其他情况
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 id=题目详解>题目详解<a hidden class=anchor aria-hidden=true href=#题目详解>#</a></h1><h2 id=33-搜索旋转排序数组httpsleetcodecnproblemssearch-in-rotated-sorted-arraydescription><a href=https://leetcode.cn/problems/search-in-rotated-sorted-array/description/>33. 搜索旋转排序数组</a><a hidden class=anchor aria-hidden=true href=#33-搜索旋转排序数组httpsleetcodecnproblemssearch-in-rotated-sorted-arraydescription>#</a></h2><p><strong>有序性变体</strong></p><p>此题题意为在一个旋转的有序数组中搜索目标值的下标，此题的关键在于<strong>选边</strong>，因为有且仅有左边严格有序或右边严格有序。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>search</span>(<span style=color:#a6e22e>nums</span> []<span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>target</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>n</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>nums</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>lo</span>, <span style=color:#a6e22e>hi</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>, <span style=color:#a6e22e>n</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>lo</span> <span style=color:#f92672>&lt;=</span> <span style=color:#a6e22e>hi</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>mid</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>lo</span> <span style=color:#f92672>+</span> (<span style=color:#a6e22e>hi</span><span style=color:#f92672>-</span><span style=color:#a6e22e>lo</span>)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>nums</span>[<span style=color:#a6e22e>mid</span>] <span style=color:#f92672>==</span> <span style=color:#a6e22e>target</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>mid</span>
</span></span><span style=display:flex><span>		} <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>nums</span>[<span style=color:#a6e22e>lo</span>] <span style=color:#f92672>&lt;=</span> <span style=color:#a6e22e>nums</span>[<span style=color:#a6e22e>mid</span>] { <span style=color:#75715e>// 左边严格有序
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>nums</span>[<span style=color:#a6e22e>lo</span>] <span style=color:#f92672>&lt;=</span> <span style=color:#a6e22e>target</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>target</span> &lt; <span style=color:#a6e22e>nums</span>[<span style=color:#a6e22e>mid</span>] { <span style=color:#75715e>// 目标值在左边序列
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>				<span style=color:#a6e22e>hi</span> = <span style=color:#a6e22e>mid</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span> <span style=color:#75715e>// 搜索左边序列
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>lo</span> = <span style=color:#a6e22e>mid</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#75715e>// 否则搜索右边序列
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			}
</span></span><span style=display:flex><span>		} <span style=color:#66d9ef>else</span> { <span style=color:#75715e>// 右边严格有序
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>nums</span>[<span style=color:#a6e22e>hi</span>] <span style=color:#f92672>&gt;=</span> <span style=color:#a6e22e>target</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>target</span> &gt; <span style=color:#a6e22e>nums</span>[<span style=color:#a6e22e>mid</span>] {  <span style=color:#75715e>// 目标值在右边序列
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>				<span style=color:#a6e22e>lo</span> = <span style=color:#a6e22e>mid</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#75715e>// 搜素右边序列
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>hi</span> = <span style=color:#a6e22e>mid</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span> <span style=color:#75715e>// 否则搜索左边序列
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=162-寻找峰值httpsleetcodecnproblemsfind-peak-elementdescription><a href=https://leetcode.cn/problems/find-peak-element/description/>162. 寻找峰值</a><a hidden class=anchor aria-hidden=true href=#162-寻找峰值httpsleetcodecnproblemsfind-peak-elementdescription>#</a></h2><p>此题存在有序性变体，二分选择条件变体。</p><p>有序性：局部有序</p><p>二分选择：通过比较相邻两元素的大小，来判断峰值所在的子序列</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>findPeakElement</span>(<span style=color:#a6e22e>nums</span> []<span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>n</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>nums</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>lo</span>, <span style=color:#a6e22e>hi</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>, <span style=color:#a6e22e>n</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>lo</span> &lt; <span style=color:#a6e22e>hi</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>mid</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>lo</span> <span style=color:#f92672>+</span> (<span style=color:#a6e22e>hi</span><span style=color:#f92672>-</span><span style=color:#a6e22e>lo</span>)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>nums</span>[<span style=color:#a6e22e>mid</span>] <span style=color:#f92672>&lt;=</span> <span style=color:#a6e22e>nums</span>[<span style=color:#a6e22e>mid</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>] { <span style=color:#75715e>// 说明是上坡，峰值在右侧
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#a6e22e>lo</span> = <span style=color:#a6e22e>mid</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>		} <span style=color:#66d9ef>else</span> { <span style=color:#75715e>// 说明是下坡，峰值在左侧
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#a6e22e>hi</span> = <span style=color:#a6e22e>mid</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>lo</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=209-长度最小的子数组httpsleetcodecnproblemsminimum-size-subarray-sumdescription><a href=https://leetcode.cn/problems/minimum-size-subarray-sum/description/>209. 长度最小的子数组</a><a hidden class=anchor aria-hidden=true href=#209-长度最小的子数组httpsleetcodecnproblemsminimum-size-subarray-sumdescription>#</a></h2><p>此题存在有序性变体。nums为正整数序列，因此其前缀和序列为单调非减序列，我们构造前缀和序列sums。</p><p>target满足当j > i 时，sums[j] - sums[i] = target</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>minSubArrayLen</span>(<span style=color:#a6e22e>target</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>nums</span> []<span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>n</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>nums</span>)
</span></span><span style=display:flex><span>	<span style=color:#75715e>// sums为前缀和序列
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// sums[i]表示长度为i的前缀和
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>sums</span> <span style=color:#f92672>:=</span> make([]<span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>n</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>1</span>; <span style=color:#a6e22e>i</span> &lt; len(<span style=color:#a6e22e>sums</span>); <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>sums</span>[<span style=color:#a6e22e>i</span>] = <span style=color:#a6e22e>nums</span>[<span style=color:#a6e22e>i</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>+</span> <span style=color:#a6e22e>sums</span>[<span style=color:#a6e22e>i</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>res</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>math</span>.<span style=color:#a6e22e>MaxInt64</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>n</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>need</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>target</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>sums</span>[<span style=color:#a6e22e>i</span>] <span style=color:#75715e>// 根据公式，我们需要通过二分法查找sums[idx]=need的下标
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>lo</span>, <span style=color:#a6e22e>hi</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>i</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, <span style=color:#a6e22e>n</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>k</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>i</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>lo</span> <span style=color:#f92672>&lt;=</span> <span style=color:#a6e22e>hi</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>mid</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>lo</span> <span style=color:#f92672>+</span> (<span style=color:#a6e22e>hi</span><span style=color:#f92672>-</span><span style=color:#a6e22e>lo</span>)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>need</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>sums</span>[<span style=color:#a6e22e>mid</span>] { <span style=color:#75715e>// 等于need时，由于是查找最小序列，因此取左边序列
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>				<span style=color:#a6e22e>k</span> = <span style=color:#a6e22e>mid</span> <span style=color:#75715e>// 更新下标k
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>				<span style=color:#a6e22e>hi</span> = <span style=color:#a6e22e>mid</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>			} <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>need</span> &lt; <span style=color:#a6e22e>sums</span>[<span style=color:#a6e22e>mid</span>] { <span style=color:#75715e>// 小于need时，查找左边序列
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>				<span style=color:#a6e22e>k</span> = <span style=color:#a6e22e>mid</span> <span style=color:#75715e>// 更新下标k
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>				<span style=color:#a6e22e>hi</span> = <span style=color:#a6e22e>mid</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>			} <span style=color:#66d9ef>else</span> { <span style=color:#75715e>// 大于need时，查找右边序列
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>				<span style=color:#a6e22e>lo</span> = <span style=color:#a6e22e>mid</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>k</span> &gt; <span style=color:#a6e22e>i</span> { <span style=color:#75715e>// 找到对应下标时，更新res
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#a6e22e>res</span> = <span style=color:#a6e22e>min</span>(<span style=color:#a6e22e>res</span>, <span style=color:#a6e22e>k</span><span style=color:#f92672>-</span><span style=color:#a6e22e>i</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>res</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>math</span>.<span style=color:#a6e22e>MaxInt64</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>res</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>min</span>(<span style=color:#a6e22e>x</span>, <span style=color:#a6e22e>y</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>x</span> &lt; <span style=color:#a6e22e>y</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>x</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>y</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=287-寻找重复数httpsleetcodecnproblemsfind-the-duplicate-numberdescription><a href=https://leetcode.cn/problems/find-the-duplicate-number/description/>287. 寻找重复数</a><a hidden class=anchor aria-hidden=true href=#287-寻找重复数httpsleetcodecnproblemsfind-the-duplicate-numberdescription>#</a></h2><p>此题需要对鸽笼原理有所了解，同时存在有序性变体和二分选择变体。根据鸽笼原理，我们可以知道，对于x，1&lt;=x&lt;=n，若nums中小于等于x的数目大于x，则重复的数一定在左边子序列中。</p><p>这是因为nums中的数除了重复数都跟[1&mldr;n]中的数一一对应，重复数在左侧则会使得中位数右移，重复数在右侧则会使中位数左移。</p><p>对于[1..n]序列来说，我们分析可得:</p><blockquote><p>对于重复数位于左侧：[1, 2, 2, 3, 4, 5]，mid为3，右移了一位</p><p>对于重复数位于右侧：[1, 2, 3, 4, 5, 5]，mid为3，左移了一位</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>findDuplicate</span>(<span style=color:#a6e22e>nums</span> []<span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>lo</span>, <span style=color:#a6e22e>hi</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>1</span>, len(<span style=color:#a6e22e>nums</span>)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> <span style=color:#75715e>// 这里搜索的是[1..n]的有序序列
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>lo</span> &lt; <span style=color:#a6e22e>hi</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>mid</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>lo</span> <span style=color:#f92672>+</span> (<span style=color:#a6e22e>hi</span><span style=color:#f92672>-</span><span style=color:#a6e22e>lo</span>)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>cnt</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>item</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>nums</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>item</span> <span style=color:#f92672>&lt;=</span> <span style=color:#a6e22e>mid</span> {
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>cnt</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>cnt</span> &gt; <span style=color:#a6e22e>mid</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>hi</span> = <span style=color:#a6e22e>mid</span>
</span></span><span style=display:flex><span>		} <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>cnt</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>mid</span> { <span style=color:#75715e>// 相等时，重复数在右侧
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#a6e22e>lo</span> = <span style=color:#a6e22e>mid</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>		} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>lo</span> = <span style=color:#a6e22e>mid</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>lo</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=540-有序数组中的单一元素httpsleetcodecnproblemssingle-element-in-a-sorted-arraydescription><a href=https://leetcode.cn/problems/single-element-in-a-sorted-array/description/>540. 有序数组中的单一元素</a><a hidden class=anchor aria-hidden=true href=#540-有序数组中的单一元素httpsleetcodecnproblemssingle-element-in-a-sorted-arraydescription>#</a></h2><p>此题存在二分选择变体，根据有序序列的下标性质</p><ul><li>若mid为偶数，且nums[mid] == nums[mid+1]，则单一元素在右边，否则在左边</li><li>若mid为奇数，且nums[mid] == nums[mid+1]，则单一元素在左边，否则在右边</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>singleNonDuplicate</span>(<span style=color:#a6e22e>nums</span> []<span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>n</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>nums</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>lo</span>, <span style=color:#a6e22e>hi</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>, <span style=color:#a6e22e>n</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>lo</span> &lt; <span style=color:#a6e22e>hi</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>mid</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>lo</span> <span style=color:#f92672>+</span> (<span style=color:#a6e22e>hi</span><span style=color:#f92672>-</span><span style=color:#a6e22e>lo</span>)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>nums</span>[<span style=color:#a6e22e>mid</span>] <span style=color:#f92672>==</span> <span style=color:#a6e22e>nums</span>[<span style=color:#a6e22e>mid</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>] {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>mid</span><span style=color:#f92672>%</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span> {
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>hi</span> = <span style=color:#a6e22e>mid</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>			} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>lo</span> = <span style=color:#a6e22e>mid</span>
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>mid</span><span style=color:#f92672>%</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span> {
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>lo</span> = <span style=color:#a6e22e>mid</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>			} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>hi</span> = <span style=color:#a6e22e>mid</span>
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>nums</span>[<span style=color:#a6e22e>hi</span>]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 id=参考>参考<a hidden class=anchor aria-hidden=true href=#参考>#</a></h1><ul><li><a href=https://en.wikipedia.org/wiki/Binary_search_algorithm>https://en.wikipedia.org/wiki/Binary_search_algorithm</a></li><li><a href=https://www.cnblogs.com/kyoner/p/11080078.html>https://www.cnblogs.com/kyoner/p/11080078.html</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://erenming.github.io/tags/algorithm/>Algorithm</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://erenming.github.io/>Nothing Special</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(t=>{const n=t.parentNode.parentNode,e=document.createElement("button");e.classList.add("copy-code"),e.innerHTML="复制";function s(){e.innerHTML="已复制！",setTimeout(()=>{e.innerHTML="复制"},2e3)}e.addEventListener("click",o=>{if("clipboard"in navigator){navigator.clipboard.writeText(t.textContent),s();return}const e=document.createRange();e.selectNodeContents(t);const n=window.getSelection();n.removeAllRanges(),n.addRange(e);try{document.execCommand("copy"),s()}catch(e){}n.removeRange(e)}),n.classList.contains("highlight")?n.appendChild(e):n.parentNode.firstChild==n||(t.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?t.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(e):t.parentNode.appendChild(e))})</script></body></html>