<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Golang中的map实现 | JimmyJiang's Blog</title><meta name=keywords content="Go"><meta name=description content="总所周知，大多数语言中，字典的底层是哈希表，而且其算法也是十分清晰的。无论采用链表法还是开放寻址法，我们都能实现一个简单的哈希表结构。对于Go来说，它是具体如何实现哈希表的呢？以及，采取了哪些优化策略呢？
内存模型 map在内存的总体结构如下图所示。
头部结构体hmap type hmap struct { 	count int // 键值对个数 	flags uint8 	B uint8 // 2^B = 桶数量 	noverflow uint16 // 溢出桶的个数 	hash0 uint32 // hash seed  	buckets unsafe.Pointer // 哈希桶 	oldbuckets unsafe.Pointer // 原哈希桶，扩容时为非空 	nevacuate uintptr // 扩容进度，地址小于它的桶已被迁移了  	extra *mapextra // optional fields } hmap即为map编译后的内存表示，这里需要注意的有两点。
 B的值是根据负载因子(LoadFactor)以及存储的键值对数量，在创建或扩容时动态改变 buckets是一个指针，它指向一个bmap结构  桶结构体bmap type bmap struct { 	// tophash数组可以看做键值对的索引 	tophash [bucketCnt]uint8 	// 实际上编译器会动态添加下述属性  // keys [8]keytype  // values [8]valuetype  // padding uinptr  // overflow uinptr } 虽然bmap结构体中只有一个tophash数组，但实际上，其后跟着8个key的槽位、8个value的槽位、padding以及一个overflow指针。如下图所示"><meta name=author content><link rel=canonical href=https://erenming.github.io/posts/map-in-go/><link crossorigin=anonymous href=/assets/css/stylesheet.min.ec8da366ca2fb647537ccb7a8f6fa5b4e9cd3c7a0d3171dd2d3baad1e49c8bfc.css integrity="sha256-7I2jZsovtkdTfMt6j2+ltOnNPHoNMXHdLTuq0eSci/w=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.2840b7fccd34145847db71a290569594bdbdb00047097f75d6495d162f5d7dff.js integrity="sha256-KEC3/M00FFhH23GikFaVlL29sABHCX911kldFi9dff8=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://erenming.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://erenming.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://erenming.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://erenming.github.io/apple-touch-icon.png><link rel=mask-icon href=https://erenming.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Golang中的map实现"><meta property="og:description" content="总所周知，大多数语言中，字典的底层是哈希表，而且其算法也是十分清晰的。无论采用链表法还是开放寻址法，我们都能实现一个简单的哈希表结构。对于Go来说，它是具体如何实现哈希表的呢？以及，采取了哪些优化策略呢？
内存模型 map在内存的总体结构如下图所示。
头部结构体hmap type hmap struct { 	count int // 键值对个数 	flags uint8 	B uint8 // 2^B = 桶数量 	noverflow uint16 // 溢出桶的个数 	hash0 uint32 // hash seed  	buckets unsafe.Pointer // 哈希桶 	oldbuckets unsafe.Pointer // 原哈希桶，扩容时为非空 	nevacuate uintptr // 扩容进度，地址小于它的桶已被迁移了  	extra *mapextra // optional fields } hmap即为map编译后的内存表示，这里需要注意的有两点。
 B的值是根据负载因子(LoadFactor)以及存储的键值对数量，在创建或扩容时动态改变 buckets是一个指针，它指向一个bmap结构  桶结构体bmap type bmap struct { 	// tophash数组可以看做键值对的索引 	tophash [bucketCnt]uint8 	// 实际上编译器会动态添加下述属性  // keys [8]keytype  // values [8]valuetype  // padding uinptr  // overflow uinptr } 虽然bmap结构体中只有一个tophash数组，但实际上，其后跟着8个key的槽位、8个value的槽位、padding以及一个overflow指针。如下图所示"><meta property="og:type" content="article"><meta property="og:url" content="https://erenming.github.io/posts/map-in-go/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-02-01T17:28:15+00:00"><meta property="article:modified_time" content="2020-02-01T17:28:15+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Golang中的map实现"><meta name=twitter:description content="总所周知，大多数语言中，字典的底层是哈希表，而且其算法也是十分清晰的。无论采用链表法还是开放寻址法，我们都能实现一个简单的哈希表结构。对于Go来说，它是具体如何实现哈希表的呢？以及，采取了哪些优化策略呢？
内存模型 map在内存的总体结构如下图所示。
头部结构体hmap type hmap struct { 	count int // 键值对个数 	flags uint8 	B uint8 // 2^B = 桶数量 	noverflow uint16 // 溢出桶的个数 	hash0 uint32 // hash seed  	buckets unsafe.Pointer // 哈希桶 	oldbuckets unsafe.Pointer // 原哈希桶，扩容时为非空 	nevacuate uintptr // 扩容进度，地址小于它的桶已被迁移了  	extra *mapextra // optional fields } hmap即为map编译后的内存表示，这里需要注意的有两点。
 B的值是根据负载因子(LoadFactor)以及存储的键值对数量，在创建或扩容时动态改变 buckets是一个指针，它指向一个bmap结构  桶结构体bmap type bmap struct { 	// tophash数组可以看做键值对的索引 	tophash [bucketCnt]uint8 	// 实际上编译器会动态添加下述属性  // keys [8]keytype  // values [8]valuetype  // padding uinptr  // overflow uinptr } 虽然bmap结构体中只有一个tophash数组，但实际上，其后跟着8个key的槽位、8个value的槽位、padding以及一个overflow指针。如下图所示"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://erenming.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Golang中的map实现","item":"https://erenming.github.io/posts/map-in-go/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Golang中的map实现","name":"Golang中的map实现","description":"总所周知，大多数语言中，字典的底层是哈希表，而且其算法也是十分清晰的。无论采用链表法还是开放寻址法，我们都能实现一个简单的哈希表结构。对于Go来说，它是具体如何实现哈希表的呢？以及，采取了哪些优化策略呢？\n内存模型 map在内存的总体结构如下图所示。\n头部结构体hmap type hmap struct { \tcount int // 键值对个数 \tflags uint8 \tB uint8 // 2^B = 桶数量 \tnoverflow uint16 // 溢出桶的个数 \thash0 uint32 // hash seed  \tbuckets unsafe.Pointer // 哈希桶 \toldbuckets unsafe.Pointer // 原哈希桶，扩容时为非空 \tnevacuate uintptr // 扩容进度，地址小于它的桶已被迁移了  \textra *mapextra // optional fields } hmap即为map编译后的内存表示，这里需要注意的有两点。\n B的值是根据负载因子(LoadFactor)以及存储的键值对数量，在创建或扩容时动态改变 buckets是一个指针，它指向一个bmap结构  桶结构体bmap type bmap struct { \t// tophash数组可以看做键值对的索引 \ttophash [bucketCnt]uint8 \t// 实际上编译器会动态添加下述属性  // keys [8]keytype  // values [8]valuetype  // padding uinptr  // overflow uinptr } 虽然bmap结构体中只有一个tophash数组，但实际上，其后跟着8个key的槽位、8个value的槽位、padding以及一个overflow指针。如下图所示","keywords":["Go"],"articleBody":"总所周知，大多数语言中，字典的底层是哈希表，而且其算法也是十分清晰的。无论采用链表法还是开放寻址法，我们都能实现一个简单的哈希表结构。对于Go来说，它是具体如何实现哈希表的呢？以及，采取了哪些优化策略呢？\n内存模型 map在内存的总体结构如下图所示。\n头部结构体hmap type hmap struct { \tcount int // 键值对个数 \tflags uint8 \tB uint8 // 2^B = 桶数量 \tnoverflow uint16 // 溢出桶的个数 \thash0 uint32 // hash seed  \tbuckets unsafe.Pointer // 哈希桶 \toldbuckets unsafe.Pointer // 原哈希桶，扩容时为非空 \tnevacuate uintptr // 扩容进度，地址小于它的桶已被迁移了  \textra *mapextra // optional fields } hmap即为map编译后的内存表示，这里需要注意的有两点。\n B的值是根据负载因子(LoadFactor)以及存储的键值对数量，在创建或扩容时动态改变 buckets是一个指针，它指向一个bmap结构  桶结构体bmap type bmap struct { \t// tophash数组可以看做键值对的索引 \ttophash [bucketCnt]uint8 \t// 实际上编译器会动态添加下述属性  // keys [8]keytype  // values [8]valuetype  // padding uinptr  // overflow uinptr } 虽然bmap结构体中只有一个tophash数组，但实际上，其后跟着8个key的槽位、8个value的槽位、padding以及一个overflow指针。如下图所示\n这里，Go做了优化。\n 这里并没有把key/value作为一个entry，而是分开存储。主要是为了节省内存，有时可以避免使用padding(额外的内存)来对齐，比如map[int64]int8就完全不需要padding。  查找操作 查找操作总体和链表法的哈希表查找类似，即key — hashFunc(key) — mask(hash) — 桶的位置 — 遍历链表。其主要代码如下所示\nfunc mapaccess1(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer { \t... \talg := t.key.alg \thash := alg.hash(key, uintptr(h.hash0)) \tm := bucketMask(h.B) \t// 计算得到桶的位置bucket-k \tb := (*bmap)(add(h.buckets, (hash\u0026m)*uintptr(t.bucketsize)))  // 若正在扩容，老buckets则为非空 \t// 若bucket-k在老的buckets数组中，未被迁移，则使用老的 \tif c := h.oldbuckets; c != nil { \tif !h.sameSizeGrow() { \t// There used to be half as many buckets; mask down one more power of two. \tm = 1 \t} \toldb := (*bmap)(add(c, (hash\u0026m)*uintptr(t.bucketsize))) \tif !evacuated(oldb) { \tb = oldb \t} \t} \t// 根据tophash(hash), 在bucket-k中的tophash中查找key \ttop := tophash(hash)  // 找到对应的bucket后，遍历查找对应的key/value bucketloop: \tfor ; b != nil; b = b.overflow(t) { \tfor i := uintptr(0); i bucketCnt; i++ { \t... \t// 计算第i个位置的key的地址 \tk := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize)) \tif t.indirectkey() { \tk = *((*unsafe.Pointer)(k)) \t} \t// 比较tophash[i]上的k是否与目标key相等 \tif alg.equal(key, k) {  // 计算value的地址 \tv := add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.valuesize)) \tif t.indirectvalue() { \tv = *((*unsafe.Pointer)(v)) \t} \treturn v \t} \t} \t} \t// 若最终还是没找到，则返回nil \treturn unsafe.Pointer(\u0026zeroVal[0]) } 首先，Go通过对应类型的alg.hash计算得到hash值（各种类型的hash\u0026equal函数定义），取后B位作为buckets数组的下标(实际上为取余)，取高8位作为tophash的下标。\n然后，通过一个嵌套循环查找目标key：外层循环是遍历一个bmap单链表，它们通过overflow指针相连；内层循环则遍历tophash数组，逐个比较，当匹配成功时，则计算得到实际key的地址，比较两者，成功则返回。如下图所示\n这里，Go做了如下优化。\n 使用tophash数组，作为索引，用以判断key是否存在该bmap中，若确实存在，再使用较为耗时的比较算法判断key是否相等。  除了查找操作，map的插入、删除以及扩容操作也十分值得学习，大家可以去查阅相关源码\n本人才疏学浅，文章难免有些不足之处，非常欢迎大大们评论指出。\n参考  https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics#easy-footnote-1-3224 https://github.com/golang/go/blob/master/src/runtime/map.go https://studygolang.com/articles/25134 https://www.linkinstar.wiki/2019/06/03/golang/source-code/graphic-golang-map/ [https://github.com/qcrao/Go-Questions/blob/master/map/map%20%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88.md](https://github.com/qcrao/Go-Questions/blob/master/map/map 的底层实现原理是什么.md)  ","wordCount":"243","inLanguage":"en","datePublished":"2020-02-01T17:28:15Z","dateModified":"2020-02-01T17:28:15Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://erenming.github.io/posts/map-in-go/"},"publisher":{"@type":"Organization","name":"JimmyJiang's Blog","logo":{"@type":"ImageObject","url":"https://erenming.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://erenming.github.io/ accesskey=h title="JimmyJiang's Blog (Alt + H)">JimmyJiang's Blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://erenming.github.io/readings/ title=Readings><span>Readings</span></a></li><li><a href=https://erenming.github.io/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Golang中的map实现</h1><div class=post-meta><span title="2020-02-01 17:28:15 +0000 UTC">February 1, 2020</span></div></header><div class=post-content><p>总所周知，大多数语言中，字典的底层是哈希表，而且其算法也是十分清晰的。无论采用链表法还是开放寻址法，我们都能实现一个简单的哈希表结构。对于Go来说，它是具体如何实现哈希表的呢？以及，采取了哪些优化策略呢？</p><h2 id=内存模型>内存模型<a hidden class=anchor aria-hidden=true href=#内存模型>#</a></h2><p>map在内存的总体结构如下图所示。</p><h4 id=头部结构体hmap>头部结构体<code>hmap</code><a hidden class=anchor aria-hidden=true href=#头部结构体hmap>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>hmap</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>count</span>     <span style=color:#66d9ef>int</span> <span style=color:#75715e>// 键值对个数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>flags</span>     <span style=color:#66d9ef>uint8</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>B</span>         <span style=color:#66d9ef>uint8</span>  <span style=color:#75715e>// 2^B = 桶数量
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>noverflow</span> <span style=color:#66d9ef>uint16</span> <span style=color:#75715e>// 溢出桶的个数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>hash0</span>     <span style=color:#66d9ef>uint32</span> <span style=color:#75715e>// hash seed
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>buckets</span>    <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span> <span style=color:#75715e>// 哈希桶
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>oldbuckets</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span> <span style=color:#75715e>// 原哈希桶，扩容时为非空
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>nevacuate</span>  <span style=color:#66d9ef>uintptr</span>        <span style=color:#75715e>// 扩容进度，地址小于它的桶已被迁移了
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>extra</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>mapextra</span> <span style=color:#75715e>// optional fields
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p><code>hmap</code>即为map编译后的内存表示，这里需要注意的有两点。</p><ol><li>B的值是根据负载因子(LoadFactor)以及存储的键值对数量，在创建或扩容时动态改变</li><li>buckets是一个指针，它指向一个<code>bmap</code>结构</li></ol><h4 id=桶结构体bmap>桶结构体<code>bmap</code><a hidden class=anchor aria-hidden=true href=#桶结构体bmap>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>bmap</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// tophash数组可以看做键值对的索引
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>tophash</span> [<span style=color:#a6e22e>bucketCnt</span>]<span style=color:#66d9ef>uint8</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 实际上编译器会动态添加下述属性
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// keys     [8]keytype
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// values   [8]valuetype
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// padding  uinptr
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// overflow uinptr
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>虽然<code>bmap</code>结构体中只有一个tophash数组，但实际上，其后跟着8个key的槽位、8个value的槽位、padding以及一个<code>overflow</code>指针。如下图所示</p><p>这里，Go做了优化。</p><ol><li>这里并没有把key/value作为一个entry，而是分开存储。主要是为了节省内存，有时可以避免使用padding(额外的内存)来对齐，比如<code>map[int64]int8</code>就完全不需要padding。</li></ol><h2 id=查找操作>查找操作<a hidden class=anchor aria-hidden=true href=#查找操作>#</a></h2><p>查找操作总体和链表法的哈希表查找类似，即key &mdash;> hashFunc(key) &mdash;> mask(hash) &mdash;> 桶的位置 &mdash;> 遍历链表。其主要代码如下所示</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>mapaccess1</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>maptype</span>, <span style=color:#a6e22e>h</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hmap</span>, <span style=color:#a6e22e>key</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>) <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span> {
</span></span><span style=display:flex><span>	<span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>alg</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>key</span>.<span style=color:#a6e22e>alg</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>hash</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>alg</span>.<span style=color:#a6e22e>hash</span>(<span style=color:#a6e22e>key</span>, uintptr(<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>hash0</span>))
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>m</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>bucketMask</span>(<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>B</span>)
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 计算得到桶的位置bucket-k
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>b</span> <span style=color:#f92672>:=</span> (<span style=color:#f92672>*</span><span style=color:#a6e22e>bmap</span>)(<span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>buckets</span>, (<span style=color:#a6e22e>hash</span><span style=color:#f92672>&amp;</span><span style=color:#a6e22e>m</span>)<span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>bucketsize</span>)))
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 若正在扩容，老buckets则为非空
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 若bucket-k在老的buckets数组中，未被迁移，则使用老的
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>oldbuckets</span>; <span style=color:#a6e22e>c</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>sameSizeGrow</span>() {
</span></span><span style=display:flex><span>			<span style=color:#75715e>// There used to be half as many buckets; mask down one more power of two.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#a6e22e>m</span> <span style=color:#f92672>&gt;&gt;=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>oldb</span> <span style=color:#f92672>:=</span> (<span style=color:#f92672>*</span><span style=color:#a6e22e>bmap</span>)(<span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>c</span>, (<span style=color:#a6e22e>hash</span><span style=color:#f92672>&amp;</span><span style=color:#a6e22e>m</span>)<span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>bucketsize</span>)))
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>evacuated</span>(<span style=color:#a6e22e>oldb</span>) {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>b</span> = <span style=color:#a6e22e>oldb</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 根据tophash(hash), 在bucket-k中的tophash中查找key
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>top</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>tophash</span>(<span style=color:#a6e22e>hash</span>)
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 找到对应的bucket后，遍历查找对应的key/value
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>bucketloop</span>:
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> ; <span style=color:#a6e22e>b</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span>; <span style=color:#a6e22e>b</span> = <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>overflow</span>(<span style=color:#a6e22e>t</span>) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> uintptr(<span style=color:#ae81ff>0</span>); <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>bucketCnt</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>			<span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>			<span style=color:#75715e>// 计算第i个位置的key的地址
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#a6e22e>k</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>b</span>), <span style=color:#a6e22e>dataOffset</span><span style=color:#f92672>+</span><span style=color:#a6e22e>i</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>keysize</span>))
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>indirectkey</span>() {
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>k</span> = <span style=color:#f92672>*</span>((<span style=color:#f92672>*</span><span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>)(<span style=color:#a6e22e>k</span>))
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			<span style=color:#75715e>// 比较tophash[i]上的k是否与目标key相等
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>alg</span>.<span style=color:#a6e22e>equal</span>(<span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>k</span>) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 计算value的地址
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>				<span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>b</span>), <span style=color:#a6e22e>dataOffset</span><span style=color:#f92672>+</span><span style=color:#a6e22e>bucketCnt</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>keysize</span>)<span style=color:#f92672>+</span><span style=color:#a6e22e>i</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>valuesize</span>))
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>indirectvalue</span>() {
</span></span><span style=display:flex><span>					<span style=color:#a6e22e>v</span> = <span style=color:#f92672>*</span>((<span style=color:#f92672>*</span><span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>)(<span style=color:#a6e22e>v</span>))
</span></span><span style=display:flex><span>				}
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>v</span>
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 若最终还是没找到，则返回nil
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>zeroVal</span>[<span style=color:#ae81ff>0</span>])
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>首先，Go通过对应类型的<code>alg.hash</code>计算得到hash值（<a href=!https://github.com/golang/go/blob/master/src/runtime/alg.go>各种类型的hash&equal函数定义</a>），取后B位作为buckets数组的下标(实际上为取余)，取高8位作为tophash的下标。</p><p>然后，通过一个嵌套循环查找目标key：外层循环是遍历一个<code>bmap</code>单链表，它们通过<code>overflow</code>指针相连；内层循环则遍历tophash数组，逐个比较，当匹配成功时，则计算得到实际key的地址，比较两者，成功则返回。如下图所示</p><p>这里，Go做了如下优化。</p><ol><li>使用tophash数组，作为索引，用以判断key是否存在该bmap中，若确实存在，再使用较为耗时的比较算法判断key是否相等。</li></ol><p>除了查找操作，map的插入、删除以及扩容操作也十分值得学习，大家可以去查阅相关<a href=!https://github.com/golang/go/blob/master/src/runtime/map.go>源码</a></p><p><em>本人才疏学浅，文章难免有些不足之处，非常欢迎大大们评论指出。</em></p><h2 id=参考>参考<a hidden class=anchor aria-hidden=true href=#参考>#</a></h2><ol><li><a href=https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics#easy-footnote-1-3224>https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics#easy-footnote-1-3224</a></li><li><a href=https://github.com/golang/go/blob/master/src/runtime/map.go>https://github.com/golang/go/blob/master/src/runtime/map.go</a></li><li><a href=https://studygolang.com/articles/25134>https://studygolang.com/articles/25134</a></li><li><a href=https://www.linkinstar.wiki/2019/06/03/golang/source-code/graphic-golang-map/>https://www.linkinstar.wiki/2019/06/03/golang/source-code/graphic-golang-map/</a></li><li>[https://github.com/qcrao/Go-Questions/blob/master/map/map%20%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88.md](<a href=https://github.com/qcrao/Go-Questions/blob/master/map/map>https://github.com/qcrao/Go-Questions/blob/master/map/map</a> 的底层实现原理是什么.md)</li></ol></div><footer class=post-footer><ul class=post-tags><li><a href=https://erenming.github.io/tags/go/>Go</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://erenming.github.io/>JimmyJiang's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(t=>{const n=t.parentNode.parentNode,e=document.createElement("button");e.classList.add("copy-code"),e.innerHTML="copy";function s(){e.innerHTML="copied!",setTimeout(()=>{e.innerHTML="copy"},2e3)}e.addEventListener("click",o=>{if("clipboard"in navigator){navigator.clipboard.writeText(t.textContent),s();return}const e=document.createRange();e.selectNodeContents(t);const n=window.getSelection();n.removeAllRanges(),n.addRange(e);try{document.execCommand("copy"),s()}catch(e){}n.removeRange(e)}),n.classList.contains("highlight")?n.appendChild(e):n.parentNode.firstChild==n||(t.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?t.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(e):t.parentNode.appendChild(e))})</script></body></html>