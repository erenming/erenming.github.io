<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>浅析Go内存分配器的实现 | Nothing Special</title>
<meta name=keywords content="Go"><meta name=description content="为什么需要内存分配器？ 总说周知，内存作为一种相对稀缺的资源，在操作系统中以虚拟内存的形式来作为一种内存抽象提供给进程，这里可以简单地把它看做一个连续的地址集合{0, 1, 2, ..., M}，由栈空间、堆空间、代码片、数据片等地址空间段组合而成，如下图所示(出自CS:APP3e, Bryant and O&rsquo;Hallaron的第9章第9节)
这里我们重点关注Heap（堆），堆是一块动态的虚拟内存地址空间。在C语言中，我们通常使用malloc来申请内存以及使用free来释放内存，也许你想问，这样不就足够了吗？但是，这种手动的内存管理会带来很多问题，比如：
给程序员带来额外的心智负担，必须得及时释放掉不再使用的内存空间，否则就很容易出现内存泄露 随着内存的不断申请与释放，会产生大量的内存碎片，这将大大降低内存的利用率 因此，正确高效地管理内存空间是非常有必要的，常见的技术实现有Sequential allocation, Free-List allocation等。那么，在Go中，内存是如何被管理的呢？
注：此为Go1.13.6的实现逻辑，随版本更替某些细节会有些许不同
实现原理 Go的内存分配器是基于TCMalloc设计的，因此我建议你先行查阅，这将有利于理解接下来的内容。
大量工程经验证明，程序中的小对象占了绝大部分，且生命周期都较为短暂。因此，Go将内存划分为各种类别(Class)，并各自形成Free-List。相较于单一的Free-List分配器，分类后主要有以下优点：
其一方面减少不必要的搜索时间，因为对象只需要在其所属类别的空闲链表中搜索即可
另一方面减少了内存碎片化，同一类别的空闲链表，每个对象分配的空间都是一样大小(不足则补齐)，因此该链表除非无空闲空间，否则总能分配空间，避免了内存碎片
那么，Go内存分配器具体是如何实现的呢？接下来，我将以自顶向下的方式，从宏观到微观，层层拨开她的神秘面纱。
数据结构 首先，介绍Go内存分配中相关的数据结构。其总体概览图如下所示：
heapArena 在操作系统中，我们一般把堆看做是一块连续的虚拟内存空间。
Go将其划分为数个相同大小的连续空间块，称之arena，其中，heapArena则作为arena空间的管理单元，其结构如下所示：
type heapArena struct { bitmap [heapArenaBitmapBytes]byte spans [pagesPerArena]*mspan ... } bitmap: 表示arena区域中的哪些地址保存了对象，哪些地址保存了指针 spans: 表示arena区域中的哪些操作系统页(8K)属于哪些mspan mheap 然后，则是核心角色mheap了，它是Go内存管理中的核心数据结构，作为全局唯一变量，其结构如下所示：
type mheap struct { free mTreap ... allspans []*mspan ... arenas [1 << arenaL1Bits]*[1 << arenaL2Bits]*heapArena ... central [numSpanClasses]struct { mcentral mcentral pad [cpu.CacheLinePadSize - unsafe.Sizeof(mcentral{})%cpu.CacheLinePadSize]byte } } free: 使用树堆的结构来保存各种类别的空闲mspan allspans: 用以记录了分配过了的mspan arenas: 表示其覆盖的所有arena区域，通过虚拟内存地址计算得到下标索引 central: 表示其覆盖的所有mcentral，一共134个，对应67个类别 mcentral 而mcentral充当mspan的中心管理员，负责管理某一类别的mspan，其结构如下："><meta name=author content="erenming"><link rel=canonical href=https://erenming.github.io/posts/memory-allocator-in-go/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://erenming.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://erenming.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://erenming.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://erenming.github.io/apple-touch-icon.png><link rel=mask-icon href=https://erenming.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://erenming.github.io/posts/memory-allocator-in-go/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="浅析Go内存分配器的实现"><meta property="og:description" content="为什么需要内存分配器？ 总说周知，内存作为一种相对稀缺的资源，在操作系统中以虚拟内存的形式来作为一种内存抽象提供给进程，这里可以简单地把它看做一个连续的地址集合{0, 1, 2, ..., M}，由栈空间、堆空间、代码片、数据片等地址空间段组合而成，如下图所示(出自CS:APP3e, Bryant and O&rsquo;Hallaron的第9章第9节)
这里我们重点关注Heap（堆），堆是一块动态的虚拟内存地址空间。在C语言中，我们通常使用malloc来申请内存以及使用free来释放内存，也许你想问，这样不就足够了吗？但是，这种手动的内存管理会带来很多问题，比如：
给程序员带来额外的心智负担，必须得及时释放掉不再使用的内存空间，否则就很容易出现内存泄露 随着内存的不断申请与释放，会产生大量的内存碎片，这将大大降低内存的利用率 因此，正确高效地管理内存空间是非常有必要的，常见的技术实现有Sequential allocation, Free-List allocation等。那么，在Go中，内存是如何被管理的呢？
注：此为Go1.13.6的实现逻辑，随版本更替某些细节会有些许不同
实现原理 Go的内存分配器是基于TCMalloc设计的，因此我建议你先行查阅，这将有利于理解接下来的内容。
大量工程经验证明，程序中的小对象占了绝大部分，且生命周期都较为短暂。因此，Go将内存划分为各种类别(Class)，并各自形成Free-List。相较于单一的Free-List分配器，分类后主要有以下优点：
其一方面减少不必要的搜索时间，因为对象只需要在其所属类别的空闲链表中搜索即可
另一方面减少了内存碎片化，同一类别的空闲链表，每个对象分配的空间都是一样大小(不足则补齐)，因此该链表除非无空闲空间，否则总能分配空间，避免了内存碎片
那么，Go内存分配器具体是如何实现的呢？接下来，我将以自顶向下的方式，从宏观到微观，层层拨开她的神秘面纱。
数据结构 首先，介绍Go内存分配中相关的数据结构。其总体概览图如下所示：
heapArena 在操作系统中，我们一般把堆看做是一块连续的虚拟内存空间。
Go将其划分为数个相同大小的连续空间块，称之arena，其中，heapArena则作为arena空间的管理单元，其结构如下所示：
type heapArena struct { bitmap [heapArenaBitmapBytes]byte spans [pagesPerArena]*mspan ... } bitmap: 表示arena区域中的哪些地址保存了对象，哪些地址保存了指针 spans: 表示arena区域中的哪些操作系统页(8K)属于哪些mspan mheap 然后，则是核心角色mheap了，它是Go内存管理中的核心数据结构，作为全局唯一变量，其结构如下所示：
type mheap struct { free mTreap ... allspans []*mspan ... arenas [1 << arenaL1Bits]*[1 << arenaL2Bits]*heapArena ... central [numSpanClasses]struct { mcentral mcentral pad [cpu.CacheLinePadSize - unsafe.Sizeof(mcentral{})%cpu.CacheLinePadSize]byte } } free: 使用树堆的结构来保存各种类别的空闲mspan allspans: 用以记录了分配过了的mspan arenas: 表示其覆盖的所有arena区域，通过虚拟内存地址计算得到下标索引 central: 表示其覆盖的所有mcentral，一共134个，对应67个类别 mcentral 而mcentral充当mspan的中心管理员，负责管理某一类别的mspan，其结构如下："><meta property="og:type" content="article"><meta property="og:url" content="https://erenming.github.io/posts/memory-allocator-in-go/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-06-15T21:08:09+08:00"><meta property="article:modified_time" content="2021-06-15T21:08:09+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="浅析Go内存分配器的实现"><meta name=twitter:description content="为什么需要内存分配器？ 总说周知，内存作为一种相对稀缺的资源，在操作系统中以虚拟内存的形式来作为一种内存抽象提供给进程，这里可以简单地把它看做一个连续的地址集合{0, 1, 2, ..., M}，由栈空间、堆空间、代码片、数据片等地址空间段组合而成，如下图所示(出自CS:APP3e, Bryant and O&rsquo;Hallaron的第9章第9节)
这里我们重点关注Heap（堆），堆是一块动态的虚拟内存地址空间。在C语言中，我们通常使用malloc来申请内存以及使用free来释放内存，也许你想问，这样不就足够了吗？但是，这种手动的内存管理会带来很多问题，比如：
给程序员带来额外的心智负担，必须得及时释放掉不再使用的内存空间，否则就很容易出现内存泄露 随着内存的不断申请与释放，会产生大量的内存碎片，这将大大降低内存的利用率 因此，正确高效地管理内存空间是非常有必要的，常见的技术实现有Sequential allocation, Free-List allocation等。那么，在Go中，内存是如何被管理的呢？
注：此为Go1.13.6的实现逻辑，随版本更替某些细节会有些许不同
实现原理 Go的内存分配器是基于TCMalloc设计的，因此我建议你先行查阅，这将有利于理解接下来的内容。
大量工程经验证明，程序中的小对象占了绝大部分，且生命周期都较为短暂。因此，Go将内存划分为各种类别(Class)，并各自形成Free-List。相较于单一的Free-List分配器，分类后主要有以下优点：
其一方面减少不必要的搜索时间，因为对象只需要在其所属类别的空闲链表中搜索即可
另一方面减少了内存碎片化，同一类别的空闲链表，每个对象分配的空间都是一样大小(不足则补齐)，因此该链表除非无空闲空间，否则总能分配空间，避免了内存碎片
那么，Go内存分配器具体是如何实现的呢？接下来，我将以自顶向下的方式，从宏观到微观，层层拨开她的神秘面纱。
数据结构 首先，介绍Go内存分配中相关的数据结构。其总体概览图如下所示：
heapArena 在操作系统中，我们一般把堆看做是一块连续的虚拟内存空间。
Go将其划分为数个相同大小的连续空间块，称之arena，其中，heapArena则作为arena空间的管理单元，其结构如下所示：
type heapArena struct { bitmap [heapArenaBitmapBytes]byte spans [pagesPerArena]*mspan ... } bitmap: 表示arena区域中的哪些地址保存了对象，哪些地址保存了指针 spans: 表示arena区域中的哪些操作系统页(8K)属于哪些mspan mheap 然后，则是核心角色mheap了，它是Go内存管理中的核心数据结构，作为全局唯一变量，其结构如下所示：
type mheap struct { free mTreap ... allspans []*mspan ... arenas [1 << arenaL1Bits]*[1 << arenaL2Bits]*heapArena ... central [numSpanClasses]struct { mcentral mcentral pad [cpu.CacheLinePadSize - unsafe.Sizeof(mcentral{})%cpu.CacheLinePadSize]byte } } free: 使用树堆的结构来保存各种类别的空闲mspan allspans: 用以记录了分配过了的mspan arenas: 表示其覆盖的所有arena区域，通过虚拟内存地址计算得到下标索引 central: 表示其覆盖的所有mcentral，一共134个，对应67个类别 mcentral 而mcentral充当mspan的中心管理员，负责管理某一类别的mspan，其结构如下："><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://erenming.github.io/posts/"},{"@type":"ListItem","position":2,"name":"浅析Go内存分配器的实现","item":"https://erenming.github.io/posts/memory-allocator-in-go/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"浅析Go内存分配器的实现","name":"浅析Go内存分配器的实现","description":"为什么需要内存分配器？ 总说周知，内存作为一种相对稀缺的资源，在操作系统中以虚拟内存的形式来作为一种内存抽象提供给进程，这里可以简单地把它看做一个连续的地址集合{0, 1, 2, ..., M}，由栈空间、堆空间、代码片、数据片等地址空间段组合而成，如下图所示(出自CS:APP3e, Bryant and O\u0026rsquo;Hallaron的第9章第9节)\n这里我们重点关注Heap（堆），堆是一块动态的虚拟内存地址空间。在C语言中，我们通常使用malloc来申请内存以及使用free来释放内存，也许你想问，这样不就足够了吗？但是，这种手动的内存管理会带来很多问题，比如：\n给程序员带来额外的心智负担，必须得及时释放掉不再使用的内存空间，否则就很容易出现内存泄露 随着内存的不断申请与释放，会产生大量的内存碎片，这将大大降低内存的利用率 因此，正确高效地管理内存空间是非常有必要的，常见的技术实现有Sequential allocation, Free-List allocation等。那么，在Go中，内存是如何被管理的呢？\n注：此为Go1.13.6的实现逻辑，随版本更替某些细节会有些许不同\n实现原理 Go的内存分配器是基于TCMalloc设计的，因此我建议你先行查阅，这将有利于理解接下来的内容。\n大量工程经验证明，程序中的小对象占了绝大部分，且生命周期都较为短暂。因此，Go将内存划分为各种类别(Class)，并各自形成Free-List。相较于单一的Free-List分配器，分类后主要有以下优点：\n其一方面减少不必要的搜索时间，因为对象只需要在其所属类别的空闲链表中搜索即可\n另一方面减少了内存碎片化，同一类别的空闲链表，每个对象分配的空间都是一样大小(不足则补齐)，因此该链表除非无空闲空间，否则总能分配空间，避免了内存碎片\n那么，Go内存分配器具体是如何实现的呢？接下来，我将以自顶向下的方式，从宏观到微观，层层拨开她的神秘面纱。\n数据结构 首先，介绍Go内存分配中相关的数据结构。其总体概览图如下所示：\nheapArena 在操作系统中，我们一般把堆看做是一块连续的虚拟内存空间。\nGo将其划分为数个相同大小的连续空间块，称之arena，其中，heapArena则作为arena空间的管理单元，其结构如下所示：\ntype heapArena struct { bitmap [heapArenaBitmapBytes]byte spans [pagesPerArena]*mspan ... } bitmap: 表示arena区域中的哪些地址保存了对象，哪些地址保存了指针 spans: 表示arena区域中的哪些操作系统页(8K)属于哪些mspan mheap 然后，则是核心角色mheap了，它是Go内存管理中的核心数据结构，作为全局唯一变量，其结构如下所示：\ntype mheap struct { free mTreap ... allspans []*mspan ... arenas [1 \u0026lt;\u0026lt; arenaL1Bits]*[1 \u0026lt;\u0026lt; arenaL2Bits]*heapArena ... central [numSpanClasses]struct { mcentral mcentral pad [cpu.CacheLinePadSize - unsafe.Sizeof(mcentral{})%cpu.CacheLinePadSize]byte } } free: 使用树堆的结构来保存各种类别的空闲mspan allspans: 用以记录了分配过了的mspan arenas: 表示其覆盖的所有arena区域，通过虚拟内存地址计算得到下标索引 central: 表示其覆盖的所有mcentral，一共134个，对应67个类别 mcentral 而mcentral充当mspan的中心管理员，负责管理某一类别的mspan，其结构如下：","keywords":["Go"],"articleBody":"为什么需要内存分配器？ 总说周知，内存作为一种相对稀缺的资源，在操作系统中以虚拟内存的形式来作为一种内存抽象提供给进程，这里可以简单地把它看做一个连续的地址集合{0, 1, 2, ..., M}，由栈空间、堆空间、代码片、数据片等地址空间段组合而成，如下图所示(出自CS:APP3e, Bryant and O’Hallaron的第9章第9节)\n这里我们重点关注Heap（堆），堆是一块动态的虚拟内存地址空间。在C语言中，我们通常使用malloc来申请内存以及使用free来释放内存，也许你想问，这样不就足够了吗？但是，这种手动的内存管理会带来很多问题，比如：\n给程序员带来额外的心智负担，必须得及时释放掉不再使用的内存空间，否则就很容易出现内存泄露 随着内存的不断申请与释放，会产生大量的内存碎片，这将大大降低内存的利用率 因此，正确高效地管理内存空间是非常有必要的，常见的技术实现有Sequential allocation, Free-List allocation等。那么，在Go中，内存是如何被管理的呢？\n注：此为Go1.13.6的实现逻辑，随版本更替某些细节会有些许不同\n实现原理 Go的内存分配器是基于TCMalloc设计的，因此我建议你先行查阅，这将有利于理解接下来的内容。\n大量工程经验证明，程序中的小对象占了绝大部分，且生命周期都较为短暂。因此，Go将内存划分为各种类别(Class)，并各自形成Free-List。相较于单一的Free-List分配器，分类后主要有以下优点：\n其一方面减少不必要的搜索时间，因为对象只需要在其所属类别的空闲链表中搜索即可\n另一方面减少了内存碎片化，同一类别的空闲链表，每个对象分配的空间都是一样大小(不足则补齐)，因此该链表除非无空闲空间，否则总能分配空间，避免了内存碎片\n那么，Go内存分配器具体是如何实现的呢？接下来，我将以自顶向下的方式，从宏观到微观，层层拨开她的神秘面纱。\n数据结构 首先，介绍Go内存分配中相关的数据结构。其总体概览图如下所示：\nheapArena 在操作系统中，我们一般把堆看做是一块连续的虚拟内存空间。\nGo将其划分为数个相同大小的连续空间块，称之arena，其中，heapArena则作为arena空间的管理单元，其结构如下所示：\ntype heapArena struct { bitmap [heapArenaBitmapBytes]byte spans [pagesPerArena]*mspan ... } bitmap: 表示arena区域中的哪些地址保存了对象，哪些地址保存了指针 spans: 表示arena区域中的哪些操作系统页(8K)属于哪些mspan mheap 然后，则是核心角色mheap了，它是Go内存管理中的核心数据结构，作为全局唯一变量，其结构如下所示：\ntype mheap struct { free mTreap ... allspans []*mspan ... arenas [1 \u003c\u003c arenaL1Bits]*[1 \u003c\u003c arenaL2Bits]*heapArena ... central [numSpanClasses]struct { mcentral mcentral pad [cpu.CacheLinePadSize - unsafe.Sizeof(mcentral{})%cpu.CacheLinePadSize]byte } } free: 使用树堆的结构来保存各种类别的空闲mspan allspans: 用以记录了分配过了的mspan arenas: 表示其覆盖的所有arena区域，通过虚拟内存地址计算得到下标索引 central: 表示其覆盖的所有mcentral，一共134个，对应67个类别 mcentral 而mcentral充当mspan的中心管理员，负责管理某一类别的mspan，其结构如下：\ntype mcentral struct { lock mutex spanclass spanClass nonempty mSpanList empty mSpanList } lock: 全局互斥锁，因为多个线程会并发请求 spanclass：mspan类别 nonempty：mspan的双端链表，且其中至少有一个mspan包含空闲对象 empty：mspan的双端链表，但不确定其中的mspan是否包含空闲对象 mcache mcache充当mspan的线程本地缓存角色，其与线程处理器(P)一一绑定。\n这样呢，当mcache有空闲mspan时，则无需向mcentral申请，因此可以避免诸多不必要的锁消耗。结构如下所示：\ntype mcache struct { ... alloc [numSpanClasses]*mspan ... } alloc: 表示各个类别的mspan mspan mspan作为虚拟内存的实际管理单元，管理着一片内存空间(npages个页)，其结构如下所示：\ntype mspan struct { next *mspan // 指向下一个mspan prev *mspan // 指向前一个mspan ... npages uintptr freeindex uintptr nelems uintptr // 总对象个数 ... allocBits *gcBits gcmarkBits *gcBits } next指针指向下一个mspan，prev指针指向前一个mspan，因此各个mspan彼此之间形成一个双端链表，并被runtime.mSpanList作为链表头。 npages：mspan所管理的页的数量 freeindex：空闲对象的起始位置，如果freeindex等于nelems时，则代表此mspan无空闲对象可分配了 allocBits：标记哪些元素已分配，哪些未分配。与freeindex结合，可跳过已分配的对象 gcmarkBits：标记哪些对象存活，每次GC结束时，将其设为allocBits 通过上述对Go内存管理中各个关键数据结构的介绍，想必现在，我们已经对其有了一个大概的轮廓。接下来，让我们继续探究，看看Go具体是如何利用这些数据结构来实现高效的内存分配算法\n算法 分配内存 内存分配算法，其主要函数为runtime.mallocgc，其基本步骤简述如下：\n判断待分配对象的大小 若对象小于maxTinySize（16B），且不为指针，则执行微对象分配算法 若对象小于maxSmallSize（32KB），则执行小对象分配算法 否则，则执行大对象分配算法 在微对象以及小对象分配过程中，如果span中找不到足够的空闲空间，Go会触发层级的内存分配申请策略。其基本步骤如下：\n先从mcache寻找对应类别的span，若有空闲对象，则成功返回 若无，则向mcentral申请，分别从nonempty和empty中寻找匹配的span，若找到，则成功返回 若还未找到，则继续向mheap申请，从mheap.free中寻找，若找到，则成功返回 若未找到，则需扩容，从关联的arena中申请，若关联的arena中空间也不足，则向OS申请额外的arena 扩容完毕后，继续从mheap.free中寻找，若仍未找到，则抛出错误 学到了什么 本地线程缓存，提高性能：通过mcache缓存小对象的span，并优先在mcache中分配，降低锁竞争 无处不在的BitMap应用场景：通过二进制位来映射对象，例如mspan.allocBits用以表示对象是否分配 多级分配策略：自底向上，性能损耗：低-\u003e高，频率：高-\u003e低，能有效提高性能，思想上类似CPU中的多级缓存 总结 本文主要介绍了Go内存分配中的一些重要组件以及分配算法。可以看到，其主要思想还是基于TCMalloc的策略，将对象根据大小分类，并使用不同的分配策略。此外，还采用逐层的内存申请策略，大大提高内存分配的性能。\n参考 https://google.github.io/tcmalloc/ http://goog-perftools.sourceforge.net/doc/tcmalloc.html https://medium.com/@ankur_anand/a-visual-guide-to-golang-memory-allocator-from-ground-up-e132258453ed https://www.cnblogs.com/zkweb/p/7880099.html https://www.cnblogs.com/luozhiyun/p/14349331.html https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-memory-allocator/ ","wordCount":"175","inLanguage":"zh","datePublished":"2021-06-15T21:08:09+08:00","dateModified":"2021-06-15T21:08:09+08:00","author":{"@type":"Person","name":"erenming"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://erenming.github.io/posts/memory-allocator-in-go/"},"publisher":{"@type":"Organization","name":"Nothing Special","logo":{"@type":"ImageObject","url":"https://erenming.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://erenming.github.io/ accesskey=h title="Nothing Special (Alt + H)">Nothing Special</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://erenming.github.io/en/ title=English aria-label=English>En</a></li></ul></div></div><ul id=menu><li><a href=https://erenming.github.io/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://erenming.github.io/archives/ title=归档><span>归档</span></a></li><li><a href=https://erenming.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://erenming.github.io/readings/ title=书单><span>书单</span></a></li><li><a href=https://erenming.github.io/about/ title=关于><span>关于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">浅析Go内存分配器的实现</h1><div class=post-meta><span title='2021-06-15 21:08:09 +0800 +0800'>六月 15, 2021</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;erenming</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e5%99%a8 aria-label=为什么需要内存分配器？>为什么需要内存分配器？</a></li><li><a href=#%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86 aria-label=实现原理>实现原理</a></li><li><a href=#%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84 aria-label=数据结构>数据结构</a><ul><ul><li><a href=#heaparena aria-label=heapArena>heapArena</a></li><li><a href=#mheap aria-label=mheap>mheap</a></li><li><a href=#mcentral aria-label=mcentral>mcentral</a></li><li><a href=#mcache aria-label=mcache>mcache</a></li><li><a href=#mspan aria-label=mspan>mspan</a></li></ul></ul></li><li><a href=#%e7%ae%97%e6%b3%95 aria-label=算法>算法</a><ul><li><a href=#%e5%88%86%e9%85%8d%e5%86%85%e5%ad%98 aria-label=分配内存>分配内存</a></li></ul></li><li><a href=#%e5%ad%a6%e5%88%b0%e4%ba%86%e4%bb%80%e4%b9%88 aria-label=学到了什么>学到了什么</a></li><li><a href=#%e6%80%bb%e7%bb%93 aria-label=总结>总结</a></li><li><a href=#%e5%8f%82%e8%80%83 aria-label=参考>参考</a></li></ul></div></details></div><div class=post-content><h1 id=为什么需要内存分配器>为什么需要内存分配器？<a hidden class=anchor aria-hidden=true href=#为什么需要内存分配器>#</a></h1><p>总说周知，内存作为一种相对稀缺的资源，在操作系统中以<em>虚拟内存</em>的形式来作为一种内存抽象提供给进程，这里可以简单地把它看做一个连续的地址集合<code>{0, 1, 2, ..., M}</code>，由栈空间、堆空间、代码片、数据片等地址空间段组合而成，如下图所示(出自<a href=https://csapp.cs.cmu.edu/>CS:APP3e, Bryant and O&rsquo;Hallaron</a>的第9章第9节)</p><p>这里我们重点关注Heap（堆），堆是一块动态的虚拟内存地址空间。在C语言中，我们通常使用<code>malloc</code>来申请内存以及使用<code>free</code>来释放内存，也许你想问，这样不就足够了吗？但是，这种手动的内存管理会带来很多问题，比如：</p><ol><li>给程序员带来额外的心智负担，必须得及时释放掉不再使用的内存空间，否则就很容易出现内存泄露</li><li>随着内存的不断申请与释放，会产生大量的<a href=https://en.wikipedia.org/wiki/Fragmentation_(computing)>内存碎片</a>，这将大大降低内存的利用率</li></ol><p>因此，正确高效地管理内存空间是非常有必要的，常见的技术实现有Sequential allocation, Free-List allocation等。那么，在Go中，内存是如何被管理的呢？</p><blockquote><p>注：此为Go1.13.6的实现逻辑，随版本更替某些细节会有些许不同</p></blockquote><h1 id=实现原理>实现原理<a hidden class=anchor aria-hidden=true href=#实现原理>#</a></h1><p>Go的内存分配器是基于<a href=https://google.github.io/tcmalloc/design.html#spans>TCMalloc</a>设计的，因此我建议你先行查阅，这将有利于理解接下来的内容。</p><p>大量工程经验证明，程序中的小对象占了绝大部分，且生命周期都较为短暂。因此，Go将内存划分为各种类别(Class)，并各自形成Free-List。相较于单一的Free-List分配器，分类后主要有以下优点：</p><ul><li><p>其一方面减少不必要的搜索时间，因为对象只需要在其所属类别的空闲链表中搜索即可</p></li><li><p>另一方面减少了内存碎片化，同一类别的空闲链表，每个对象分配的空间都是一样大小(不足则补齐)，因此该链表除非无空闲空间，否则总能分配空间，避免了内存碎片</p></li></ul><p>那么，Go内存分配器具体是如何实现的呢？接下来，我将以自顶向下的方式，从宏观到微观，层层拨开她的神秘面纱。</p><h1 id=数据结构>数据结构<a hidden class=anchor aria-hidden=true href=#数据结构>#</a></h1><p>首先，介绍Go内存分配中相关的数据结构。其总体概览图如下所示：</p><p><img loading=lazy src=https://raw.githubusercontent.com/erenming/image-pool/master/blog/go-mem-alloctor.png alt=go-mem-alloctor></p><h3 id=heaparena>heapArena<a hidden class=anchor aria-hidden=true href=#heaparena>#</a></h3><p>在操作系统中，我们一般把堆看做是一块连续的虚拟内存空间。</p><p>Go将其划分为数个相同大小的连续空间块，称之<code>arena</code>，其中，heapArena则作为arena空间的管理单元，其结构如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>heapArena</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>bitmap</span> [<span style=color:#a6e22e>heapArenaBitmapBytes</span>]<span style=color:#66d9ef>byte</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>spans</span> [<span style=color:#a6e22e>pagesPerArena</span>]<span style=color:#f92672>*</span><span style=color:#a6e22e>mspan</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>bitmap: 表示arena区域中的哪些地址保存了对象，哪些地址保存了指针</li><li>spans: 表示arena区域中的哪些操作系统页(8K)属于哪些mspan</li></ul><h3 id=mheap>mheap<a hidden class=anchor aria-hidden=true href=#mheap>#</a></h3><p>然后，则是核心角色mheap了，它是Go内存管理中的核心数据结构，作为全局唯一变量，其结构如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>mheap</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>free</span>      <span style=color:#a6e22e>mTreap</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>allspans</span> []<span style=color:#f92672>*</span><span style=color:#a6e22e>mspan</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>arenas</span> [<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#a6e22e>arenaL1Bits</span>]<span style=color:#f92672>*</span>[<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#a6e22e>arenaL2Bits</span>]<span style=color:#f92672>*</span><span style=color:#a6e22e>heapArena</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>central</span> [<span style=color:#a6e22e>numSpanClasses</span>]<span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>mcentral</span> <span style=color:#a6e22e>mcentral</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>pad</span>      [<span style=color:#a6e22e>cpu</span>.<span style=color:#a6e22e>CacheLinePadSize</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Sizeof</span>(<span style=color:#a6e22e>mcentral</span>{})<span style=color:#f92672>%</span><span style=color:#a6e22e>cpu</span>.<span style=color:#a6e22e>CacheLinePadSize</span>]<span style=color:#66d9ef>byte</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>free: 使用树堆的结构来保存各种类别的空闲mspan</li><li>allspans: 用以记录了分配过了的mspan</li><li>arenas: 表示其覆盖的所有arena区域，通过虚拟内存地址计算得到下标索引</li><li>central: 表示其覆盖的所有mcentral，一共134个，对应67个类别</li></ul><h3 id=mcentral>mcentral<a hidden class=anchor aria-hidden=true href=#mcentral>#</a></h3><p>而<code>mcentral</code>充当<code>mspan</code>的中心管理员，负责管理某一类别的mspan，其结构如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>mcentral</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>lock</span>      <span style=color:#a6e22e>mutex</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>spanclass</span> <span style=color:#a6e22e>spanClass</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>nonempty</span>  <span style=color:#a6e22e>mSpanList</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>empty</span>     <span style=color:#a6e22e>mSpanList</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>lock: 全局互斥锁，因为多个线程会并发请求</li><li>spanclass：mspan类别</li><li>nonempty：mspan的双端链表，且其中至少有一个mspan包含空闲对象</li><li>empty：mspan的双端链表，但不确定其中的mspan是否包含空闲对象</li></ul><h3 id=mcache>mcache<a hidden class=anchor aria-hidden=true href=#mcache>#</a></h3><p><code>mcache</code>充当mspan的线程本地缓存角色，其与线程处理器(P)一一绑定。</p><p>这样呢，当mcache有空闲mspan时，则无需向mcentral申请，因此可以避免诸多不必要的锁消耗。结构如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>mcache</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>  <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>alloc</span> [<span style=color:#a6e22e>numSpanClasses</span>]<span style=color:#f92672>*</span><span style=color:#a6e22e>mspan</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>alloc: 表示各个类别的mspan</li></ul><h3 id=mspan>mspan<a hidden class=anchor aria-hidden=true href=#mspan>#</a></h3><p><code>mspan</code>作为虚拟内存的实际管理单元，管理着一片内存空间(npages个页)，其结构如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>mspan</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>next</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>mspan</span>     <span style=color:#75715e>// 指向下一个mspan
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>prev</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>mspan</span>     <span style=color:#75715e>// 指向前一个mspan
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>npages</span>    <span style=color:#66d9ef>uintptr</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>freeindex</span> <span style=color:#66d9ef>uintptr</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>nelems</span>    <span style=color:#66d9ef>uintptr</span> <span style=color:#75715e>// 总对象个数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>allocBits</span>  <span style=color:#f92672>*</span><span style=color:#a6e22e>gcBits</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>gcmarkBits</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>gcBits</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>next指针指向下一个mspan，prev指针指向前一个mspan，因此各个mspan彼此之间形成一个双端链表，并被runtime.mSpanList作为链表头。</li><li>npages：mspan所管理的页的数量</li><li>freeindex：空闲对象的起始位置，如果freeindex等于nelems时，则代表此mspan无空闲对象可分配了</li><li>allocBits：标记哪些元素已分配，哪些未分配。与freeindex结合，可跳过已分配的对象</li><li>gcmarkBits：标记哪些对象存活，每次GC结束时，将其设为allocBits</li></ul><p>通过上述对Go内存管理中各个关键数据结构的介绍，想必现在，我们已经对其有了一个大概的轮廓。接下来，让我们继续探究，看看Go具体是如何利用这些数据结构来实现高效的内存分配算法</p><h1 id=算法>算法<a hidden class=anchor aria-hidden=true href=#算法>#</a></h1><h2 id=分配内存>分配内存<a hidden class=anchor aria-hidden=true href=#分配内存>#</a></h2><p>内存分配算法，其主要函数为<code>runtime.mallocgc</code>，其基本步骤简述如下：</p><ul><li>判断待分配对象的大小</li><li>若对象小于maxTinySize（16B），且不为指针，则执行微对象分配算法</li><li>若对象小于maxSmallSize（32KB），则执行小对象分配算法</li><li>否则，则执行大对象分配算法</li></ul><p>在微对象以及小对象分配过程中，如果span中找不到足够的空闲空间，Go会触发层级的内存分配申请策略。其基本步骤如下：</p><ul><li>先从mcache寻找对应类别的span，若有空闲对象，则成功返回</li><li>若无，则向mcentral申请，分别从nonempty和empty中寻找匹配的span，若找到，则成功返回</li><li>若还未找到，则继续向mheap申请，从mheap.free中寻找，若找到，则成功返回</li><li>若未找到，则需扩容，从关联的arena中申请，若关联的arena中空间也不足，则向OS申请额外的arena</li><li>扩容完毕后，继续从mheap.free中寻找，若仍未找到，则抛出错误</li></ul><h1 id=学到了什么>学到了什么<a hidden class=anchor aria-hidden=true href=#学到了什么>#</a></h1><ul><li>本地线程缓存，提高性能：通过mcache缓存小对象的span，并优先在mcache中分配，降低锁竞争</li><li>无处不在的<a href=https://www.jianshu.com/p/6082a2f7df8e>BitMap</a>应用场景：通过二进制位来映射对象，例如mspan.allocBits用以表示对象是否分配</li><li>多级分配策略：自底向上，性能损耗：低->高，频率：高->低，能有效提高性能，思想上类似CPU中的多级缓存</li></ul><h1 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h1><p>本文主要介绍了Go内存分配中的一些重要组件以及分配算法。可以看到，其主要思想还是基于TCMalloc的策略，将对象根据大小分类，并使用不同的分配策略。此外，还采用逐层的内存申请策略，大大提高内存分配的性能。</p><h1 id=参考>参考<a hidden class=anchor aria-hidden=true href=#参考>#</a></h1><ul><li><a href=https://google.github.io/tcmalloc/>https://google.github.io/tcmalloc/</a></li><li><a href=http://goog-perftools.sourceforge.net/doc/tcmalloc.html>http://goog-perftools.sourceforge.net/doc/tcmalloc.html</a></li><li><a href=https://medium.com/@ankur_anand/a-visual-guide-to-golang-memory-allocator-from-ground-up-e132258453ed>https://medium.com/@ankur_anand/a-visual-guide-to-golang-memory-allocator-from-ground-up-e132258453ed</a></li><li><a href=https://www.cnblogs.com/zkweb/p/7880099.html>https://www.cnblogs.com/zkweb/p/7880099.html</a></li><li><a href=https://www.cnblogs.com/luozhiyun/p/14349331.html>https://www.cnblogs.com/luozhiyun/p/14349331.html</a></li><li><a href=https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-memory-allocator/>https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-memory-allocator/</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://erenming.github.io/tags/go/>Go</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://erenming.github.io/>Nothing Special</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>