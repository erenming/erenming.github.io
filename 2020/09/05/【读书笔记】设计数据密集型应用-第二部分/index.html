<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="分布式数据，replication and partition  Replication: keeping a copy of the same data on sevral differrent nodes, or in different locations Partition: splittion a big databse into smaller subsets called parti">
<meta property="og:type" content="article">
<meta property="og:title" content="【读书笔记】设计数据密集型应用-第二部分">
<meta property="og:url" content="https://erenming.com/2020/09/05/【读书笔记】设计数据密集型应用-第二部分/index.html">
<meta property="og:site_name" content="Eren with you">
<meta property="og:description" content="分布式数据，replication and partition  Replication: keeping a copy of the same data on sevral differrent nodes, or in different locations Partition: splittion a big databse into smaller subsets called parti">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://github.com/Vonng/ddia/raw/master/img/fig5-3.png">
<meta property="og:image" content="https://github.com/Vonng/ddia/raw/master/img/fig5-4.png">
<meta property="og:image" content="https://github.com/Vonng/ddia/raw/master/img/fig5-5.png">
<meta property="og:image" content="https://github.com/Vonng/ddia/raw/master/img/fig5-8.png">
<meta property="og:image" content="https://github.com/Vonng/ddia/raw/master/img/fig5-12.png">
<meta property="og:image" content="https://github.com/Vonng/ddia/raw/master/img/fig5-13.png">
<meta property="og:image" content="https://github.com/Vonng/ddia/raw/master/img/fig6-2.png">
<meta property="og:image" content="https://github.com/Vonng/ddia/raw/master/img/fig6-3.png">
<meta property="og:image" content="https://github.com/Vonng/ddia/raw/master/img/fig6-4.png">
<meta property="og:image" content="https://github.com/Vonng/ddia/raw/master/img/fig6-5.png">
<meta property="og:image" content="https://github.com/Vonng/ddia/raw/master/img/fig6-6.png">
<meta property="og:image" content="https://github.com/Vonng/ddia/raw/master/img/fig6-7.png">
<meta property="og:image" content="https://github.com/Vonng/ddia/raw/master/img/fig7-6.png">
<meta property="og:image" content="https://github.com/Vonng/ddia/raw/master/img/fig7-7.png">
<meta property="og:image" content="https://github.com/Vonng/ddia/raw/master/img/fig7-8.png">
<meta property="og:image" content="https://github.com/Vonng/ddia/raw/master/img/fig7-11.png">
<meta property="og:image" content="https://github.com/Vonng/ddia/raw/master/img/fig8-4.png">
<meta property="og:image" content="https://github.com/Vonng/ddia/raw/master/img/fig8-5.png">
<meta property="og:image" content="https://github.com/Vonng/ddia/raw/master/img/fig9-3.png">
<meta property="og:image" content="https://github.com/Vonng/ddia/raw/master/img/fig9-4.png">
<meta property="og:image" content="https://github.com/Vonng/ddia/raw/master/img/fig9-5.png">
<meta property="og:image" content="https://github.com/Vonng/ddia/raw/master/img/fig9-8.png">
<meta property="og:updated_time" content="2020-10-25T12:15:43.370Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="【读书笔记】设计数据密集型应用-第二部分">
<meta name="twitter:description" content="分布式数据，replication and partition  Replication: keeping a copy of the same data on sevral differrent nodes, or in different locations Partition: splittion a big databse into smaller subsets called parti">
<meta name="twitter:image" content="https://github.com/Vonng/ddia/raw/master/img/fig5-3.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://erenming.com/2020/09/05/【读书笔记】设计数据密集型应用-第二部分/">





  <title>【读书笔记】设计数据密集型应用-第二部分 | Eren with you</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Eren with you</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://erenming.com/2020/09/05/【读书笔记】设计数据密集型应用-第二部分/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Eren Ming">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eren with you">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">【读书笔记】设计数据密集型应用-第二部分</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-09-05T17:24:59+08:00">
                2020-09-05
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/09/05/【读书笔记】设计数据密集型应用-第二部分/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/09/05/【读书笔记】设计数据密集型应用-第二部分/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>分布式数据，replication and partition</p>
<ul>
<li>Replication: keeping a <strong>copy</strong> of the same data on sevral differrent nodes, or in different locations</li>
<li>Partition: <strong>splittion</strong> a big databse into smaller subsets called partitions so that different partitions can be assigned to different nodes(called <em>sharding</em>)</li>
</ul>
<h1 id="第五章-复制"><a href="#第五章-复制" class="headerlink" title="第五章-复制"></a>第五章-复制</h1><p>复制的作用：</p>
<ul>
<li>数据物理上靠近用户</li>
<li>允许部分节点故障而系统正常，提高可靠性</li>
<li>水平扩展机器数可提高吞吐量</li>
</ul>
<h2 id="Leaders-and-Followers-单Leader"><a href="#Leaders-and-Followers-单Leader" class="headerlink" title="Leaders and Followers(单Leader)"></a>Leaders and Followers(单Leader)</h2><p>如何确保所有节点都获得数据？使用<em>leader-based replication</em>方案</p>
<ul>
<li>选择其中一个副本作为主节点，客户端的写请求必须通过leader</li>
<li>其他副本作为从节点，leader收到请求并发送relication log给followers。followers获取到后再写数据</li>
<li>读请求可通过任何节点读取</li>
</ul>
<p>MySQL、PostgreSQL，Kafka等均通过该方案实现</p>
<h2 id="同步还是异步复制"><a href="#同步还是异步复制" class="headerlink" title="同步还是异步复制"></a>同步还是异步复制</h2><p>同步复制：主节点等待从节点写入数据完成</p>
<p>异步复制：主节点不等待从节点写入数据完成，而直接返回</p>
<p>优缺点：</p>
<ul>
<li>同步优点：能确保从节点的数据与主节点保持一致性</li>
<li>同步缺点：主从节点之间由于各种原因，导致写操作阻塞。从而阻塞后续的写请求</li>
</ul>
<p>通常，主节点与一个从节点保持同步，与其他保持异步。而实际中，完全异步的架构也是很普遍的，这可能会导致数据丢失，可通过<em>共识</em>解决</p>
<h2 id="设置新的Followers"><a href="#设置新的Followers" class="headerlink" title="设置新的Followers"></a>设置新的Followers</h2><p>简单地拷贝数据是不可行的，因为数据是在不断变化的。也许能锁磁盘来解决，但是显然会影响性能。</p>
<ol>
<li>主节点创建自身快照</li>
<li>复制快照到从节点</li>
<li>新的从节点请求从快照创建时间点之后的数据并写入</li>
<li>follower处理完back log之后，我们为<em>caught up</em></li>
</ol>
<h2 id="处理节点宕机"><a href="#处理节点宕机" class="headerlink" title="处理节点宕机"></a>处理节点宕机</h2><h3 id="Follower-failure：Catch-up-recovery"><a href="#Follower-failure：Catch-up-recovery" class="headerlink" title="Follower failure：Catch-up recovery"></a>Follower failure：Catch-up recovery</h3><p>根据log，节点知道失败前的最后一个事务的具体时间点，follower恢复后只需向主节点请求改时间点之后的数据即可。</p>
<h3 id="Leader-failure-Failure-故障切换"><a href="#Leader-failure-Failure-故障切换" class="headerlink" title="Leader failure: Failure(故障切换)"></a>Leader failure: Failure(故障切换)</h3><p>自动流程：</p>
<ol>
<li>确认leader失败。很简单，超时-心跳机制</li>
<li><p>选择个一个新leader。通过其他节点或者控制器选举leader，通常来说是拥有数据最新的（减少数据丢失）</p>
</li>
<li><p>使用leader重新配置整个系统。系统需要保证原leader只能变成follower并认同新leader</p>
</li>
</ol>
<p>潜在问题：</p>
<ul>
<li>原leader拥有未同步的数据，重新加入集群后，跟新leader的数据会有冲突。通过丢去未同步的数据处理，持久性未满足</li>
<li>抛弃数据造成灾难，尤其是与其他系统协作时</li>
<li>某些情况下，两个节点认为自身为leader，我们成为<em>split brain</em>(脑裂)</li>
<li>判定leader失败的超时时间多少合适？网络、负载等等原因都会影响心跳时间</li>
</ul>
<h2 id="Implementation-of-Replication-Logs"><a href="#Implementation-of-Replication-Logs" class="headerlink" title="Implementation of Replication Logs"></a>Implementation of Replication Logs</h2><p>介绍Leader-based replication 是如何实现的</p>
<h3 id="statement-based-replication"><a href="#statement-based-replication" class="headerlink" title="statement-based replication"></a>statement-based replication</h3><p>leader记录每条写请求(statement，语句)，并发送给followers。听起来很简单，但是缺点也多</p>
<ul>
<li>任何非确定性的语句都会有问题，例如NOW()函数</li>
<li>语句如果存在顺序关系，例如<code>UPDATE</code>操作，也会存在问题（除非保证顺序）</li>
<li>语句有副作用，例如触发器，存储过程等</li>
</ul>
<h3 id="Write-ahead-log-WAL-传输"><a href="#Write-ahead-log-WAL-传输" class="headerlink" title="Write-ahead log(WAL) 传输"></a>Write-ahead log(WAL) 传输</h3><p>诸如基于log-structure以及B-Tree的数据库，都会有有一个append-only log。</p>
<p>leader将数据的log发送到各个followers，follower再通过它建立一个与leader一样的copy。广泛应用PostgreSQL等</p>
<p>缺点：</p>
<ul>
<li>log记录的数据过于底层，例如包含哪些磁盘中的哪些字节改变。</li>
<li>数据库版本升级时，版本之间并不兼容，需要停机升级</li>
</ul>
<h3 id="Logical-row-based-log-replication"><a href="#Logical-row-based-log-replication" class="headerlink" title="Logical(row-based)log replication"></a>Logical(row-based)log replication</h3><p>替代底层log，而使用逻辑上的log来表示，其通常是一系列的记录来代表写请求。例如插入，log则包含所有列的新值。</p>
<p>由于其与底层存储解耦了，因此易于兼容不同版本，且能被外部系统解析使用。应用于MySQL中的binlog等</p>
<h3 id="Trigger-based-replication"><a href="#Trigger-based-replication" class="headerlink" title="Trigger-based replication"></a>Trigger-based replication</h3><p>上述均为数据库底层实现，若需要更高的灵活性，则可使用trigger-based的方式。它让你注册一些用户代码，在数据变化时自动触发执行</p>
<h2 id="Porblems-with-Replication-Lag"><a href="#Porblems-with-Replication-Lag" class="headerlink" title="Porblems with Replication Lag"></a>Porblems with Replication Lag</h2><p>relication lag：the delay between a write happening on the leader and being reflected on a follower(leader与follower之间的数据延迟)</p>
<p>通常来说，followers的数据经常会落后于leader，这种状态通常很短。但是一旦lag过长，则会出大问题。如何解决？</p>
<h3 id="Reading-Your-Owen-Writes"><a href="#Reading-Your-Owen-Writes" class="headerlink" title="Reading Your Owen Writes"></a>Reading Your Owen Writes</h3><p><img src="https://github.com/Vonng/ddia/raw/master/img/fig5-3.png" alt="img"></p>
<p>用户修改了，再次查询时可能还是老的。</p>
<p>使用<em>read-after-write consistency</em> 、或称为<code>read-your-writes consistency</code>来保证一致性，即保证用户再次查询时能查到其更新的，这对其他用户不保证。</p>
<p>方案：</p>
<ul>
<li>当获取某些刚修改的数据时，只通过leader查询</li>
<li>常见情况下，可对数据标记，例如更新时间，若更新时间小于1分钟，则从leader中读取</li>
<li>客户端记住最近写的时间戳，然后判读读取</li>
</ul>
<h3 id="单调读"><a href="#单调读" class="headerlink" title="单调读"></a>单调读</h3><p><img src="https://github.com/Vonng/ddia/raw/master/img/fig5-4.png" alt="img"></p>
<p>由于同步时间的不确定性，用户可能发现修改了的数据又复原了，出现时光倒流现象。</p>
<p><em>monotonic reads</em>，使用单调读技术来确保这种情况不会发生。</p>
<p>方案：确保每个用户总是从单个副本中读取</p>
<h3 id="Consistent-Prefix-Reads"><a href="#Consistent-Prefix-Reads" class="headerlink" title="Consistent Prefix Reads"></a>Consistent Prefix Reads</h3><p><img src="https://github.com/Vonng/ddia/raw/master/img/fig5-5.png" alt="img"></p>
<p>本来带有顺序含义的语句，由于复制延迟，第三方观测下顺序异常导致的混乱。例如，聊天的对话顺序</p>
<p>使用<em>consistent prefix reads</em>(一致性前缀读)来避免。</p>
<p>方案：</p>
<ul>
<li>保证任何因果关系的写入都写入到同一个partition。</li>
<li>显式跟踪因果依赖关系的算法。例如<em>happens-before</em>技术</li>
</ul>
<h2 id="Solution-for-Replication-Lag"><a href="#Solution-for-Replication-Lag" class="headerlink" title="Solution for Replication Lag"></a>Solution for Replication Lag</h2><p>使用最终一致性以及分布式事务等</p>
<h2 id="Multi-Leader-Replication-多主复制"><a href="#Multi-Leader-Replication-多主复制" class="headerlink" title="Multi-Leader Replication(多主复制)"></a>Multi-Leader Replication(多主复制)</h2><p>单Leader缺点：所有写入必须经过它。</p>
<p>多Leader缺点：同一数据可能会在不同数据中心被同时处理，需要解决因此带来的<strong>冲突</strong>。</p>
<p>多leader下，每个leader都担任其他leader的follower</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li>性能：多数据中心下，写请求被本地数据中心处理，随后与其他数据中心异步复制</li>
<li>可用性：能有效容忍某个数据中心挂掉</li>
<li><p>网络性能：数据中心间的网络往往很拥堵且不稳定，单leader无法应对，而多leader至少本地能处理用户请求</p>
</li>
<li><p>客户端离线操作：客户端(例如手机设备等)本机类比作为一个datacenter</p>
</li>
<li>协同编辑：多人协同编辑应用，每个设备都类比作为一个datacenter</li>
</ul>
<h3 id="处理写冲突"><a href="#处理写冲突" class="headerlink" title="处理写冲突"></a>处理写冲突</h3><h4 id="避免写冲突"><a href="#避免写冲突" class="headerlink" title="避免写冲突"></a>避免写冲突</h4><p>同一地区或者同一一批设备的写请求都通过同一leader写入。例如通过hash路由的方式等</p>
<h4 id="收敛到一致的状态"><a href="#收敛到一致的状态" class="headerlink" title="收敛到一致的状态"></a>收敛到一致的状态</h4><p>通过一些方法将不同状态的数据收敛到同一状态。</p>
<p>方案：</p>
<ul>
<li>使用LWW(last write wins)技术，即每次写入都绑定一个唯一ID（UUID，时间戳等），选择最大的ID并丢弃其他</li>
<li>给副本绑定ID，选择ID大的副本里的数据</li>
<li>通过某种方式合并，例如字母顺序最大者</li>
<li>或者用数据结构保留冲突，提示用户自己解决</li>
</ul>
<h4 id="自定义冲突解决"><a href="#自定义冲突解决" class="headerlink" title="自定义冲突解决"></a>自定义冲突解决</h4><p>允许用户编写冲突解决逻辑，并在读、写操作是执行。</p>
<ul>
<li>写时：只要检测到冲突即会执行</li>
<li>读时：检测到冲突，会保存所有冲突。用户读取时，提示用户解决，并回写结果。</li>
</ul>
<h3 id="拓扑结构"><a href="#拓扑结构" class="headerlink" title="拓扑结构"></a>拓扑结构</h3><p><img src="https://github.com/Vonng/ddia/raw/master/img/fig5-8.png" alt="img"></p>
<ul>
<li>环形：节点收到来自前一个节点的写请求并传递给下一个节点</li>
<li>星形：一个指定的节点传递给掐所有节点</li>
<li>All-to-all：<ul>
<li>优点：能避免环形以及星形的单点故障影响其他节点的问题</li>
<li>缺点：节点间网络的速率不同，一些复制消息将超过其他消息</li>
</ul>
</li>
</ul>
<h2 id="Leaderless-Replication-无主复制"><a href="#Leaderless-Replication-无主复制" class="headerlink" title="Leaderless Replication(无主复制)"></a>Leaderless Replication(无主复制)</h2><p>无主复制中，写请求通常是直接发送到所有副本中，或者通过coordinator代表客户端写入。</p>
<h4 id="单节点故障时写入"><a href="#单节点故障时写入" class="headerlink" title="单节点故障时写入"></a>单节点故障时写入</h4><p>无主复制中，故障切换是不存在的。节点故障时，只要剩余节点能承认写入即可。</p>
<p>当原节点恢复，将会存在数据不一致的现象，如何解决？</p>
<blockquote>
<p>客户端接收所有副本的返回数据，并选择最新的。通常使用Version numbers来确定</p>
</blockquote>
<h4 id="Read-pair-and-anti-entropy"><a href="#Read-pair-and-anti-entropy" class="headerlink" title="Read pair and anti-entropy"></a>Read pair and anti-entropy</h4><h5 id="Read-repair"><a href="#Read-repair" class="headerlink" title="Read repair"></a>Read repair</h5><p>客户端读取并行所有节点的数据，能检测到stale responses，并回写新数据到老节点</p>
<h5 id="Anti-entropy-process"><a href="#Anti-entropy-process" class="headerlink" title="Anti-entropy process"></a>Anti-entropy process</h5><p>后台进程不断地检测不同节点检测数据差异，并补齐。</p>
<h3 id="Quorums-法定人数-for-reading-and-writing"><a href="#Quorums-法定人数-for-reading-and-writing" class="headerlink" title="Quorums(法定人数) for reading and writing"></a>Quorums(法定人数) for reading and writing</h3><p>定义：只要<code>w + r &gt; n</code>，则客户端总能获得最新的数据。遵守该规则的r与w称为<em>quorums read and write</em></p>
<blockquote>
<p>n: 副本数；r: 读请求时，至少得有r个节点能返回数据；w: 写请求至少要被w个节点确认</p>
</blockquote>
<h3 id="Quorums的局限性"><a href="#Quorums的局限性" class="headerlink" title="Quorums的局限性"></a>Quorums的局限性</h3><ul>
<li>如果两个写入同时发生，不清楚哪一个先发生。</li>
<li>如果写操作在某些副本上成功，而在其他节点上失败（例如，因为某些节点上的磁盘已满），在小于w个副本上写入成功</li>
<li>如果携带新值的节点失败，需要读取其他带有旧值的副本。</li>
</ul>
<p>Dynamo风格可以忍受最终一致性，但是无法绝对保证。更强有力的保证通常需要<strong>事务</strong>或<strong>共识</strong></p>
<h4 id="监控staleness-陈旧度"><a href="#监控staleness-陈旧度" class="headerlink" title="监控staleness(陈旧度)"></a>监控staleness(陈旧度)</h4><p>监视你的数据库是否返回最新的结果是很重要的，如果显著落后，应该提醒您，以便您可以调查原因（例如，网络中的问题或超载节点）。</p>
<h3 id="Sloppy-Quorums-and-Hinted-Handoff"><a href="#Sloppy-Quorums-and-Hinted-Handoff" class="headerlink" title="Sloppy Quorums and Hinted Handoff"></a>Sloppy Quorums and Hinted Handoff</h3><p>写和读仍然需要w和r成功的响应, 只不过把把一些请求暂时寄宿在可达节点上，等不可达节点恢复后再传递到目标节点上</p>
<h3 id="多数据中心"><a href="#多数据中心" class="headerlink" title="多数据中心"></a>多数据中心</h3><p>自然支持，quorums只需在一个数据中心满足即可。</p>
<h3 id="检测并发写"><a href="#检测并发写" class="headerlink" title="检测并发写"></a>检测并发写</h3><p>Dynamo-stype允许客户端并发写同一key。存在事件以不同顺序到达不同的节点。</p>
<p><img src="https://github.com/Vonng/ddia/raw/master/img/fig5-12.png" alt="img"></p>
<p>如果每个节点只是简单地覆盖对应key的值，则会出现不一致现象。因此需要解决冲突</p>
<h4 id="Last-wirte-wins-discharding-current-wirtes"><a href="#Last-wirte-wins-discharding-current-wirtes" class="headerlink" title="Last wirte wins(discharding current wirtes)"></a>Last wirte wins(discharding current wirtes)</h4><p>保存”recent”值，并允许“older”值被覆盖或丢弃。使用一些标识来区分”rencent”以及”older”</p>
<h4 id="The-“happens-before”-relationship-and-concurrency"><a href="#The-“happens-before”-relationship-and-concurrency" class="headerlink" title="The “happens-before” relationship and concurrency"></a>The “happens-before” relationship and concurrency</h4><p>只要有两个操作A和B，就有三种可能性：A在B之前发生，或者B在A之前发生(因果关系)，或者A和B并发。</p>
<p>如果一个操作发生在另一个操作之前，则后面的操作应该覆盖较早的操作，但是如果这些操作是并发的，则存在需要解决的冲突。</p>
<h4 id="捕获”happens-before”关系"><a href="#捕获”happens-before”关系" class="headerlink" title="捕获”happens-before”关系"></a>捕获”happens-before”关系</h4><p><img src="https://github.com/Vonng/ddia/raw/master/img/fig5-13.png" alt="img"></p>
<h4 id="合并同时写入的值"><a href="#合并同时写入的值" class="headerlink" title="合并同时写入的值"></a>合并同时写入的值</h4><p>如果多个操作并发发生，则客户端必须通过合并并发写入的值来擦屁股。</p>
<h4 id="版本向量"><a href="#版本向量" class="headerlink" title="版本向量"></a>版本向量</h4><p>使用单个版本号(上图)来捕获操作之间的依赖关系，但是当多个副本并发接受写入时，这是不够的。</p>
<p> 所有副本的版本号集合称为<strong>版本向量（version vector）</strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>单主复制是非常流行的，因为它很容易理解，不需要担心冲突解决。在出现故障节点，网络中断和延迟峰值的情况下，多领导者和无领导者复制可以更加稳健，但以更难以推理并仅提供非常弱的一致性保证为代价。</p>
<p>多领导者和无领导者复制方法所固有的并发问题：因为他们允许多个写入并发发生冲突。我们研究了一个数据库可能使用的算法来确定一个操作是否发生在另一个操作之前，或者它们是否同时发生。</p>
<h1 id="第六章-分区"><a href="#第六章-分区" class="headerlink" title="第六章-分区"></a>第六章-分区</h1><p>复制提高了数据容错性。</p>
<p>但是当数据量大，且查询吞吐量大时，我就必须把数据拆开并分布到不同分区上(partitions or sharding)。这体现了可扩展性</p>
<h3 id="分区与复制"><a href="#分区与复制" class="headerlink" title="分区与复制"></a>分区与复制</h3><p>分区与复制往往是同时存在的，同一个分区有多个副本，多个副本归属不同分区</p>
<h3 id="Key-Value-类数据的分区"><a href="#Key-Value-类数据的分区" class="headerlink" title="Key-Value 类数据的分区"></a>Key-Value 类数据的分区</h3><p>偏斜(skewed): 分区不公平，导致部分分区拥有较多的数据和查询压力</p>
<p>热点(hopt spot): 由于分区不公平，部分节点承受了过高的负载</p>
<p>如何避免不公平的现象呢？</p>
<h4 id="通过Key-Range分区"><a href="#通过Key-Range分区" class="headerlink" title="通过Key Range分区"></a>通过Key Range分区</h4><p>将连续的keys划分成多个段，并分配个每个分区。如下图的单词分区</p>
<p><img src="https://github.com/Vonng/ddia/raw/master/img/fig6-2.png" alt="img"></p>
<p>为了避免skewed，需要针对数据实际分布来分区。例如单词始子母，书籍1只有A,B，而书籍12却有TUVWXYZ</p>
<p>优点：可以让keys保持排序，这样范围查询将变得很容易</p>
<p>缺点：特定的访问模式容易导致热点现象。</p>
<blockquote>
<p>比如时间戳作为key，按天分区，则当天的时序数据都会往同一分区写，造成热点。此时你可以选择数据源作为key</p>
</blockquote>
<h4 id="通过Hash-of-Key-分区"><a href="#通过Hash-of-Key-分区" class="headerlink" title="通过Hash of Key 分区"></a>通过Hash of Key 分区</h4><p>通过给定key的哈希值来决定分区。已知哈希值的范围后，再按分数区划分范围来指定分区。</p>
<p><img src="https://github.com/Vonng/ddia/raw/master/img/fig6-3.png" alt="img"></p>
<p>有点：分区公平</p>
<p>缺点：范围查询困难</p>
<p>折中方案：使用<em>compound primary key</em>(组合主键)，即将多个列组合成一个key。其中key中的第一部分取用hash后分区，剩余部分做为排序所用的连接索引</p>
<h3 id="负载倾斜与消除热点"><a href="#负载倾斜与消除热点" class="headerlink" title="负载倾斜与消除热点"></a>负载倾斜与消除热点</h3><p>尽管hash的方法能帮助减少热点，但并不能完全避免。比如微博明星出轨现象，对同一key的大量请求，同样会造成热点现象。</p>
<p>这只能应用程序自己处理，例如在key前面或者后面append上随机数字。当然有利必有弊，这将导致其他低吞吐量的key产生不必要的性能损耗</p>
<h3 id="分区以及二级索引"><a href="#分区以及二级索引" class="headerlink" title="分区以及二级索引"></a>分区以及二级索引</h3><h4 id="基于文档分区二级索引"><a href="#基于文档分区二级索引" class="headerlink" title="基于文档分区二级索引"></a>基于文档分区二级索引</h4><p>有利于写，不利于读</p>
<p><img src="https://github.com/Vonng/ddia/raw/master/img/fig6-4.png" alt="img"></p>
<p>每个分区维护自身的二级索引，并覆盖自身分区内的所有文档数据。因此又称，本地索引(<em>local index</em>)</p>
<p>缺点：</p>
<ul>
<li>索引往往会分布在多个分区里。在读取时，会造成<strong>分散/聚集（scatter/gather）</strong>现象，读取二级索引较为低效。</li>
</ul>
<h4 id="基于关键词-Term-分区二级索引"><a href="#基于关键词-Term-分区二级索引" class="headerlink" title="基于关键词(Term)分区二级索引"></a>基于关键词(Term)分区二级索引</h4><p>有利于读，不利于写</p>
<p><img src="https://github.com/Vonng/ddia/raw/master/img/fig6-5.png" alt="img"></p>
<p><strong>关键词分区（term-partitioned）</strong>，因为我们寻找的关键词决定了索引的分区方式。是一种全局的分区方式，又称<strong>全局索引</strong></p>
<p>优点：使读取更有效率：不需要<strong>分散/收集</strong>所有分区，客户端只需要向包含关键词的分区发出请求</p>
<p>缺点：写入速度较慢且较为复杂，因为写入单个文档现在可能会影响索引的多个分区。而且，通常更新全局二级索引都是异步的，你写入后查询并不能立即生效</p>
<h3 id="分区再平衡"><a href="#分区再平衡" class="headerlink" title="分区再平衡"></a>分区再平衡</h3><p>定义：更改都需要数据和请求从一个节点移动到另一个节点。 将负载从集群中的一个节点向另一个节点移动的过程，称为称为<strong>再平衡（reblancing）</strong></p>
<p>最低要求：</p>
<ul>
<li>再平衡之后，负载（数据存储，读取和写入请求）应该在集群中的节点之间公平地共享。</li>
<li>再平衡发生时，数据库应该继续接受读取和写入。</li>
<li>节点之间只移动必须的数据，以便快速再平衡，并减少网络和磁盘I/O负载。</li>
</ul>
<h3 id="平衡策略"><a href="#平衡策略" class="headerlink" title="平衡策略"></a>平衡策略</h3><h4 id="反面教材：hash-mod-N"><a href="#反面教材：hash-mod-N" class="headerlink" title="反面教材：hash mod N"></a>反面教材：hash mod N</h4><p>为什么我们不使用<strong><em>mod</em></strong>（许多编程语言中的％运算符）？</p>
<p>因为，如果节点数量N发生变化，大多数密钥将需要从一个节点移动到另一个节点，这过于昂贵了</p>
<h4 id="固定数量的分区"><a href="#固定数量的分区" class="headerlink" title="固定数量的分区"></a>固定数量的分区</h4><p>创建比节点更多的分区，并为每个节点分配多个分区</p>
<p>如果一个节点被添加到集群中，新节点可以从当前每个节点中<strong>窃取</strong>一些分区，直到分区再次公平分配。</p>
<p><img src="https://github.com/Vonng/ddia/raw/master/img/fig6-6.png" alt="img"></p>
<p>优点：简单</p>
<p>缺点： 如果数据集的总大小难以预估，选择正确的分区数是困难的。</p>
<blockquote>
<p>如果分区非常大，再平衡和从节点故障恢复变得昂贵。但是，如果分区太小，则会产生太多的开销。</p>
</blockquote>
<h4 id="动态分区"><a href="#动态分区" class="headerlink" title="动态分区"></a>动态分区</h4><p>当分区增长到超过配置的大小时，会被分成两个分区，每个分区约占一半的数据。与之相反，如果大量数据被删除并且分区缩小到某个阈值以下，则可以将其与相邻分区合并。此过程与B树底层发生的过程类似</p>
<p>注意，数据集开始时很小，直到达到第一个分区的分割点，所有写入操作都必须由单个节点处理，而其他节点则处于空闲状态。使用<strong>预分割（pre-splitting）</strong>避免</p>
<p>优点：分区数量适应总数据量</p>
<h4 id="按节点比例分区"><a href="#按节点比例分区" class="headerlink" title="按节点比例分区"></a>按节点比例分区</h4><p>使分区数与节点数成正比，即每个节点具有固定数量的分区。</p>
<p>当一个新节点加入集群时，它随机选择固定数量的现有分区进行拆分，然后获取每个分区的一半数据，另外一半保留。</p>
<p>随机化可能会产生不公平的分区，可以通过增大分区数来平均化(Cassandra每个节点默认就256个分区)</p>
<h3 id="运维：手动还是自动平衡"><a href="#运维：手动还是自动平衡" class="headerlink" title="运维：手动还是自动平衡"></a>运维：手动还是自动平衡</h3><p>全自动重新平衡可以很方便，但是自动化与自动故障检测相结合可能十分危险。例如误判过载的节点已经死亡</p>
<h2 id="请求路由"><a href="#请求路由" class="headerlink" title="请求路由"></a>请求路由</h2><p>当客户想要发出请求时，如何知道要连接哪个节点？使用<strong>服务发现(service discovery)</strong> 技术</p>
<p><img src="https://github.com/Vonng/ddia/raw/master/img/fig6-7.png" alt="img"></p>
<p>挑战：无论如何，所有参与者都同意路由规则，否则请求将被发送到错误的节点。</p>
<p>方案一：</p>
<p>许多分布式数据系统都依赖于一个独立的协调服务，比如ZooKeeper来跟踪集群元数据。</p>
<ul>
<li>每个节点在ZooKeeper中注册自己，ZooKeeper维护分区到节点的可靠映射</li>
<li>只要分区分配发生的改变，或者集群中添加或删除了一个节点，ZooKeeper就会通知路由层使路由信息保持最新状态。</li>
</ul>
<p>方案二：</p>
<p>在节点之间使用<strong>流言协议（gossip protocol）</strong> 来传播群集状态的变化。</p>
<ul>
<li>请求可以发送到任意节点，该节点会转发到包含所请求的分区的适当节点。如上图中的方法1</li>
</ul>
<h3 id="执行并行查询"><a href="#执行并行查询" class="headerlink" title="执行并行查询"></a>执行并行查询</h3><p><strong>大规模并行处理（MPP, Massively parallel processing）</strong>，MPP查询优化器将这个复杂的查询分解成许多执行阶段和分区，其中许多可以在数据库集群的不同节点上并行执行</p>
<h1 id="第七章-事务"><a href="#第七章-事务" class="headerlink" title="第七章-事务"></a>第七章-事务</h1><p>事务是应用程序将多个读写操作组合成一个逻辑单元的一种方式，整个事务要么成功（<strong>提交（commit）</strong>）要么失败（<strong>中止（abort）</strong>，<strong>回滚（rollback）</strong>）。如果失败，应用程序可以安全地重试。</p>
<p>提供一层抽象，给应用程序一种并发、软硬件问题均不会存在的假象。</p>
<h2 id="ACID的含义"><a href="#ACID的含义" class="headerlink" title="ACID的含义"></a>ACID的含义</h2><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>一般来说，原子是指不能分解成小部分的东西。</p>
<p>在多线程编程中，如果一个线程执行一个原子操作，这意味着另一个线程无法看到该操作的一半结果。</p>
<p>ACID的原子性中，描述了当客户想进行多次写入，在一些写操作处理完之后出现故障时，<strong>能够在错误时中止事务，丢弃该事务进行的所有写入变更的能力</strong></p>
<h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p>ACID的上下文中，<strong>一致性</strong>是指数据库在应用程序的特定概念中处于“良好状态”</p>
<p><strong>you have certain statements about your data that must always be true</strong>, 比如在会计系统中，所有账户整体上必须借贷相抵</p>
<p>原子性，隔离性和持久性是数据库的属性，而一致性（在ACID意义上）是应用程序的属性</p>
<h3 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h3><p><strong>同时执行的事务是相互隔离的</strong>：它们不能相互冒犯</p>
<h3 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h3><p><strong>持久性</strong> 是一个承诺，即一旦事务成功完成，即使发生硬件故障或数据库崩溃，写入的任何数据也不会丢失。</p>
<h2 id="单对象和多对象操作"><a href="#单对象和多对象操作" class="headerlink" title="单对象和多对象操作"></a>单对象和多对象操作</h2><p>多对象事务需要某种方式来确定哪些读写操作属于同一个事务，在关系型数据库中，通常基于客户端与数据库服务器的TCP连接：在任何特定连接上，<code>BEGIN TRANSACTION</code> 和 <code>COMMIT</code> 语句之间的所有内容，被认为是同一事务的一部分。</p>
<h3 id="单对象写入"><a href="#单对象写入" class="headerlink" title="单对象写入"></a>单对象写入</h3><p>对单节点上的单个对象（例如键值对）上提供原子性和隔离性</p>
<h3 id="多对象事务的需求"><a href="#多对象事务的需求" class="headerlink" title="多对象事务的需求"></a>多对象事务的需求</h3><p>场景：</p>
<ul>
<li>在关系数据模型中，一个表中的行通常具有对另一个表中的行的外键引用</li>
<li>当需要更新非规范化的信息时，需要一次更新多个文档</li>
<li>每次更改值时都需要更新索引</li>
</ul>
<p>针对多对象，<strong>若没有原子性，错误处理就要复杂得多，若缺乏隔离性，就会导致并发问题</strong></p>
<h3 id="处理错误和中止"><a href="#处理错误和中止" class="headerlink" title="处理错误和中止"></a>处理错误和中止</h3><p>事务的一个关键特性是，如果发生错误，它可以中止并安全地重试。如若未被ACID，则会终止整个事务，而不是保留半完成的状态</p>
<p>然而，有些数据库则选择，做尽可能多的事，运行遇到错误时，它不会撤消它已经完成的事情，此时，从错误中恢复就是应用程序的责任了。</p>
<p>中止重试的潜在问题：</p>
<ul>
<li>如果事务实际上成功了，但是在服务器试图向客户端确认提交成功时网络发生故障，那么重试事务会导致事务被执行两次</li>
<li>重试事务将使负载过大变得更糟</li>
<li>仅在临时性错误（例如，由于死锁，异常情况，临时性网络中断和故障切换）后才值得重试。在发生永久性错误（例如，违反约束）之后重试是毫无意义的。</li>
<li>如果事务在数据库之外也有副作用，即使事务被中止，也可能发生这些副作用</li>
<li>如果客户端进程在重试中失效，任何试图写入数据库的数据都将丢失。</li>
</ul>
<h2 id="弱隔离级别"><a href="#弱隔离级别" class="headerlink" title="弱隔离级别"></a>弱隔离级别</h2><p>当一个事务读取由另一个事务同时修改的数据时，或者当两个事务试图同时修改相同的数据时，并发问题（竞争条件）才会出现。而且并发BUG很难通过测试找到。</p>
<p>因此，数据库提供了<strong>事务隔离（transaction isolation）</strong> 来隐藏应用程序开发者的并发问题。</p>
<p><strong>可序列化（serializable）</strong> 的隔离等级意味着数据库保证事务的效果如同连续运行。</p>
<p>然而，为了性能，系统通常使用较弱的隔离级别来防止一部分，而不是全部的并发问题</p>
<h3 id="读已提交-Read-Commited"><a href="#读已提交-Read-Commited" class="headerlink" title="读已提交(Read Commited)"></a>读已提交(Read Commited)</h3><p>保证：</p>
<ul>
<li>从数据库读时，只能看到已提交的数据（没有<strong>脏读（ no dirty reads）</strong>）</li>
<li>写入数据库时，只会覆盖已经写入的数据（没有<strong>脏写（no dirty writes）</strong>）。</li>
</ul>
<h4 id="No-dirty-reads"><a href="#No-dirty-reads" class="headerlink" title="No dirty reads"></a>No dirty reads</h4><p>脏读(dirty reads): 假定一个事务已经将一些数据写入数据库，但事务还没有提交或中止。另一个事务可以看到未提交的数据吗？如果是的话，那就叫做<strong>脏读</strong></p>
<p>避免脏读的原因：</p>
<ul>
<li>如果事务需要更新多个对象，脏读取意味着另一个事务可能会只看到一部分更新</li>
<li>如果事务中止，则所有写入操作都需要回滚，若数据库允许脏读，就意味着一个事务可能会看到稍后需要回滚的数据，即从未实际提交给数据库的数据。</li>
</ul>
<h4 id="No-dirty-writes"><a href="#No-dirty-writes" class="headerlink" title="No dirty writes"></a>No dirty writes</h4><p>如果两个事务同时尝试更新数据库中的相同对象，会发生什么情况？通常认为后面的写入会覆盖前面的写入。如果先前的写入是尚未提交事务的一部分，又会发生什么情况，后面的写入会覆盖一个尚未提交的值？这被称作<strong>脏写</strong>。</p>
<p>在<strong>读已提交</strong>的隔离级别上运行的事务必须防止脏写，通常是延迟第二次写入，直到第一次写入事务提交或中止为止。</p>
<p>避免脏写的原因：</p>
<ul>
<li>如果事务更新多个对象，脏写会导致不好的结果，比如，来自不同事务的冲突写入可能会混淆在一起。</li>
<li>Read commited并不能防止两个计数器增量之间的竞争状态。</li>
</ul>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>防止脏写: </p>
<blockquote>
<p> 使用<strong>行锁（row-level lock）</strong>，当事务想要修改特定对象（row or ducument）时，它必须首先获得该对象的锁。然后必须持有该锁直到事务被提交或中止。一次只有一个事务可持有任何给定对象的锁；如果另一个事务要写入同一个对象，则必须等到第一个事务提交或中止后，才能获取该锁并继续。</p>
</blockquote>
<p>防止脏读：</p>
<blockquote>
<p>也可以用锁，不过有性能问题，不采用。因此，通常对于写入的每个对象，数据库都会记住旧的已提交值，和由当前持有写入锁的事务设置的新值。当事务正在进行时，任何其他读取对象的事务都会拿到旧值。 只有当新值提交后，事务才会切换到读取新值。</p>
</blockquote>
<h3 id="快照隔离和可重复读"><a href="#快照隔离和可重复读" class="headerlink" title="快照隔离和可重复读"></a>快照隔离和可重复读</h3><p><img src="https://github.com/Vonng/ddia/raw/master/img/fig7-6.png" alt="img"></p>
<p>这种异常被称为<strong>不可重复读（nonrepeatable read）\</strong>或**读取偏差（read skew）**。</p>
<p>对于read commited来说，这种情况是可容忍的，然而以下情况则不可</p>
<ul>
<li>备份，备份进程运行时，数据库仍然会接受写入操作。因此备份可能会包含一些旧的部分和一些新的部分。</li>
<li>分析查询和完整性检查，一个查询，扫描大部分的数据库，查询在不同时间点观察数据库的不同部分，则可能会返回毫无意义的结果</li>
</ul>
<p>使用<strong>快照隔离（snapshot isolation）</strong>，每个事务都从数据库的<strong>一致快照（consistent snapshot）</strong> 中读取。也就是说，事务可以看到事务开始时在数据库中提交的所有数据。即使这些数据随后被另一个事务更改，每个事务也<strong>只能</strong>看到该特定时间点的旧数据。</p>
<h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>也通常使用写锁来防止脏写，这意味着进行写入的事务会阻止另一个事务修改同一个对象。但是读取不需要任何锁定。性能角度，<strong>读不阻塞写，写不阻塞读</strong></p>
<p>数据库必须可能保留一个对象的几个不同的提交版本，因为各种正在进行的事务可能需要看到数据库在不同的时间点的状态。因为它并排维护着多个版本的对象，所以这种技术被称为<strong>多版本并发控制（MVCC, multi-version concurrentcy control）</strong>。</p>
<p><img src="https://github.com/Vonng/ddia/raw/master/img/fig7-7.png" alt="img"></p>
<p>表中的每一行都有一个 <code>created_by</code> 字段，其中包含将该行插入到表中的的事务ID。</p>
<p>每行都有一个 <code>deleted_by</code> 字段，删除时，将 <code>deleted_by</code> 字段设置为请求删除的事务的ID来标记为删除。其中，update转换为一个delete和create</p>
<h4 id="一致性快照的可见性规则"><a href="#一致性快照的可见性规则" class="headerlink" title="一致性快照的可见性规则"></a>一致性快照的可见性规则</h4><p>当一个事务从数据库中读取时，事务ID用于决定它可以看见哪些对象，看不见哪些对象。工作流程：</p>
<ol>
<li>在每次事务开始时，数据库列出当时所有其他在运行（尚未提交或尚未中止）的事务清单，即使在它之后提交了，这些事务已执行的任何写入也都会被忽略。</li>
<li>被已中止的事务所执行的任何写入都将被忽略。</li>
<li>由具有较晚事务ID（即，在当前事务开始之后开始的）的事务所做的任何写入都被忽略，而不管这些事务是否已经提交。</li>
<li>所有其他写入，对应用都是可见的。</li>
</ol>
<p>一个对象可见的条件：</p>
<ul>
<li>读事务开始时，创建该对象的事务已经提交。</li>
<li>对象未被标记为删除，或如果被标记为删除，请求删除的事务在读事务开始时尚未提交。</li>
</ul>
<h4 id="索引和快照隔离"><a href="#索引和快照隔离" class="headerlink" title="索引和快照隔离"></a>索引和快照隔离</h4><p>索引如何在多版本数据库中工作？一种选择是使索引简单地指向对象的所有版本，并且需要索引查询来过滤掉当前事务不可见的任何对象版本</p>
<h4 id="可重复读与命名混淆"><a href="#可重复读与命名混淆" class="headerlink" title="可重复读与命名混淆"></a>可重复读与命名混淆</h4><p>快照隔离是一个有用的隔离级别，特别对于只读事务而言。但是，许多数据库实现了它，却用不同的名字来称呼。在Oracle中称为<strong>可序列化（Serializable）\</strong>的，在PostgreSQL和MySQL中称为**可重复读（repeatable read）**</p>
<h3 id="防止丢失更新"><a href="#防止丢失更新" class="headerlink" title="防止丢失更新"></a>防止丢失更新</h3><p>如果应用从数据库中读取一些值，修改它并写回修改的值（读取-修改-写入序列，<em>read-modify-write-cycle</em>），则可能会发生丢失更新的问题。例如，如果两个事务同时执行，则其中一个的修改可能会丢失，因为第二个写入的内容并没有包括第一个事务的修改。</p>
<p>场景：</p>
<ul>
<li>增加计数器或更新账户余额（需要读取当前值，计算新值并写回更新后的值）</li>
<li>在复杂值中进行本地修改：例如，将元素添加到JSON文档中的一个列表（需要解析文档，进行更改并写回修改的文档）</li>
<li>两个用户同时编辑wiki页面，每个用户通过将整个页面内容发送到服务器来保存其更改，覆写数据库中当前的任何内容。</li>
</ul>
<h4 id="原子写"><a href="#原子写" class="headerlink" title="原子写"></a>原子写</h4><p>使用原子操作，通常是最好的解决方案。</p>
<p>方法一，原子操作通常通过在读取对象时，获取其上的排它锁来实现，以便更新完成之前没有其他事务可以读取它。</p>
<p>方法二，强制所有的原子操作在单一线程上执行</p>
<h4 id="显式锁定"><a href="#显式锁定" class="headerlink" title="显式锁定"></a>显式锁定</h4><p>让应用程序显式地锁定将要更新的对象。应用程序可以执行读取-修改-写入序列，如果任何其他事务尝试同时读取同一个对象，则强制等待，直到第一个<strong>读取-修改-写入序列</strong>完成</p>
<h4 id="自动检测丢失的更新"><a href="#自动检测丢失的更新" class="headerlink" title="自动检测丢失的更新"></a>自动检测丢失的更新</h4><p>允许它们并行执行，如果事务管理器检测到丢失更新，则中止事务并强制它们重试其<strong>读取-修改-写入序列</strong></p>
<p>优点：数据库可以结合快照隔离高效地执行此检查；它不需要应用代码使用任何特殊的数据库功能</p>
<h4 id="比较并设置（CAS）"><a href="#比较并设置（CAS）" class="headerlink" title="比较并设置（CAS）"></a>比较并设置（CAS）</h4><p><strong>比较并设置（CAS, Compare And Set）</strong>，只有当前值从上次读取时一直未改变，才允许更新发生</p>
<h4 id="冲突解决和复制"><a href="#冲突解决和复制" class="headerlink" title="冲突解决和复制"></a>冲突解决和复制</h4><p>最后写入胜利（LWW）的冲突解决方法很容易丢失更新，不幸的是，LWW是许多复制数据库中的默认方案。</p>
<h3 id="写入偏差与幻读"><a href="#写入偏差与幻读" class="headerlink" title="写入偏差与幻读"></a>写入偏差与幻读</h3><p><img src="https://github.com/Vonng/ddia/raw/master/img/fig7-8.png" alt="img"></p>
<h4 id="写偏差-write-skew"><a href="#写偏差-write-skew" class="headerlink" title="写偏差(write skew)"></a>写偏差(write skew)</h4><p>如果两个事务读取相同的对象，然后更新其中一些对象（不同的事务可能更新不同的对象），则可能发生写入偏差。</p>
<p>例子：</p>
<ul>
<li><strong><em>会议室预订系统</em></strong>，当有人想要预订时，首先检查是否存在相互冲突的预订（即预订时间范围重叠的同一房间），如果没有找到，则创建会议。快照隔离并不能防止另一个用户同时插入冲突的会议。</li>
<li><p><strong><em>多人游戏</em></strong>，玩家将两个不同的棋子移动到棋盘上的相同位置，或者采取其他违反游戏规则的行为。</p>
</li>
<li><p><strong><em>抢注用户名</em></strong>，在每个用户拥有唯一用户名的网站上，两个用户可能会尝试同时创建具有相同用户名的帐户。</p>
</li>
<li><strong><em>防止双重开支</em></strong>，允许用户花钱或积分的服务，需要检查用户的支付数额不超过其余额。有了写入偏差，可能会发生两个支出项目同时插入，一起导致余额变为负值，但这两个事务都不会注意到另一个。</li>
</ul>
<h4 id="导致写入偏差的幻读"><a href="#导致写入偏差的幻读" class="headerlink" title="导致写入偏差的幻读"></a>导致写入偏差的幻读</h4><p>上述例子，基本遵循规律</p>
<ol>
<li>一个<code>SELECT</code>查询找出符合条件的行，并检查是否符合一些要求。</li>
<li>按照第一个查询的结果，应用代码决定是否继续。（可能会继续操作，也可能中止并报错）</li>
<li>如果应用决定继续操作，就执行写入（插入、更新或删除），并提交事务。</li>
</ol>
<p>一个事务中的写入改变另一个事务的搜索查询的结果，被称为<strong>幻读</strong>（快照隔离避免了只读查询中幻读）</p>
<h4 id="物化冲突"><a href="#物化冲突" class="headerlink" title="物化冲突"></a>物化冲突</h4><p>将幻读变为数据库中一组具体行上的锁冲突</p>
<h2 id="Serializability-可序列化"><a href="#Serializability-可序列化" class="headerlink" title="Serializability(可序列化)"></a>Serializability(可序列化)</h2><p>能有效解决写入偏差，幻读等问题。</p>
<p>可序列化（Serializability ）隔离通常被认为是<strong>最强</strong>的隔离级别。它保证即使事务可以并行执行，最终的结果也是一样的，就好像它们没有任何并发性，连续挨个执行一样。</p>
<p>因此数据库保证，如果事务在单独运行时正常运行，则它们在并发运行时继续保持正确 —— 换句话说，数据库可以防止所有可能的竞争条件。</p>
<p>如何实现？</p>
<h3 id="真-串行执行"><a href="#真-串行执行" class="headerlink" title="真*串行执行"></a>真*串行执行</h3><p>最简之法，<strong>完全不要并发</strong>：在单个线程上按顺序一次只执行一个事务。</p>
<p>这样做就完全绕开了检测/防止事务间冲突的问题，由此产生的隔离，正是可序列化的定义。</p>
<p>能实际运用的原因：</p>
<ul>
<li>RAM足够便宜了，许多场景现在都可以将完整的活跃数据集保存在内存中</li>
<li>数据库设计人员意识到OLTP事务通常很短，而且只进行少量的读写操作。相比之下，长时间的OLAP，通常是只读的</li>
</ul>
<h4 id="在存储过程中封装事务"><a href="#在存储过程中封装事务" class="headerlink" title="在存储过程中封装事务"></a>在存储过程中封装事务</h4><p>即使用存储过程，将各个阶段的操作合并为单个事务</p>
<h4 id="串行执行小结"><a href="#串行执行小结" class="headerlink" title="串行执行小结"></a>串行执行小结</h4><ul>
<li>每个事务都必须小而快，只要有一个缓慢的事务，就会拖慢所有事务处理。</li>
<li>仅限于活跃数据集可以放入内存的情况</li>
<li>写入吞吐量必须低到能在单个CPU核上处理，如若不然，事务需要能划分至单个分区，且不需要跨分区协调。</li>
<li>跨分区事务是可能的，但是它们的使用程度有很大的限制。</li>
</ul>
<h3 id="两阶段锁定（2PL）"><a href="#两阶段锁定（2PL）" class="headerlink" title="两阶段锁定（2PL）"></a>两阶段锁定（2PL）</h3><p>只要没有写入，就允许多个事务同时读取同一个对象。但对象只要有写入（修改或删除），就需要<strong>独占访问（exclusive access）</strong> 权限：</p>
<ul>
<li>如果事务A读取了一个对象，并且事务B想要写入该对象，那么B必须等到A提交或中止才能继续。（这确保B不能在A底下意外地改变对象。）</li>
<li>如果事务A写入了一个对象，并且事务B想要读取该对象，则B必须等到A提交或中止才能继续。（读取旧版本的对象在2PL下是不可接受的。）</li>
</ul>
<h4 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h4><p>为数据库中每个对象添加锁来实现的。锁可以处于<strong>共享模式（shared mode）\</strong>或**独占模式（exclusive mode**</p>
<ul>
<li>若事务要读取对象，则须先以共享模式获取锁。允许多个事务同时持有共享锁。但如果另一个事务已经在对象上持有排它锁，则这些事务必须等待。</li>
<li>若事务要写入一个对象，它必须首先以独占模式获取该锁。没有其他事务可以同时持有锁（无论是共享模式还是独占模式），所以如果对象上存在任何锁，该事务必须等待。</li>
<li>如果事务先读取再写入对象，则它可能会将其共享锁升级为独占锁。升级锁的工作与直接获得排他锁相同。</li>
<li>事务获得锁之后，必须继续持有锁直到事务结束（提交或中止）。这就是“两阶段”这个名字的来源：第一阶段（当事务正在执行时）获取锁，第二阶段（在事务结束时）释放所有的锁。</li>
</ul>
<p>死锁发生：事务A等待事务B释放它的锁，反之亦然。数据库会自动检测，并中止其中一个。</p>
<h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p>一部分是由于获取和释放所有这些锁的开销，但更重要的是由于并发性的降低。</p>
<p>只需要一个缓慢的事务，或者一个访问大量数据并获取许多锁的事务，就能把系统的其他部分拖慢。</p>
<p>当事务由于死锁而被中止并被重试时，它需要从头重做它的工作。如果死锁很频繁，这可能意味着巨大的浪费。</p>
<h4 id="谓词锁"><a href="#谓词锁" class="headerlink" title="谓词锁"></a>谓词锁</h4><p>它类似于前面描述的共享/排它锁，但不属于特定的对象（例如，表中的一行），它属于所有符合某些<strong>搜索条件</strong>的对象</p>
<h4 id="索引范围锁"><a href="#索引范围锁" class="headerlink" title="索引范围锁"></a>索引范围锁</h4><p>如果活跃事务持有很多锁，检查匹配的锁会非常耗时。因此，大多数使用2PL的数据库实际上实现了<strong>索引范围锁</strong>（也称为<strong>间隙锁（next-key locking </strong>），这是一个简化的近似版谓词锁</p>
<p>在房间预订数据库中，您可能会在<code>room_id</code>列上有一个索引，并且/或者在<code>start_time</code> 和 <code>end_time</code>上有索引（否则前面的查询在大型数据库上的速度会非常慢）</p>
<ul>
<li>设您的索引位于<code>room_id</code>上，并且数据库使用此索引查找123号房间的现有预订。现在数据库可以简单地将共享锁附加到这个索引项上，指示事务已搜索123号房间用于预订。</li>
<li>或者，如果数据库使用基于时间的索引来查找现有预订，那么它可以将共享锁附加到该索引中的一系列值，指示事务已经将12:00~13:00时间段标记为用于预定。</li>
</ul>
<p>现在，如果另一个事务想要插入，更新或删除同一个房间和/或重叠时间段的预订，则它将不得不更新索引的相同部分，此时，它会遇到共享锁，它将被迫等到锁被释放。</p>
<h3 id="序列化快照隔离（SSI）"><a href="#序列化快照隔离（SSI）" class="headerlink" title="序列化快照隔离（SSI）"></a>序列化快照隔离（SSI）</h3><p>很有前途</p>
<h4 id="悲观与乐观的并发控制"><a href="#悲观与乐观的并发控制" class="headerlink" title="悲观与乐观的并发控制"></a>悲观与乐观的并发控制</h4><p>两阶段锁(2PL)是一种所谓的<strong>悲观并发控制机制</strong>。意味着，如果有事情可能出错（如另一个事务所持有的锁所表示的），最好等到情况安全后再做任何事情。这就像互斥，用于保护多线程编程中的数据结构。</p>
<p><strong>序列化快照隔离</strong>是一种<strong>乐观（optimistic）</strong> 的并发控制技术。意味着，如果存在潜在的危险也不阻止事务，而是继续执行事务，希望一切都会好起来。当一个事务想要提交时，数据库检查是否有什么不好的事情发生（比如，隔离是否被违反）；如果是的话，事务将被中止，并且必须重试。</p>
<p>SSI基于快照隔离，事务中的所有读取都是来自数据库的一致性快照。SSI添加了一种算法来检测写入之间的序列化冲突，并确定要中止哪些事务。</p>
<h4 id="基于过时前提的决策"><a href="#基于过时前提的决策" class="headerlink" title="基于过时前提的决策"></a>基于过时前提的决策</h4><p>事务从数据库读取一些数据，检查查询的结果，并根据它看到的结果决定采取一些操作（写入数据库）。但是，在快照隔离的情况下，原始查询的结果在事务提交时可能不再是最新的，因为数据可能在同一时间被修改。</p>
<p>事务基于一个<strong>前提（premise）</strong> 采取行动（事务开始时候的事实，例如：“目前有两名医生正在值班”）</p>
<h4 id="检测旧MVCC读取"><a href="#检测旧MVCC读取" class="headerlink" title="检测旧MVCC读取"></a>检测旧MVCC读取</h4><p>数据库需要跟踪一个事务由于MVCC可见性规则而忽略另一个事务的写入。当事务想要提交时，数据库检查是否有任何被忽略的写入现在已经被提交。如果是这样，事务必须中止。</p>
<h4 id="检测影响之前读取的写入"><a href="#检测影响之前读取的写入" class="headerlink" title="检测影响之前读取的写入"></a>检测影响之前读取的写入</h4><p>第二种情况要考虑的是另一个事务在读取数据之后修改数据。</p>
<p><img src="https://github.com/Vonng/ddia/raw/master/img/fig7-11.png" alt="img"></p>
<p>如果在<code>shift_id</code>上有索引，则数据库可以使用索引项1234 来记录事务42 和43 读取这个数据的事实。</p>
<p>当事务写入数据库时，它必须在索引中查找最近曾读取受影响数据的其他事务。并通知其他事务：你们读过的数据可能不是最新的啦。</p>
<h4 id="可序列化的快照隔离的性能"><a href="#可序列化的快照隔离的性能" class="headerlink" title="可序列化的快照隔离的性能"></a>可序列化的快照隔离的性能</h4><p>有很多细节影响。例如，跟踪事务的读取和写入的<strong>粒度</strong>，粒度越细，准确度越高，但性能损耗也越高。事务可以读取被另一个事务覆盖的信息。</p>
<p>与两阶段锁定相比，可序列化快照隔离的最大优点是一个事务不需要阻塞等待另一个事务所持有的锁。</p>
<p>中止率显著影响SSI的整体表现，对于慢事务，SSI可能比两阶段锁定或串行执行更不敏感。</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ul>
<li><strong><em>脏读</em></strong>： 一个客户端读取到另一个客户端尚未提交的写入。<strong>读已提交</strong>或更强的隔离级别可以防止脏读。</li>
<li><strong><em>脏写</em></strong>： 一个客户端覆盖写入了另； 一个客户端尚未提交的写入。几乎所有的事务实现都可以防止脏写。</li>
<li><strong><em>读取偏差（不可重复读）</em></strong>：  在同一个事务中，客户端在不同的时间点会看见数据库的不同状态。<strong>快照隔离</strong>，通常使用<strong>多版本并发控制（MVCC）</strong> 来实现</li>
<li><strong><em>更新丢失</em></strong>： 两个客户端同时执行<strong>读取-修改-写入序列</strong>。其中一个写操作，在没有合并另一个写入变更情况下，直接覆盖了另一个写操作的结果。所以导致数据丢失。</li>
<li><strong><em>写偏差</em></strong>： 一个事务读取一些东西，根据它所看到的值作出决定，并将该决定写入数据库。但是，写入时，该决定的前提不再是真实的。只有可序列化的隔离才能防止这种异常。</li>
<li><strong><em>幻读</em></strong>： 事务读取符合某些搜索条件的对象。另一个客户端进行写入，影响搜索结果。快照隔离可以防止直接的幻像读取，但是写入偏差上下文中的幻读需要特殊处理，例如索引范围锁定。</li>
</ul>
<h1 id="第八章-分布式系统的麻烦"><a href="#第八章-分布式系统的麻烦" class="headerlink" title="第八章-分布式系统的麻烦"></a>第八章-分布式系统的麻烦</h1><h2 id="故障与部分失效"><a href="#故障与部分失效" class="headerlink" title="故障与部分失效"></a>故障与部分失效</h2><p>当你在一台计算机上编写一个程序时，它通常会以一种相当可预测的方式运行：无论是工作还是不工作。因为计算机设计目的就是<strong>总是正确地计算</strong></p>
<p><strong>部分失效（partial failure）</strong>： 部分正常工作，系统其它部分则被不可预料地破坏了。</p>
<p><strong>不确定性的（nonderterministic）</strong>：如果你试图做任何涉及多个节点和网络的事情，它有时可能会工作，有时会出现不可预知的失败。</p>
<h2 id="云计算与超级计算机"><a href="#云计算与超级计算机" class="headerlink" title="云计算与超级计算机"></a>云计算与超级计算机</h2><p>超级计算机：高性能计算（HPC）领域，计算密集型科学计算任务，如天气预报或分子动力学。（垂直扩展的极致），类似于单个计算机</p>
<p>云计算：通常与多租户数据中心，连接IP网络的商品计算机（通常是以太网），弹性/按需资源分配以及计量计费等相关联。</p>
<p>分布式系统更接近于云计算</p>
<h2 id="不可靠的网络"><a href="#不可靠的网络" class="headerlink" title="不可靠的网络"></a>不可靠的网络</h2><p><strong>异步分组网络（asynchronous packet networks）</strong>，一个节点可以向另一个节点发送一个消息（一个数据包），但是网络不能保证它什么时候到达，或者是否到达。</p>
<p>处理这个问题的通常方法是<strong>超时（Timeout）</strong>，在一段时间之后放弃等待，并且认为响应不会到达。</p>
<h3 id="实际的网络错误"><a href="#实际的网络错误" class="headerlink" title="实际的网络错误"></a>实际的网络错误</h3><p>一句话，并非永远可靠。需要你做额外处理，假设。</p>
<h3 id="检测故障"><a href="#检测故障" class="headerlink" title="检测故障"></a>检测故障</h3><p>系统需要自动检测故障节点。例如，负载平衡器需要停止向已死亡的节点转发请求。</p>
<p>网络不定，加重判断难度：</p>
<ul>
<li>如果节点在处理请求时发生崩溃，则无法知道远程节点实际处理了多少数据</li>
<li>节点操作系统上，添加脚本，可以通知其他节点有关该崩溃的信息</li>
</ul>
<p>总的来说，必须假设你根本就没有得到任何回应。可以重试几次，等待超时过期，并且如果在超时时间内没有收到响应，则最终声明节点已经死亡。</p>
<h3 id="超时与无穷的延迟"><a href="#超时与无穷的延迟" class="headerlink" title="超时与无穷的延迟"></a>超时与无穷的延迟</h3><p>超时应该是多少？</p>
<ul>
<li>过多？意味着长时间等待，期间，用户可能不得不等待，或者看到错误信息。</li>
<li>过短？错误地判断节点失效（例如节点只是暂时地高负载）的风险更高，而转移节点，这会给其他节点和网络带来额外的负担，从而更加恶化情况</li>
</ul>
<p>如何估算？2d+r？实际情况下，都无法保证，异步网络具有无限的延迟，服务器并不能保证它们可以在一定的最大时间内处理请求。</p>
<h4 id="网络拥塞和排队"><a href="#网络拥塞和排队" class="headerlink" title="网络拥塞和排队"></a>网络拥塞和排队</h4><p>网络上数据包延迟的可变性通常是由于排队，例如</p>
<ul>
<li>CPU内核当前都处于繁忙状态，网络传入请求将被操作系统排队</li>
<li>TCP执行<strong>流量控制</strong>，意味着在数据甚至进入网络之前，在发送者处需要进行额外的排队</li>
</ul>
<p>解决办法：</p>
<ul>
<li>通过实验方式选择超时：测量延长的网络往返时间和多台机器的分布，以确定延迟的预期可变性</li>
<li>连续测量响应时间及其变化：根据观察到的响应时间分布自动调整超时时间</li>
</ul>
<h3 id="同步网络-vs-异步网络"><a href="#同步网络-vs-异步网络" class="headerlink" title="同步网络 vs 异步网络"></a>同步网络 vs 异步网络</h3><p>同步网络：即使数据经过多个路由器，也不会受到排队的影响，因为呼叫的16位空间已经在网络的下一跳中保留了下来（电话通信）</p>
<p>存在的问题，利用率低，吞吐量低。</p>
<p>异步网络：如TCP协议，是try best策略</p>
<h2 id="不可靠的时钟"><a href="#不可靠的时钟" class="headerlink" title="不可靠的时钟"></a>不可靠的时钟</h2><p>通信不即时：消息通过网络从一台机器传送到另一台机器需要时间。</p>
<p>时钟硬件设备也不一定稳定正确</p>
<h3 id="单调钟与时钟"><a href="#单调钟与时钟" class="headerlink" title="单调钟与时钟"></a>单调钟与时钟</h3><h4 id="时钟："><a href="#时钟：" class="headerlink" title="时钟："></a>时钟：</h4><p>根据某个日历，返回当前日期和时间。如timestamp, date之类</p>
<h4 id="单调钟："><a href="#单调钟：" class="headerlink" title="单调钟："></a>单调钟：</h4><p>单调钟适用于测量持续时间（时间间隔）。</p>
<p>NTP协议检测到计算机的本地石英钟比NTP服务器要更快或更慢，可以调整单调钟向前走的频率</p>
<p>在分布式系统中，使用单调钟测量<strong>经过时间（elapsed time）</strong></p>
<h3 id="时钟同步与准确性"><a href="#时钟同步与准确性" class="headerlink" title="时钟同步与准确性"></a>时钟同步与准确性</h3><p> 单调钟不需要同步，但是时钟需要根据NTP服务器或其他外部时间源来设置才能有用。而外部来源不可靠</p>
<p>石英钟不够精确：它会<strong>漂移（drifts）</strong>（运行速度快于或慢于预期）。且NTP同步也会由于各种因素而不稳定</p>
<p>当然，如果你足够在乎这件事并投入大量资源，可以达到非常好的时钟精度</p>
<h3 id="依赖同步时钟"><a href="#依赖同步时钟" class="headerlink" title="依赖同步时钟"></a>依赖同步时钟</h3><p>时钟的缺陷：一天可能不会有精确的86,400秒，<strong>时钟</strong>可能会前后跳跃，而一个节点上的时间可能与另一个节点上的时间完全不同。</p>
<p>如果使用需要同步时钟的软件，必须仔细监控所有机器之间的时钟偏移，时钟偏离太远则宣布该节点死亡</p>
<h4 id="有序事件的时间戳"><a href="#有序事件的时间戳" class="headerlink" title="有序事件的时间戳"></a>有序事件的时间戳</h4><p>依赖时钟，在多个节点上对事件进行排序，例如LWW策略？不可取，因为时钟不可靠。</p>
<p>how？<strong>逻辑时钟（logic clock）</strong>，基于递增计数器而不是振荡石英晶体，对于排序事件来说是更安全的选择。例如tx_id</p>
<h4 id="时钟读数存在置信区间"><a href="#时钟读数存在置信区间" class="headerlink" title="时钟读数存在置信区间"></a>时钟读数存在置信区间</h4><p>将时钟读数视为一个时间点是没有意义的——它更像是一段时间范围: </p>
<blockquote>
<p> 例如，一个系统可能以95％的置信度认为当前时间处于本分钟内的第10.3秒和10.5秒之间，它可能没法比这更精确了</p>
</blockquote>
<h4 id="全局快照的同步时钟"><a href="#全局快照的同步时钟" class="headerlink" title="全局快照的同步时钟"></a>全局快照的同步时钟</h4><p>分布式系统，由于需要协调，（跨所有分区）全局单调递增的事务ID会很难生成。</p>
<p>可行： 为了确保事务时间戳反映因果关系，在提交读写事务之前，Spanner在提交读写事务时，会故意等待置信区间长度的时间</p>
<h3 id="进程暂停"><a href="#进程暂停" class="headerlink" title="进程暂停"></a>进程暂停</h3><p><strong>租约（lease）</strong>：类似一个带超时的锁，当一个节点获得一个租约时，它知道它在某段时间内自己是领导者，直到租约到期。</p>
<p> 如果节点发生故障，就会停止续期，所以当租约过期时，另一个节点可以接管。类似如下代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">while(true)&#123;</span><br><span class="line">	request=getIncomingRequest();</span><br><span class="line">	// 确保租约还剩下至少10秒</span><br><span class="line">	if (lease.expiryTimeMillis-System.currentTimeMillis()&lt; 10000)&#123;</span><br><span class="line">		lease = lease.renew();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if(lease.isValid())&#123; // 期间可能会发生进程暂停</span><br><span class="line">    	process(request);</span><br><span class="line">	&#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个线程可能会暂停很长时间？当然了，例如GC，虚拟机挂起，磁盘IO阻塞等等</p>
<p>分布式系统没有共享内存，只有通过不可靠网络发送的消息，因此：</p>
<blockquote>
<p> 分布式系统中的节点，必须假定其执行可能在任意时刻暂停相当长的时间，即使是在一个函数的中间。在暂停期间，其它部分在继续运转，甚至可能因为该节点没有响应，而宣告暂停节点的死亡。最终暂停的节点可能会继续运行，在再次检查自己的时钟之前，甚至可能不会意识到自己进入了睡眠。</p>
</blockquote>
<h4 id="响应时间保证"><a href="#响应时间保证" class="headerlink" title="响应时间保证"></a>响应时间保证</h4><p><strong>硬实时（hard real-time）</strong>可行，例如飞机系统中。但是实现昂贵，例如在系统中提供<strong>实时保证</strong>需要各级软件栈的支持，且会降低延迟、吞吐等</p>
<h4 id="限制垃圾收集的影响"><a href="#限制垃圾收集的影响" class="headerlink" title="限制垃圾收集的影响"></a>限制垃圾收集的影响</h4><p>只用垃圾收集器来处理短命对象（这些对象要快速收集），并定期在积累大量长寿对象（因此需要完整GC）之前重新启动进程</p>
<h2 id="知识、真相与谎言"><a href="#知识、真相与谎言" class="headerlink" title="知识、真相与谎言"></a>知识、真相与谎言</h2><h3 id="真理由多数所定义"><a href="#真理由多数所定义" class="headerlink" title="真理由多数所定义"></a>真理由多数所定义</h3><p>节点自身并没问题，但是由于网络、GC等会被误判死亡。</p>
<p>因此，分布式系统不能完全依赖单个节点。决策需要来自多个节点的最小投票数，以减少对于某个特定节点的依赖。</p>
<h4 id="leader-and-lock"><a href="#leader-and-lock" class="headerlink" title="leader and lock"></a>leader and lock</h4><p><img src="https://github.com/Vonng/ddia/raw/master/img/fig8-4.png" alt="img"></p>
<p><strong>图8-4 分布式锁的实现不正确：客户端1认为它仍然具有有效的租约，即使它已经过期，从而破坏了存储中的文件</strong></p>
<p>即使一个节点认为它是“<strong>天选者（the choosen one）</strong>”（分区的负责人，锁的持有者，成功获取用户名的用户的请求处理程序），但这并不一定意味着有法定人数的节点同意</p>
<h4 id="防护令牌"><a href="#防护令牌" class="headerlink" title="防护令牌"></a>防护令牌</h4><p>资源方需要确保一个被误认为自己是“天选者”的节点不能扰乱系统的其它部分，使用<strong>防护（fencing）</strong></p>
<p><img src="https://github.com/Vonng/ddia/raw/master/img/fig8-5.png" alt="img"></p>
<p>假设每次锁定服务器授予锁或租约时，它还会返回一个<strong>防护令牌（fencing token）</strong>，这个数字在每次授予锁定时都会增加</p>
<h3 id="拜占庭故障"><a href="#拜占庭故障" class="headerlink" title="拜占庭故障"></a>拜占庭故障</h3><p>如果节点可能声称其实际上没有收到特定的消息（欺骗行为）。这种行为被称为<strong>拜占庭故障（Byzantine fault）</strong>，<strong>在不信任的环境中达成共识的问题被称为拜占庭将军问题</strong></p>
<p> 当一个系统在部分节点发生故障、不遵守协议、甚至恶意攻击、扰乱网络时仍然能继续正确工作，称之为<strong>拜占庭容错（Byzantine fault-tolerant）</strong>的</p>
<p>例如web 服务的输入验证，数据清洗和输出转义等，即是容错行为。</p>
<h3 id="系统模型与现实"><a href="#系统模型与现实" class="headerlink" title="系统模型与现实"></a>系统模型与现实</h3><p>时机模型。</p>
<ul>
<li><strong><em>同步模型</em></strong>：假设网络延迟，进程暂停和和时钟误差都是有界限的</li>
<li><strong><em>部分同步模型</em></strong>：一个系统在大多数情况下像一个同步系统一样运行，但有时候会超出网络延迟，进程暂停和时钟漂移的界限。<strong>实际</strong></li>
<li><strong><em>异步模型</em></strong>：一个算法不允许对时机做任何假设。场景很有限</li>
</ul>
<p>节点故障模型</p>
<ul>
<li><strong><em>崩溃-停止故障</em></strong>：假设一个节点只能以一种方式失效，即通过崩溃。意味着节点可能在任意时刻突然停止响应，此后该节点永远消失</li>
<li><strong><em>崩溃-恢复故障</em></strong>：假设节点可能会在任何时候崩溃，但也许会在未知的时间之后再次开始响应。<strong>实际</strong></li>
<li><strong><em>拜占庭（任意）故障</em></strong>： 节点可以做（绝对意义上的）任何事情，包括试图戏弄和欺骗其他节点</li>
</ul>
<h4 id="算法的正确性"><a href="#算法的正确性" class="headerlink" title="算法的正确性"></a>算法的正确性</h4><p>分布式算法的属性。</p>
<ul>
<li><strong><em>唯一性</em></strong>：  没有两个防护令牌请求返回相同的值。</li>
<li><strong><em>单调序列</em></strong>：if request x returned token tx, and request y returned token ty, and x competed before y began, then tx &lt; ty</li>
<li><strong><em>可用性</em></strong>:  请求防护令牌并且不会崩溃的节点，最终会收到响应。</li>
</ul>
<h4 id="安全性和活性"><a href="#安全性和活性" class="headerlink" title="安全性和活性"></a>安全性和活性</h4><p> 安全性通常被非正式地定义为，<strong>没有坏事发生</strong>，而活性通常就类似：<strong>最终好事发生</strong>。</p>
<ul>
<li>如果安全属性被违反，我们可以指向一个特定的时间点</li>
<li>活性属性反过来：it may not hold the point in time. But always hope that it may be satisfied in the fueture</li>
</ul>
<p>对于分布式算法，在系统模型的所有可能情况下，要求<strong>始终</strong>保持安全属性是常见的。即使所有节点崩溃，或者整个网络出现故障，算法必须确保它不会返回错误的结果。</p>
<p> 但是，对于活性属性，我们可以提出一些注意事项。例如部分同步模型的定义要求系统最终返回到同步状态——即任何网络中断的时间段只会持续一段有限的时间，然后进行修复。</p>
<h1 id="第九章-一致性和共识"><a href="#第九章-一致性和共识" class="headerlink" title="第九章-一致性和共识"></a>第九章-一致性和共识</h1><p>分布式系统有诸多可能错误，最简单的方法是让服务整体失败，并抛出错误。</p>
<p>然而，我们往往需要的是<em>可容错的分布式系统</em>，即使部分故障了，系统功能也是可用的。</p>
<p>因此， 构建容错系统的最好方法，就是找到带有实用保证的通用抽象，实现之，并让应用依赖这些保证。</p>
<h2 id="一致性的保证"><a href="#一致性的保证" class="headerlink" title="一致性的保证"></a>一致性的保证</h2><p>大多数带副本数据库，都提供了至少<strong>最终一致性</strong>的保证，又称<strong>收敛（convergence）</strong>，我们预计所有的副本最终会收敛到相同的值。</p>
<p>特点：非常弱的保证，并没有说什么时候副本会收敛。</p>
<p>与弱保证的数据库打交道时，你需要始终意识到它的局限性，而不是意外地作出太多假设。</p>
<p>数据库也会提供更强一致性模型的保证，当然这意味着容错和性能损失</p>
<h3 id="线性一致性"><a href="#线性一致性" class="headerlink" title="线性一致性"></a>线性一致性</h3><p><strong>线性一致性</strong>（linearizability），基本的想法是让一个系统看起来好像只有一个数据副本，而且所有的操作都是原子性的。</p>
<p>系统能保障读到的值是最近的，最新的。因此，线性一致性是一种<strong>新鲜度保证（recency guarantee）</strong></p>
<p>这是一种怎样的保证？</p>
<p><img src="https://github.com/Vonng/ddia/raw/master/img/fig9-3.png" alt="img"></p>
<p><strong>图9-3 任何一个读取返回新值后，所有后续读取（在相同或其他客户端上）也必须返回新值。</strong></p>
<p>下图，丨代表操作生效点</p>
<p><img src="https://github.com/Vonng/ddia/raw/master/img/fig9-4.png" alt="img"></p>
<p><strong>图9-4 可视化读取和写入看起来已经生效的时间点。 B的最后读取不是线性一致性的</strong></p>
<blockquote>
<p><strong>操作标记的连线总是按时间（从左到右）向前移动，而不是向后移动</strong></p>
</blockquote>
<h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><h4 id="lock-and-leader-election"><a href="#lock-and-leader-election" class="headerlink" title="lock and leader election"></a>lock and leader election</h4><p>单主系统通常是用锁来保证单一leader，而这个锁则必须是线性一致的。诸如Apache ZooKeeper和etcd之类的协调服务通常用于实现分布式锁和领导者选举。</p>
<p> 分布式锁也在一些分布式数据库中更多的粒度级别上使用</p>
<h4 id="约束与唯一性保证"><a href="#约束与唯一性保证" class="headerlink" title="约束与唯一性保证"></a>约束与唯一性保证</h4><p>例如，用户名或电子邮件地址必须唯一标识一个用户的场景</p>
<h4 id="跨信道的时序依赖"><a href="#跨信道的时序依赖" class="headerlink" title="跨信道的时序依赖"></a>跨信道的时序依赖</h4><p>由于系统中存在额外的信道，线性一致性的违背才被注意到。</p>
<p><img src="https://github.com/Vonng/ddia/raw/master/img/fig9-5.png" alt="img"></p>
<blockquote>
<p> <strong>如果它不是线性一致的，则存在竞争条件的风险：消息队列(图中的步骤3和4）可能比存储服务内部的复制更快</strong>。因为Web服务器和缩放器之间存在两个不同的信道</p>
</blockquote>
<h3 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h3><p>最简单就是真的只有一份数据，然而这显然不具备容错性。</p>
<p>系统容错通常都是用复制来解决。</p>
<ul>
<li><strong><em>单主复制（可能线性一致）</em></strong></li>
<li><strong><em>共识算法（线性一致）</em></strong>，与单主复制类似。然而，共识协议包含防止脑裂和陈旧副本的措施</li>
<li><strong><em>多主复制（非线性一致）</em></strong></li>
<li><strong><em>无主复制（也许不是线性一致的）</em></strong></li>
</ul>
<h3 id="代价"><a href="#代价" class="headerlink" title="代价"></a>代价</h3><p>由于必须是单主复制，因此多数据中心下，数据中心间网络中断会造成不可用。</p>
<ol>
<li><p>CAP理论。最初是作为一个经验法则提出，是一种权衡，鼓励数据库工程师向分布式无共享系统的设计领域深入探索。(实际参考价值不高)</p>
<blockquote>
<p>CAP有时以这种面目出现：一致性，可用性和分区容错性：三者只能择其二。不幸的是这种说法很有误导性【32】，因为网络分区是一种错误，所以它并不是一个选项：不管你喜不喜欢它都会发生</p>
</blockquote>
</li>
<li><p>通常，会<strong>为了提高性能</strong>而选择了牺牲线性一致性，而不是为了容错</p>
</li>
</ol>
<h2 id="顺序的保证"><a href="#顺序的保证" class="headerlink" title="顺序的保证"></a>顺序的保证</h2><p>顺序，操作是按照某种良好定义的顺序执行的，它反复地出现，是一个重要的基础性概念。</p>
<h3 id="顺序与因果"><a href="#顺序与因果" class="headerlink" title="顺序与因果"></a>顺序与因果</h3><p><strong>顺序</strong>反复出现有几个原因，其中一个原因是，它有助于保持<strong>因果关系</strong>。</p>
<p>因果关系对事件施加了一种<strong>顺序</strong>：因在果之前；消息发送在消息收取之前；问题发生在回答前等。</p>
<p>如果一个系统服从因果关系所规定的顺序，我们说它是<strong>因果一致（causally consistent）</strong></p>
<h4 id="因果顺序不是全序"><a href="#因果顺序不是全序" class="headerlink" title="因果顺序不是全序"></a>因果顺序不是全序</h4><p><strong>全序（total order）</strong>允许任意两个元素进行比较，所以如果有两个元素，你总是可以说出哪个更大，哪个更小。比如自然数。</p>
<p>而数学集合是<strong>偏序</strong>(partially ordered)</p>
<p>全序、偏序体现在一致性模型上：</p>
<ul>
<li>线性一致性：全序的</li>
<li>因果一致性：偏序的</li>
</ul>
<p>在线性一致的数据存储中是不存在并发操作的：必须有且仅有一条时间线，所有的操作都在这条时间线上，构成一个全序关系。</p>
<p> 并发意味着时间线会分岔然后合并 —— 在这种情况下，不同分支上的操作是无法比较的</p>
<h4 id="线性一致性强于因果一致性"><a href="#线性一致性强于因果一致性" class="headerlink" title="线性一致性强于因果一致性"></a>线性一致性强于因果一致性</h4><p>线性一致性隐含着因果关系：任何线性一致的系统都能正确保持因果性</p>
<h4 id="捕获因果关系"><a href="#捕获因果关系" class="headerlink" title="捕获因果关系"></a>捕获因果关系</h4><p>为了维持因果性，需要知道哪个操作发生在哪个其他操作之前（<strong>happened before</strong>）。</p>
<p> 为了确定<em>哪些操作发生在其他操作之前</em> ，因果一致性需要跟踪整个数据库中的因果依赖，而不仅仅是一个键</p>
<h3 id="序列号顺序"><a href="#序列号顺序" class="headerlink" title="序列号顺序"></a>序列号顺序</h3><p>使用<strong>序列号（sequence nunber）</strong>或<strong>时间戳（timestamp）</strong>来排序事件，时间戳用逻辑时钟。</p>
<p>因此，提供了全序关系：也就是说每操作都有一个唯一的序列号，而且总是可以比较两个序列号，确定哪一个更大</p>
<p>单主复制的数据库中，复制log使得写操作具备了因果一致性。</p>
<h4 id="非因果序列号生成器"><a href="#非因果序列号生成器" class="headerlink" title="非因果序列号生成器"></a>非因果序列号生成器</h4><p>如果主库不存在？一些方法</p>
<ul>
<li>每个节点都可以生成自己独立的一组序列号</li>
<li>可以将时钟（物理时钟）时间戳附加到每个操作上</li>
<li>预先分配序列号区块。例如1-1000， 1001-2000</li>
</ul>
<p>然而，这将无法满足因果一致。因为这些序列号生成不能正确地捕获跨节点的操作顺序，所以会出现因果关系的问题</p>
<h4 id="兰伯特时间戳-Lamport-timestamps"><a href="#兰伯特时间戳-Lamport-timestamps" class="headerlink" title="兰伯特时间戳(Lamport timestamps)"></a>兰伯特时间戳(Lamport timestamps)</h4><p>尽管上述的三个序列号生成器与因果不一致，但实际上有一个简单的方法来产生与因果关系一致的序列号，即兰伯特时间戳。</p>
<p>它由<em>(counter, node ID)</em>表示。</p>
<p><img src="https://github.com/Vonng/ddia/raw/master/img/fig9-8.png" alt="img"></p>
<p>提供<em>全序</em>：如果你有两个时间戳，则<strong>计数器</strong>值大者是更大的时间戳。如果计数器值相同，则节点ID越大的，时间戳越大。当一个节点收到最大计数器值大于自身计数器值的请求或响应时，它立即将自己的计数器设置为这个最大值。</p>
<h4 id="光有时间戳排序还不够"><a href="#光有时间戳排序还不够" class="headerlink" title="光有时间戳排序还不够"></a>光有时间戳排序还不够</h4><p>为何？</p>
<ul>
<li>因为它基于一种事实，即一旦你收集了系统中的所有用户名创建操作，你才能比较它们的时间戳</li>
<li>你只有在所有的操作都被收集之后，操作的全序才能显现</li>
<li>为了实诸如如用户名上的唯一约束这种东西，仅有操作的全序是不够的，你还需要知道这个全序何时会尘埃落定。</li>
</ul>
<h3 id="全序广播"><a href="#全序广播" class="headerlink" title="全序广播"></a>全序广播</h3><p>如果吞吐量超出单个主库的处理能力，这种情况下如何扩展系统；以及，如果主库失效，如何处理故障切换。问题被称为<strong>全序广播</strong>(total order broadcast)</p>
<p>全序广播通常被描述为在节点间交换消息的协议。 非正式地讲，它要满足两个安全属性：</p>
<ul>
<li><strong><em>可靠交付（reliable delivery）</em></strong>， 没有消息丢失：如果消息被传递到一个节点，它将被传递到所有节点。</li>
<li><strong><em>全序交付（totally ordered delivery）</em></strong>： 消息以相同的顺序传递给每个节点。</li>
</ul>
<p>正确的全序广播算法必须始终保证可靠性和有序性，即使节点或网络出现故障。</p>
<h4 id="使用全序广播"><a href="#使用全序广播" class="headerlink" title="使用全序广播"></a>使用全序广播</h4><p>广泛应用。如，数据库复制、实现可序列化的事务、顺序是在消息送达时被固化、实现提供防护令牌的锁服务。</p>
<h4 id="全序广播-VS-线性一致"><a href="#全序广播-VS-线性一致" class="headerlink" title="全序广播 VS 线性一致"></a>全序广播 VS 线性一致</h4><ul>
<li>可以使用全序广播实现线性一致的存储</li>
<li>同时，也可以使用线性一致的性存储来实现全序广播</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/08/08/【读书笔记】设计数据密集型应用/" rel="next" title="设计数据密集型应用之数据系统基础">
                <i class="fa fa-chevron-left"></i> 设计数据密集型应用之数据系统基础
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Eren Ming</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/erenming" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:erenming233@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#第五章-复制"><span class="nav-number">1.</span> <span class="nav-text">第五章-复制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Leaders-and-Followers-单Leader"><span class="nav-number">1.1.</span> <span class="nav-text">Leaders and Followers(单Leader)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#同步还是异步复制"><span class="nav-number">1.2.</span> <span class="nav-text">同步还是异步复制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#设置新的Followers"><span class="nav-number">1.3.</span> <span class="nav-text">设置新的Followers</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#处理节点宕机"><span class="nav-number">1.4.</span> <span class="nav-text">处理节点宕机</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Follower-failure：Catch-up-recovery"><span class="nav-number">1.4.1.</span> <span class="nav-text">Follower failure：Catch-up recovery</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Leader-failure-Failure-故障切换"><span class="nav-number">1.4.2.</span> <span class="nav-text">Leader failure: Failure(故障切换)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Implementation-of-Replication-Logs"><span class="nav-number">1.5.</span> <span class="nav-text">Implementation of Replication Logs</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#statement-based-replication"><span class="nav-number">1.5.1.</span> <span class="nav-text">statement-based replication</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Write-ahead-log-WAL-传输"><span class="nav-number">1.5.2.</span> <span class="nav-text">Write-ahead log(WAL) 传输</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Logical-row-based-log-replication"><span class="nav-number">1.5.3.</span> <span class="nav-text">Logical(row-based)log replication</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Trigger-based-replication"><span class="nav-number">1.5.4.</span> <span class="nav-text">Trigger-based replication</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Porblems-with-Replication-Lag"><span class="nav-number">1.6.</span> <span class="nav-text">Porblems with Replication Lag</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Reading-Your-Owen-Writes"><span class="nav-number">1.6.1.</span> <span class="nav-text">Reading Your Owen Writes</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#单调读"><span class="nav-number">1.6.2.</span> <span class="nav-text">单调读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Consistent-Prefix-Reads"><span class="nav-number">1.6.3.</span> <span class="nav-text">Consistent Prefix Reads</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution-for-Replication-Lag"><span class="nav-number">1.7.</span> <span class="nav-text">Solution for Replication Lag</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Multi-Leader-Replication-多主复制"><span class="nav-number">1.8.</span> <span class="nav-text">Multi-Leader Replication(多主复制)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#应用场景"><span class="nav-number">1.8.1.</span> <span class="nav-text">应用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#处理写冲突"><span class="nav-number">1.8.2.</span> <span class="nav-text">处理写冲突</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#避免写冲突"><span class="nav-number">1.8.2.1.</span> <span class="nav-text">避免写冲突</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#收敛到一致的状态"><span class="nav-number">1.8.2.2.</span> <span class="nav-text">收敛到一致的状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#自定义冲突解决"><span class="nav-number">1.8.2.3.</span> <span class="nav-text">自定义冲突解决</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#拓扑结构"><span class="nav-number">1.8.3.</span> <span class="nav-text">拓扑结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Leaderless-Replication-无主复制"><span class="nav-number">1.9.</span> <span class="nav-text">Leaderless Replication(无主复制)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#单节点故障时写入"><span class="nav-number">1.9.0.1.</span> <span class="nav-text">单节点故障时写入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Read-pair-and-anti-entropy"><span class="nav-number">1.9.0.2.</span> <span class="nav-text">Read pair and anti-entropy</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Read-repair"><span class="nav-number">1.9.0.2.1.</span> <span class="nav-text">Read repair</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Anti-entropy-process"><span class="nav-number">1.9.0.2.2.</span> <span class="nav-text">Anti-entropy process</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Quorums-法定人数-for-reading-and-writing"><span class="nav-number">1.9.1.</span> <span class="nav-text">Quorums(法定人数) for reading and writing</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Quorums的局限性"><span class="nav-number">1.9.2.</span> <span class="nav-text">Quorums的局限性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#监控staleness-陈旧度"><span class="nav-number">1.9.2.1.</span> <span class="nav-text">监控staleness(陈旧度)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Sloppy-Quorums-and-Hinted-Handoff"><span class="nav-number">1.9.3.</span> <span class="nav-text">Sloppy Quorums and Hinted Handoff</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多数据中心"><span class="nav-number">1.9.4.</span> <span class="nav-text">多数据中心</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#检测并发写"><span class="nav-number">1.9.5.</span> <span class="nav-text">检测并发写</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Last-wirte-wins-discharding-current-wirtes"><span class="nav-number">1.9.5.1.</span> <span class="nav-text">Last wirte wins(discharding current wirtes)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#The-“happens-before”-relationship-and-concurrency"><span class="nav-number">1.9.5.2.</span> <span class="nav-text">The “happens-before” relationship and concurrency</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#捕获”happens-before”关系"><span class="nav-number">1.9.5.3.</span> <span class="nav-text">捕获”happens-before”关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#合并同时写入的值"><span class="nav-number">1.9.5.4.</span> <span class="nav-text">合并同时写入的值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#版本向量"><span class="nav-number">1.9.5.5.</span> <span class="nav-text">版本向量</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">1.10.</span> <span class="nav-text">总结</span></a></li></ol><li class="nav-item nav-level-1"><a class="nav-link" href="#第六章-分区"><span class="nav-number">2.</span> <span class="nav-text">第六章-分区</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#分区与复制"><span class="nav-number">2.0.1.</span> <span class="nav-text">分区与复制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Key-Value-类数据的分区"><span class="nav-number">2.0.2.</span> <span class="nav-text">Key-Value 类数据的分区</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#通过Key-Range分区"><span class="nav-number">2.0.2.1.</span> <span class="nav-text">通过Key Range分区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#通过Hash-of-Key-分区"><span class="nav-number">2.0.2.2.</span> <span class="nav-text">通过Hash of Key 分区</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#负载倾斜与消除热点"><span class="nav-number">2.0.3.</span> <span class="nav-text">负载倾斜与消除热点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分区以及二级索引"><span class="nav-number">2.0.4.</span> <span class="nav-text">分区以及二级索引</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基于文档分区二级索引"><span class="nav-number">2.0.4.1.</span> <span class="nav-text">基于文档分区二级索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#基于关键词-Term-分区二级索引"><span class="nav-number">2.0.4.2.</span> <span class="nav-text">基于关键词(Term)分区二级索引</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分区再平衡"><span class="nav-number">2.0.5.</span> <span class="nav-text">分区再平衡</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#平衡策略"><span class="nav-number">2.0.6.</span> <span class="nav-text">平衡策略</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#反面教材：hash-mod-N"><span class="nav-number">2.0.6.1.</span> <span class="nav-text">反面教材：hash mod N</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#固定数量的分区"><span class="nav-number">2.0.6.2.</span> <span class="nav-text">固定数量的分区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#动态分区"><span class="nav-number">2.0.6.3.</span> <span class="nav-text">动态分区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#按节点比例分区"><span class="nav-number">2.0.6.4.</span> <span class="nav-text">按节点比例分区</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#运维：手动还是自动平衡"><span class="nav-number">2.0.7.</span> <span class="nav-text">运维：手动还是自动平衡</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#请求路由"><span class="nav-number">2.1.</span> <span class="nav-text">请求路由</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#执行并行查询"><span class="nav-number">2.1.1.</span> <span class="nav-text">执行并行查询</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第七章-事务"><span class="nav-number">3.</span> <span class="nav-text">第七章-事务</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ACID的含义"><span class="nav-number">3.1.</span> <span class="nav-text">ACID的含义</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#原子性"><span class="nav-number">3.1.1.</span> <span class="nav-text">原子性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一致性"><span class="nav-number">3.1.2.</span> <span class="nav-text">一致性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#隔离性"><span class="nav-number">3.1.3.</span> <span class="nav-text">隔离性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#持久性"><span class="nav-number">3.1.4.</span> <span class="nav-text">持久性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#单对象和多对象操作"><span class="nav-number">3.2.</span> <span class="nav-text">单对象和多对象操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#单对象写入"><span class="nav-number">3.2.1.</span> <span class="nav-text">单对象写入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多对象事务的需求"><span class="nav-number">3.2.2.</span> <span class="nav-text">多对象事务的需求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#处理错误和中止"><span class="nav-number">3.2.3.</span> <span class="nav-text">处理错误和中止</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#弱隔离级别"><span class="nav-number">3.3.</span> <span class="nav-text">弱隔离级别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#读已提交-Read-Commited"><span class="nav-number">3.3.1.</span> <span class="nav-text">读已提交(Read Commited)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#No-dirty-reads"><span class="nav-number">3.3.1.1.</span> <span class="nav-text">No dirty reads</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#No-dirty-writes"><span class="nav-number">3.3.1.2.</span> <span class="nav-text">No dirty writes</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实现"><span class="nav-number">3.3.1.3.</span> <span class="nav-text">实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#快照隔离和可重复读"><span class="nav-number">3.3.2.</span> <span class="nav-text">快照隔离和可重复读</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#实现-1"><span class="nav-number">3.3.2.1.</span> <span class="nav-text">实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#一致性快照的可见性规则"><span class="nav-number">3.3.2.2.</span> <span class="nav-text">一致性快照的可见性规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#索引和快照隔离"><span class="nav-number">3.3.2.3.</span> <span class="nav-text">索引和快照隔离</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#可重复读与命名混淆"><span class="nav-number">3.3.2.4.</span> <span class="nav-text">可重复读与命名混淆</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#防止丢失更新"><span class="nav-number">3.3.3.</span> <span class="nav-text">防止丢失更新</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#原子写"><span class="nav-number">3.3.3.1.</span> <span class="nav-text">原子写</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#显式锁定"><span class="nav-number">3.3.3.2.</span> <span class="nav-text">显式锁定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#自动检测丢失的更新"><span class="nav-number">3.3.3.3.</span> <span class="nav-text">自动检测丢失的更新</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#比较并设置（CAS）"><span class="nav-number">3.3.3.4.</span> <span class="nav-text">比较并设置（CAS）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#冲突解决和复制"><span class="nav-number">3.3.3.5.</span> <span class="nav-text">冲突解决和复制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#写入偏差与幻读"><span class="nav-number">3.3.4.</span> <span class="nav-text">写入偏差与幻读</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#写偏差-write-skew"><span class="nav-number">3.3.4.1.</span> <span class="nav-text">写偏差(write skew)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#导致写入偏差的幻读"><span class="nav-number">3.3.4.2.</span> <span class="nav-text">导致写入偏差的幻读</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#物化冲突"><span class="nav-number">3.3.4.3.</span> <span class="nav-text">物化冲突</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Serializability-可序列化"><span class="nav-number">3.4.</span> <span class="nav-text">Serializability(可序列化)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#真-串行执行"><span class="nav-number">3.4.1.</span> <span class="nav-text">真*串行执行</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#在存储过程中封装事务"><span class="nav-number">3.4.1.1.</span> <span class="nav-text">在存储过程中封装事务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#串行执行小结"><span class="nav-number">3.4.1.2.</span> <span class="nav-text">串行执行小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#两阶段锁定（2PL）"><span class="nav-number">3.4.2.</span> <span class="nav-text">两阶段锁定（2PL）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#实现-2"><span class="nav-number">3.4.2.1.</span> <span class="nav-text">实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#性能"><span class="nav-number">3.4.2.2.</span> <span class="nav-text">性能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#谓词锁"><span class="nav-number">3.4.2.3.</span> <span class="nav-text">谓词锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#索引范围锁"><span class="nav-number">3.4.2.4.</span> <span class="nav-text">索引范围锁</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#序列化快照隔离（SSI）"><span class="nav-number">3.4.3.</span> <span class="nav-text">序列化快照隔离（SSI）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#悲观与乐观的并发控制"><span class="nav-number">3.4.3.1.</span> <span class="nav-text">悲观与乐观的并发控制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#基于过时前提的决策"><span class="nav-number">3.4.3.2.</span> <span class="nav-text">基于过时前提的决策</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#检测旧MVCC读取"><span class="nav-number">3.4.3.3.</span> <span class="nav-text">检测旧MVCC读取</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#检测影响之前读取的写入"><span class="nav-number">3.4.3.4.</span> <span class="nav-text">检测影响之前读取的写入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#可序列化的快照隔离的性能"><span class="nav-number">3.4.3.5.</span> <span class="nav-text">可序列化的快照隔离的性能</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结-1"><span class="nav-number">3.5.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第八章-分布式系统的麻烦"><span class="nav-number">4.</span> <span class="nav-text">第八章-分布式系统的麻烦</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#故障与部分失效"><span class="nav-number">4.1.</span> <span class="nav-text">故障与部分失效</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#云计算与超级计算机"><span class="nav-number">4.2.</span> <span class="nav-text">云计算与超级计算机</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#不可靠的网络"><span class="nav-number">4.3.</span> <span class="nav-text">不可靠的网络</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#实际的网络错误"><span class="nav-number">4.3.1.</span> <span class="nav-text">实际的网络错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#检测故障"><span class="nav-number">4.3.2.</span> <span class="nav-text">检测故障</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#超时与无穷的延迟"><span class="nav-number">4.3.3.</span> <span class="nav-text">超时与无穷的延迟</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#网络拥塞和排队"><span class="nav-number">4.3.3.1.</span> <span class="nav-text">网络拥塞和排队</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#同步网络-vs-异步网络"><span class="nav-number">4.3.4.</span> <span class="nav-text">同步网络 vs 异步网络</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#不可靠的时钟"><span class="nav-number">4.4.</span> <span class="nav-text">不可靠的时钟</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#单调钟与时钟"><span class="nav-number">4.4.1.</span> <span class="nav-text">单调钟与时钟</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#时钟："><span class="nav-number">4.4.1.1.</span> <span class="nav-text">时钟：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#单调钟："><span class="nav-number">4.4.1.2.</span> <span class="nav-text">单调钟：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#时钟同步与准确性"><span class="nav-number">4.4.2.</span> <span class="nav-text">时钟同步与准确性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#依赖同步时钟"><span class="nav-number">4.4.3.</span> <span class="nav-text">依赖同步时钟</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#有序事件的时间戳"><span class="nav-number">4.4.3.1.</span> <span class="nav-text">有序事件的时间戳</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#时钟读数存在置信区间"><span class="nav-number">4.4.3.2.</span> <span class="nav-text">时钟读数存在置信区间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#全局快照的同步时钟"><span class="nav-number">4.4.3.3.</span> <span class="nav-text">全局快照的同步时钟</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程暂停"><span class="nav-number">4.4.4.</span> <span class="nav-text">进程暂停</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#响应时间保证"><span class="nav-number">4.4.4.1.</span> <span class="nav-text">响应时间保证</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#限制垃圾收集的影响"><span class="nav-number">4.4.4.2.</span> <span class="nav-text">限制垃圾收集的影响</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#知识、真相与谎言"><span class="nav-number">4.5.</span> <span class="nav-text">知识、真相与谎言</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#真理由多数所定义"><span class="nav-number">4.5.1.</span> <span class="nav-text">真理由多数所定义</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#leader-and-lock"><span class="nav-number">4.5.1.1.</span> <span class="nav-text">leader and lock</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#防护令牌"><span class="nav-number">4.5.1.2.</span> <span class="nav-text">防护令牌</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#拜占庭故障"><span class="nav-number">4.5.2.</span> <span class="nav-text">拜占庭故障</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#系统模型与现实"><span class="nav-number">4.5.3.</span> <span class="nav-text">系统模型与现实</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#算法的正确性"><span class="nav-number">4.5.3.1.</span> <span class="nav-text">算法的正确性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#安全性和活性"><span class="nav-number">4.5.3.2.</span> <span class="nav-text">安全性和活性</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第九章-一致性和共识"><span class="nav-number">5.</span> <span class="nav-text">第九章-一致性和共识</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#一致性的保证"><span class="nav-number">5.1.</span> <span class="nav-text">一致性的保证</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#线性一致性"><span class="nav-number">5.1.1.</span> <span class="nav-text">线性一致性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#应用场景-1"><span class="nav-number">5.1.2.</span> <span class="nav-text">应用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#lock-and-leader-election"><span class="nav-number">5.1.2.1.</span> <span class="nav-text">lock and leader election</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#约束与唯一性保证"><span class="nav-number">5.1.2.2.</span> <span class="nav-text">约束与唯一性保证</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#跨信道的时序依赖"><span class="nav-number">5.1.2.3.</span> <span class="nav-text">跨信道的时序依赖</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何实现"><span class="nav-number">5.1.3.</span> <span class="nav-text">如何实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代价"><span class="nav-number">5.1.4.</span> <span class="nav-text">代价</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#顺序的保证"><span class="nav-number">5.2.</span> <span class="nav-text">顺序的保证</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#顺序与因果"><span class="nav-number">5.2.1.</span> <span class="nav-text">顺序与因果</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#因果顺序不是全序"><span class="nav-number">5.2.1.1.</span> <span class="nav-text">因果顺序不是全序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线性一致性强于因果一致性"><span class="nav-number">5.2.1.2.</span> <span class="nav-text">线性一致性强于因果一致性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#捕获因果关系"><span class="nav-number">5.2.1.3.</span> <span class="nav-text">捕获因果关系</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#序列号顺序"><span class="nav-number">5.2.2.</span> <span class="nav-text">序列号顺序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#非因果序列号生成器"><span class="nav-number">5.2.2.1.</span> <span class="nav-text">非因果序列号生成器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#兰伯特时间戳-Lamport-timestamps"><span class="nav-number">5.2.2.2.</span> <span class="nav-text">兰伯特时间戳(Lamport timestamps)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#光有时间戳排序还不够"><span class="nav-number">5.2.2.3.</span> <span class="nav-text">光有时间戳排序还不够</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#全序广播"><span class="nav-number">5.2.3.</span> <span class="nav-text">全序广播</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#使用全序广播"><span class="nav-number">5.2.3.1.</span> <span class="nav-text">使用全序广播</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#全序广播-VS-线性一致"><span class="nav-number">5.2.3.2.</span> <span class="nav-text">全序广播 VS 线性一致</span></a></li></ol></li></ol></li></ol></li></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  #<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Eren Ming</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://erenming.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'https://erenming.com/2020/09/05/【读书笔记】设计数据密集型应用-第二部分/';
          this.page.identifier = '2020/09/05/【读书笔记】设计数据密集型应用-第二部分/';
          this.page.title = '【读书笔记】设计数据密集型应用-第二部分';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://erenming.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  














  





  

  

  

  
  

  

  

  

</body>
</html>
