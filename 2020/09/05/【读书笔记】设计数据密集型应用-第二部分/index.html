<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="分布式数据，replication and partition  Replication: keeping a copy of the same data on sevral differrent nodes, or in different locations Partition: splittion a big databse into smaller subsets called parti">
<meta property="og:type" content="article">
<meta property="og:title" content="【读书笔记】设计数据密集型应用-第二部分">
<meta property="og:url" content="https://erenming.com/2020/09/05/【读书笔记】设计数据密集型应用-第二部分/index.html">
<meta property="og:site_name" content="Eren with you">
<meta property="og:description" content="分布式数据，replication and partition  Replication: keeping a copy of the same data on sevral differrent nodes, or in different locations Partition: splittion a big databse into smaller subsets called parti">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://github.com/Vonng/ddia/raw/master/img/fig5-3.png">
<meta property="og:image" content="https://github.com/Vonng/ddia/raw/master/img/fig5-4.png">
<meta property="og:image" content="https://github.com/Vonng/ddia/raw/master/img/fig5-5.png">
<meta property="og:image" content="https://github.com/Vonng/ddia/raw/master/img/fig5-8.png">
<meta property="og:image" content="https://github.com/Vonng/ddia/raw/master/img/fig5-12.png">
<meta property="og:image" content="https://github.com/Vonng/ddia/raw/master/img/fig5-13.png">
<meta property="og:image" content="https://github.com/Vonng/ddia/raw/master/img/fig6-2.png">
<meta property="og:image" content="https://github.com/Vonng/ddia/raw/master/img/fig6-3.png">
<meta property="og:image" content="https://github.com/Vonng/ddia/raw/master/img/fig6-4.png">
<meta property="og:image" content="https://github.com/Vonng/ddia/raw/master/img/fig6-5.png">
<meta property="og:image" content="https://github.com/Vonng/ddia/raw/master/img/fig6-6.png">
<meta property="og:image" content="https://github.com/Vonng/ddia/raw/master/img/fig6-7.png">
<meta property="og:image" content="https://github.com/Vonng/ddia/raw/master/img/fig7-6.png">
<meta property="og:image" content="https://github.com/Vonng/ddia/raw/master/img/fig7-7.png">
<meta property="og:image" content="https://github.com/Vonng/ddia/raw/master/img/fig7-8.png">
<meta property="og:image" content="https://github.com/Vonng/ddia/raw/master/img/fig7-11.png">
<meta property="og:updated_time" content="2020-10-07T04:10:32.113Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="【读书笔记】设计数据密集型应用-第二部分">
<meta name="twitter:description" content="分布式数据，replication and partition  Replication: keeping a copy of the same data on sevral differrent nodes, or in different locations Partition: splittion a big databse into smaller subsets called parti">
<meta name="twitter:image" content="https://github.com/Vonng/ddia/raw/master/img/fig5-3.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://erenming.com/2020/09/05/【读书笔记】设计数据密集型应用-第二部分/">





  <title>【读书笔记】设计数据密集型应用-第二部分 | Eren with you</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Eren with you</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://erenming.com/2020/09/05/【读书笔记】设计数据密集型应用-第二部分/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Eren Ming">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eren with you">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">【读书笔记】设计数据密集型应用-第二部分</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-09-05T17:24:59+08:00">
                2020-09-05
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/09/05/【读书笔记】设计数据密集型应用-第二部分/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/09/05/【读书笔记】设计数据密集型应用-第二部分/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>分布式数据，replication and partition</p>
<ul>
<li>Replication: keeping a <strong>copy</strong> of the same data on sevral differrent nodes, or in different locations</li>
<li>Partition: <strong>splittion</strong> a big databse into smaller subsets called partitions so that different partitions can be assigned to different nodes(called <em>sharding</em>)</li>
</ul>
<h1 id="第五章-复制"><a href="#第五章-复制" class="headerlink" title="第五章-复制"></a>第五章-复制</h1><p>复制的作用：</p>
<ul>
<li>数据物理上靠近用户</li>
<li>允许部分节点故障而系统正常，提高可靠性</li>
<li>水平扩展机器数可提高吞吐量</li>
</ul>
<h2 id="Leaders-and-Followers-单Leader"><a href="#Leaders-and-Followers-单Leader" class="headerlink" title="Leaders and Followers(单Leader)"></a>Leaders and Followers(单Leader)</h2><p>如何确保所有节点都获得数据？使用<em>leader-based replication</em>方案</p>
<ul>
<li>选择其中一个副本作为主节点，客户端的写请求必须通过leader</li>
<li>其他副本作为从节点，leader收到请求并发送relication log给followers。followers获取到后再写数据</li>
<li>读请求可通过任何节点读取</li>
</ul>
<p>MySQL、PostgreSQL，Kafka等均通过该方案实现</p>
<h2 id="同步还是异步复制"><a href="#同步还是异步复制" class="headerlink" title="同步还是异步复制"></a>同步还是异步复制</h2><p>同步复制：主节点等待从节点写入数据完成</p>
<p>异步复制：主节点不等待从节点写入数据完成，而直接返回</p>
<p>优缺点：</p>
<ul>
<li>同步优点：能确保从节点的数据与主节点保持一致性</li>
<li>同步缺点：主从节点之间由于各种原因，导致写操作阻塞。从而阻塞后续的写请求</li>
</ul>
<p>通常，主节点与一个从节点保持同步，与其他保持异步。而实际中，完全异步的架构也是很普遍的，这可能会导致数据丢失，可通过<em>共识</em>解决</p>
<h2 id="设置新的Followers"><a href="#设置新的Followers" class="headerlink" title="设置新的Followers"></a>设置新的Followers</h2><p>简单地拷贝数据是不可行的，因为数据是在不断变化的。也许能锁磁盘来解决，但是显然会影响性能。</p>
<ol>
<li>主节点创建自身快照</li>
<li>复制快照到从节点</li>
<li>新的从节点请求从快照创建时间点之后的数据并写入</li>
<li>follower处理完back log之后，我们为<em>caught up</em></li>
</ol>
<h2 id="处理节点宕机"><a href="#处理节点宕机" class="headerlink" title="处理节点宕机"></a>处理节点宕机</h2><h3 id="Follower-failure：Catch-up-recovery"><a href="#Follower-failure：Catch-up-recovery" class="headerlink" title="Follower failure：Catch-up recovery"></a>Follower failure：Catch-up recovery</h3><p>根据log，节点知道失败前的最后一个事务的具体时间点，follower恢复后只需向主节点请求改时间点之后的数据即可。</p>
<h3 id="Leader-failure-Failure-故障切换"><a href="#Leader-failure-Failure-故障切换" class="headerlink" title="Leader failure: Failure(故障切换)"></a>Leader failure: Failure(故障切换)</h3><p>自动流程：</p>
<ol>
<li>确认leader失败。很简单，超时-心跳机制</li>
<li><p>选择个一个新leader。通过其他节点或者控制器选举leader，通常来说是拥有数据最新的（减少数据丢失）</p>
</li>
<li><p>使用leader重新配置整个系统。系统需要保证原leader只能变成follower并认同新leader</p>
</li>
</ol>
<p>潜在问题：</p>
<ul>
<li>原leader拥有未同步的数据，重新加入集群后，跟新leader的数据会有冲突。通过丢去未同步的数据处理，持久性未满足</li>
<li>抛弃数据造成灾难，尤其是与其他系统协作时</li>
<li>某些情况下，两个节点认为自身为leader，我们成为<em>split brain</em>(脑裂)</li>
<li>判定leader失败的超时时间多少合适？网络、负载等等原因都会影响心跳时间</li>
</ul>
<h2 id="Implementation-of-Replication-Logs"><a href="#Implementation-of-Replication-Logs" class="headerlink" title="Implementation of Replication Logs"></a>Implementation of Replication Logs</h2><p>介绍Leader-based replication 是如何实现的</p>
<h3 id="statement-based-replication"><a href="#statement-based-replication" class="headerlink" title="statement-based replication"></a>statement-based replication</h3><p>leader记录每条写请求(statement，语句)，并发送给followers。听起来很简单，但是缺点也多</p>
<ul>
<li>任何非确定性的语句都会有问题，例如NOW()函数</li>
<li>语句如果存在顺序关系，例如<code>UPDATE</code>操作，也会存在问题（除非保证顺序）</li>
<li>语句有副作用，例如触发器，存储过程等</li>
</ul>
<h3 id="Write-ahead-log-WAL-传输"><a href="#Write-ahead-log-WAL-传输" class="headerlink" title="Write-ahead log(WAL) 传输"></a>Write-ahead log(WAL) 传输</h3><p>诸如基于log-structure以及B-Tree的数据库，都会有有一个append-only log。</p>
<p>leader将数据的log发送到各个followers，follower再通过它建立一个与leader一样的copy。广泛应用PostgreSQL等</p>
<p>缺点：</p>
<ul>
<li>log记录的数据过于底层，例如包含哪些磁盘中的哪些字节改变。</li>
<li>数据库版本升级时，版本之间并不兼容，需要停机升级</li>
</ul>
<h3 id="Logical-row-based-log-replication"><a href="#Logical-row-based-log-replication" class="headerlink" title="Logical(row-based)log replication"></a>Logical(row-based)log replication</h3><p>替代底层log，而使用逻辑上的log来表示，其通常是一系列的记录来代表写请求。例如插入，log则包含所有列的新值。</p>
<p>由于其与底层存储解耦了，因此易于兼容不同版本，且能被外部系统解析使用。应用于MySQL中的binlog等</p>
<h3 id="Trigger-based-replication"><a href="#Trigger-based-replication" class="headerlink" title="Trigger-based replication"></a>Trigger-based replication</h3><p>上述均为数据库底层实现，若需要更高的灵活性，则可使用trigger-based的方式。它让你注册一些用户代码，在数据变化时自动触发执行</p>
<h2 id="Porblems-with-Replication-Lag"><a href="#Porblems-with-Replication-Lag" class="headerlink" title="Porblems with Replication Lag"></a>Porblems with Replication Lag</h2><p>relication lag：the delay between a write happening on the leader and being reflected on a follower(leader与follower之间的数据延迟)</p>
<p>通常来说，followers的数据经常会落后于leader，这种状态通常很短。但是一旦lag过长，则会出大问题。如何解决？</p>
<h3 id="Reading-Your-Owen-Writes"><a href="#Reading-Your-Owen-Writes" class="headerlink" title="Reading Your Owen Writes"></a>Reading Your Owen Writes</h3><p><img src="https://github.com/Vonng/ddia/raw/master/img/fig5-3.png" alt="img"></p>
<p>用户修改了，再次查询时可能还是老的。</p>
<p>使用<em>read-after-write consistency</em> 、或称为<code>read-your-writes consistency</code>来保证一致性，即保证用户再次查询时能查到其更新的，这对其他用户不保证。</p>
<p>方案：</p>
<ul>
<li>当获取某些刚修改的数据时，只通过leader查询</li>
<li>常见情况下，可对数据标记，例如更新时间，若更新时间小于1分钟，则从leader中读取</li>
<li>客户端记住最近写的时间戳，然后判读读取</li>
</ul>
<h3 id="单调读"><a href="#单调读" class="headerlink" title="单调读"></a>单调读</h3><p><img src="https://github.com/Vonng/ddia/raw/master/img/fig5-4.png" alt="img"></p>
<p>由于同步时间的不确定性，用户可能发现修改了的数据又复原了，出现时光倒流现象。</p>
<p><em>monotonic reads</em>，使用单调读技术来确保这种情况不会发生。</p>
<p>方案：确保每个用户总是从单个副本中读取</p>
<h3 id="Consistent-Prefix-Reads"><a href="#Consistent-Prefix-Reads" class="headerlink" title="Consistent Prefix Reads"></a>Consistent Prefix Reads</h3><p><img src="https://github.com/Vonng/ddia/raw/master/img/fig5-5.png" alt="img"></p>
<p>本来带有顺序含义的语句，由于复制延迟，第三方观测下顺序异常导致的混乱。例如，聊天的对话顺序</p>
<p>使用<em>consistent prefix reads</em>(一致性前缀读)来避免。</p>
<p>方案：</p>
<ul>
<li>保证任何因果关系的写入都写入到同一个partition。</li>
<li>显式跟踪因果依赖关系的算法。例如<em>happens-before</em>技术</li>
</ul>
<h2 id="Solution-for-Replication-Lag"><a href="#Solution-for-Replication-Lag" class="headerlink" title="Solution for Replication Lag"></a>Solution for Replication Lag</h2><p>使用最终一致性以及分布式事务等</p>
<h2 id="Multi-Leader-Replication-多主复制"><a href="#Multi-Leader-Replication-多主复制" class="headerlink" title="Multi-Leader Replication(多主复制)"></a>Multi-Leader Replication(多主复制)</h2><p>单Leader缺点：所有写入必须经过它。</p>
<p>多Leader缺点：同一数据可能会在不同数据中心被同时处理，需要解决因此带来的<strong>冲突</strong>。</p>
<p>多leader下，每个leader都担任其他leader的follower</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li>性能：多数据中心下，写请求被本地数据中心处理，随后与其他数据中心异步复制</li>
<li>可用性：能有效容忍某个数据中心挂掉</li>
<li><p>网络性能：数据中心间的网络往往很拥堵且不稳定，单leader无法应对，而多leader至少本地能处理用户请求</p>
</li>
<li><p>客户端离线操作：客户端(例如手机设备等)本机类比作为一个datacenter</p>
</li>
<li>协同编辑：多人协同编辑应用，每个设备都类比作为一个datacenter</li>
</ul>
<h3 id="处理写冲突"><a href="#处理写冲突" class="headerlink" title="处理写冲突"></a>处理写冲突</h3><h4 id="避免写冲突"><a href="#避免写冲突" class="headerlink" title="避免写冲突"></a>避免写冲突</h4><p>同一地区或者同一一批设备的写请求都通过同一leader写入。例如通过hash路由的方式等</p>
<h4 id="收敛到一致的状态"><a href="#收敛到一致的状态" class="headerlink" title="收敛到一致的状态"></a>收敛到一致的状态</h4><p>通过一些方法将不同状态的数据收敛到同一状态。</p>
<p>方案：</p>
<ul>
<li>使用LWW(last write wins)技术，即每次写入都绑定一个唯一ID（UUID，时间戳等），选择最大的ID并丢弃其他</li>
<li>给副本绑定ID，选择ID大的副本里的数据</li>
<li>通过某种方式合并，例如字母顺序最大者</li>
<li>或者用数据结构保留冲突，提示用户自己解决</li>
</ul>
<h4 id="自定义冲突解决"><a href="#自定义冲突解决" class="headerlink" title="自定义冲突解决"></a>自定义冲突解决</h4><p>允许用户编写冲突解决逻辑，并在读、写操作是执行。</p>
<ul>
<li>写时：只要检测到冲突即会执行</li>
<li>读时：检测到冲突，会保存所有冲突。用户读取时，提示用户解决，并回写结果。</li>
</ul>
<h3 id="拓扑结构"><a href="#拓扑结构" class="headerlink" title="拓扑结构"></a>拓扑结构</h3><p><img src="https://github.com/Vonng/ddia/raw/master/img/fig5-8.png" alt="img"></p>
<ul>
<li>环形：节点收到来自前一个节点的写请求并传递给下一个节点</li>
<li>星形：一个指定的节点传递给掐所有节点</li>
<li>All-to-all：<ul>
<li>优点：能避免环形以及星形的单点故障影响其他节点的问题</li>
<li>缺点：节点间网络的速率不同，一些复制消息将超过其他消息</li>
</ul>
</li>
</ul>
<h2 id="Leaderless-Replication-无主复制"><a href="#Leaderless-Replication-无主复制" class="headerlink" title="Leaderless Replication(无主复制)"></a>Leaderless Replication(无主复制)</h2><p>无主复制中，写请求通常是直接发送到所有副本中，或者通过coordinator代表客户端写入。</p>
<h4 id="单节点故障时写入"><a href="#单节点故障时写入" class="headerlink" title="单节点故障时写入"></a>单节点故障时写入</h4><p>无主复制中，故障切换是不存在的。节点故障时，只要剩余节点能承认写入即可。</p>
<p>当原节点恢复，将会存在数据不一致的现象，如何解决？</p>
<blockquote>
<p>客户端接收所有副本的返回数据，并选择最新的。通常使用Version numbers来确定</p>
</blockquote>
<h4 id="Read-pair-and-anti-entropy"><a href="#Read-pair-and-anti-entropy" class="headerlink" title="Read pair and anti-entropy"></a>Read pair and anti-entropy</h4><h5 id="Read-repair"><a href="#Read-repair" class="headerlink" title="Read repair"></a>Read repair</h5><p>客户端读取并行所有节点的数据，能检测到stale responses，并回写新数据到老节点</p>
<h5 id="Anti-entropy-process"><a href="#Anti-entropy-process" class="headerlink" title="Anti-entropy process"></a>Anti-entropy process</h5><p>后台进程不断地检测不同节点检测数据差异，并补齐。</p>
<h3 id="Quorums-法定人数-for-reading-and-writing"><a href="#Quorums-法定人数-for-reading-and-writing" class="headerlink" title="Quorums(法定人数) for reading and writing"></a>Quorums(法定人数) for reading and writing</h3><p>定义：只要<code>w + r &gt; n</code>，则客户端总能获得最新的数据。遵守该规则的r与w称为<em>quorums read and write</em></p>
<blockquote>
<p>n: 副本数；r: 读请求时，至少得有r个节点能返回数据；w: 写请求至少要被w个节点确认</p>
</blockquote>
<h3 id="Quorums的局限性"><a href="#Quorums的局限性" class="headerlink" title="Quorums的局限性"></a>Quorums的局限性</h3><ul>
<li>如果两个写入同时发生，不清楚哪一个先发生。</li>
<li>如果写操作在某些副本上成功，而在其他节点上失败（例如，因为某些节点上的磁盘已满），在小于w个副本上写入成功</li>
<li>如果携带新值的节点失败，需要读取其他带有旧值的副本。</li>
</ul>
<p>Dynamo风格可以忍受最终一致性，但是无法绝对保证。更强有力的保证通常需要<strong>事务</strong>或<strong>共识</strong></p>
<h4 id="监控staleness-陈旧度"><a href="#监控staleness-陈旧度" class="headerlink" title="监控staleness(陈旧度)"></a>监控staleness(陈旧度)</h4><p>监视你的数据库是否返回最新的结果是很重要的，如果显著落后，应该提醒您，以便您可以调查原因（例如，网络中的问题或超载节点）。</p>
<h3 id="Sloppy-Quorums-and-Hinted-Handoff"><a href="#Sloppy-Quorums-and-Hinted-Handoff" class="headerlink" title="Sloppy Quorums and Hinted Handoff"></a>Sloppy Quorums and Hinted Handoff</h3><p>写和读仍然需要w和r成功的响应, 只不过把把一些请求暂时寄宿在可达节点上，等不可达节点恢复后再传递到目标节点上</p>
<h3 id="多数据中心"><a href="#多数据中心" class="headerlink" title="多数据中心"></a>多数据中心</h3><p>自然支持，quorums只需在一个数据中心满足即可。</p>
<h3 id="检测并发写"><a href="#检测并发写" class="headerlink" title="检测并发写"></a>检测并发写</h3><p>Dynamo-stype允许客户端并发写同一key。存在事件以不同顺序到达不同的节点。</p>
<p><img src="https://github.com/Vonng/ddia/raw/master/img/fig5-12.png" alt="img"></p>
<p>如果每个节点只是简单地覆盖对应key的值，则会出现不一致现象。因此需要解决冲突</p>
<h4 id="Last-wirte-wins-discharding-current-wirtes"><a href="#Last-wirte-wins-discharding-current-wirtes" class="headerlink" title="Last wirte wins(discharding current wirtes)"></a>Last wirte wins(discharding current wirtes)</h4><p>保存”recent”值，并允许“older”值被覆盖或丢弃。使用一些标识来区分”rencent”以及”older”</p>
<h4 id="The-“happens-before”-relationship-and-concurrency"><a href="#The-“happens-before”-relationship-and-concurrency" class="headerlink" title="The “happens-before” relationship and concurrency"></a>The “happens-before” relationship and concurrency</h4><p>只要有两个操作A和B，就有三种可能性：A在B之前发生，或者B在A之前发生(因果关系)，或者A和B并发。</p>
<p>如果一个操作发生在另一个操作之前，则后面的操作应该覆盖较早的操作，但是如果这些操作是并发的，则存在需要解决的冲突。</p>
<h4 id="捕获”happens-before”关系"><a href="#捕获”happens-before”关系" class="headerlink" title="捕获”happens-before”关系"></a>捕获”happens-before”关系</h4><p><img src="https://github.com/Vonng/ddia/raw/master/img/fig5-13.png" alt="img"></p>
<h4 id="合并同时写入的值"><a href="#合并同时写入的值" class="headerlink" title="合并同时写入的值"></a>合并同时写入的值</h4><p>如果多个操作并发发生，则客户端必须通过合并并发写入的值来擦屁股。</p>
<h4 id="版本向量"><a href="#版本向量" class="headerlink" title="版本向量"></a>版本向量</h4><p>使用单个版本号(上图)来捕获操作之间的依赖关系，但是当多个副本并发接受写入时，这是不够的。</p>
<p> 所有副本的版本号集合称为<strong>版本向量（version vector）</strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>单主复制是非常流行的，因为它很容易理解，不需要担心冲突解决。在出现故障节点，网络中断和延迟峰值的情况下，多领导者和无领导者复制可以更加稳健，但以更难以推理并仅提供非常弱的一致性保证为代价。</p>
<p>多领导者和无领导者复制方法所固有的并发问题：因为他们允许多个写入并发发生冲突。我们研究了一个数据库可能使用的算法来确定一个操作是否发生在另一个操作之前，或者它们是否同时发生。</p>
<h1 id="第六章-分区"><a href="#第六章-分区" class="headerlink" title="第六章-分区"></a>第六章-分区</h1><p>复制提高了数据容错性。</p>
<p>但是当数据量大，且查询吞吐量大时，我就必须把数据拆开并分布到不同分区上(partitions or sharding)。这体现了可扩展性</p>
<h3 id="分区与复制"><a href="#分区与复制" class="headerlink" title="分区与复制"></a>分区与复制</h3><p>分区与复制往往是同时存在的，同一个分区有多个副本，多个副本归属不同分区</p>
<h3 id="Key-Value-类数据的分区"><a href="#Key-Value-类数据的分区" class="headerlink" title="Key-Value 类数据的分区"></a>Key-Value 类数据的分区</h3><p>偏斜(skewed): 分区不公平，导致部分分区拥有较多的数据和查询压力</p>
<p>热点(hopt spot): 由于分区不公平，部分节点承受了过高的负载</p>
<p>如何避免不公平的现象呢？</p>
<h4 id="通过Key-Range分区"><a href="#通过Key-Range分区" class="headerlink" title="通过Key Range分区"></a>通过Key Range分区</h4><p>将连续的keys划分成多个段，并分配个每个分区。如下图的单词分区</p>
<p><img src="https://github.com/Vonng/ddia/raw/master/img/fig6-2.png" alt="img"></p>
<p>为了避免skewed，需要针对数据实际分布来分区。例如单词始子母，书籍1只有A,B，而书籍12却有TUVWXYZ</p>
<p>优点：可以让keys保持排序，这样范围查询将变得很容易</p>
<p>缺点：特定的访问模式容易导致热点现象。</p>
<blockquote>
<p>比如时间戳作为key，按天分区，则当天的时序数据都会往同一分区写，造成热点。此时你可以选择数据源作为key</p>
</blockquote>
<h4 id="通过Hash-of-Key-分区"><a href="#通过Hash-of-Key-分区" class="headerlink" title="通过Hash of Key 分区"></a>通过Hash of Key 分区</h4><p>通过给定key的哈希值来决定分区。已知哈希值的范围后，再按分数区划分范围来指定分区。</p>
<p><img src="https://github.com/Vonng/ddia/raw/master/img/fig6-3.png" alt="img"></p>
<p>有点：分区公平</p>
<p>缺点：范围查询困难</p>
<p>折中方案：使用<em>compound primary key</em>(组合主键)，即将多个列组合成一个key。其中key中的第一部分取用hash后分区，剩余部分做为排序所用的连接索引</p>
<h3 id="负载倾斜与消除热点"><a href="#负载倾斜与消除热点" class="headerlink" title="负载倾斜与消除热点"></a>负载倾斜与消除热点</h3><p>尽管hash的方法能帮助减少热点，但并不能完全避免。比如微博明星出轨现象，对同一key的大量请求，同样会造成热点现象。</p>
<p>这只能应用程序自己处理，例如在key前面或者后面append上随机数字。当然有利必有弊，这将导致其他低吞吐量的key产生不必要的性能损耗</p>
<h3 id="分区以及二级索引"><a href="#分区以及二级索引" class="headerlink" title="分区以及二级索引"></a>分区以及二级索引</h3><h4 id="基于文档分区二级索引"><a href="#基于文档分区二级索引" class="headerlink" title="基于文档分区二级索引"></a>基于文档分区二级索引</h4><p>有利于写，不利于读</p>
<p><img src="https://github.com/Vonng/ddia/raw/master/img/fig6-4.png" alt="img"></p>
<p>每个分区维护自身的二级索引，并覆盖自身分区内的所有文档数据。因此又称，本地索引(<em>local index</em>)</p>
<p>缺点：</p>
<ul>
<li>索引往往会分布在多个分区里。在读取时，会造成<strong>分散/聚集（scatter/gather）</strong>现象，读取二级索引较为低效。</li>
</ul>
<h4 id="基于关键词-Term-分区二级索引"><a href="#基于关键词-Term-分区二级索引" class="headerlink" title="基于关键词(Term)分区二级索引"></a>基于关键词(Term)分区二级索引</h4><p>有利于读，不利于写</p>
<p><img src="https://github.com/Vonng/ddia/raw/master/img/fig6-5.png" alt="img"></p>
<p><strong>关键词分区（term-partitioned）</strong>，因为我们寻找的关键词决定了索引的分区方式。是一种全局的分区方式，又称<strong>全局索引</strong></p>
<p>优点：使读取更有效率：不需要<strong>分散/收集</strong>所有分区，客户端只需要向包含关键词的分区发出请求</p>
<p>缺点：写入速度较慢且较为复杂，因为写入单个文档现在可能会影响索引的多个分区。而且，通常更新全局二级索引都是异步的，你写入后查询并不能立即生效</p>
<h3 id="分区再平衡"><a href="#分区再平衡" class="headerlink" title="分区再平衡"></a>分区再平衡</h3><p>定义：更改都需要数据和请求从一个节点移动到另一个节点。 将负载从集群中的一个节点向另一个节点移动的过程，称为称为<strong>再平衡（reblancing）</strong></p>
<p>最低要求：</p>
<ul>
<li>再平衡之后，负载（数据存储，读取和写入请求）应该在集群中的节点之间公平地共享。</li>
<li>再平衡发生时，数据库应该继续接受读取和写入。</li>
<li>节点之间只移动必须的数据，以便快速再平衡，并减少网络和磁盘I/O负载。</li>
</ul>
<h3 id="平衡策略"><a href="#平衡策略" class="headerlink" title="平衡策略"></a>平衡策略</h3><h4 id="反面教材：hash-mod-N"><a href="#反面教材：hash-mod-N" class="headerlink" title="反面教材：hash mod N"></a>反面教材：hash mod N</h4><p>为什么我们不使用<strong><em>mod</em></strong>（许多编程语言中的％运算符）？</p>
<p>因为，如果节点数量N发生变化，大多数密钥将需要从一个节点移动到另一个节点，这过于昂贵了</p>
<h4 id="固定数量的分区"><a href="#固定数量的分区" class="headerlink" title="固定数量的分区"></a>固定数量的分区</h4><p>创建比节点更多的分区，并为每个节点分配多个分区</p>
<p>如果一个节点被添加到集群中，新节点可以从当前每个节点中<strong>窃取</strong>一些分区，直到分区再次公平分配。</p>
<p><img src="https://github.com/Vonng/ddia/raw/master/img/fig6-6.png" alt="img"></p>
<p>优点：简单</p>
<p>缺点： 如果数据集的总大小难以预估，选择正确的分区数是困难的。</p>
<blockquote>
<p>如果分区非常大，再平衡和从节点故障恢复变得昂贵。但是，如果分区太小，则会产生太多的开销。</p>
</blockquote>
<h4 id="动态分区"><a href="#动态分区" class="headerlink" title="动态分区"></a>动态分区</h4><p>当分区增长到超过配置的大小时，会被分成两个分区，每个分区约占一半的数据。与之相反，如果大量数据被删除并且分区缩小到某个阈值以下，则可以将其与相邻分区合并。此过程与B树底层发生的过程类似</p>
<p>注意，数据集开始时很小，直到达到第一个分区的分割点，所有写入操作都必须由单个节点处理，而其他节点则处于空闲状态。使用<strong>预分割（pre-splitting）</strong>避免</p>
<p>优点：分区数量适应总数据量</p>
<h4 id="按节点比例分区"><a href="#按节点比例分区" class="headerlink" title="按节点比例分区"></a>按节点比例分区</h4><p>使分区数与节点数成正比，即每个节点具有固定数量的分区。</p>
<p>当一个新节点加入集群时，它随机选择固定数量的现有分区进行拆分，然后获取每个分区的一半数据，另外一半保留。</p>
<p>随机化可能会产生不公平的分区，可以通过增大分区数来平均化(Cassandra每个节点默认就256个分区)</p>
<h3 id="运维：手动还是自动平衡"><a href="#运维：手动还是自动平衡" class="headerlink" title="运维：手动还是自动平衡"></a>运维：手动还是自动平衡</h3><p>全自动重新平衡可以很方便，但是自动化与自动故障检测相结合可能十分危险。例如误判过载的节点已经死亡</p>
<h2 id="请求路由"><a href="#请求路由" class="headerlink" title="请求路由"></a>请求路由</h2><p>当客户想要发出请求时，如何知道要连接哪个节点？使用<strong>服务发现(service discovery)</strong> 技术</p>
<p><img src="https://github.com/Vonng/ddia/raw/master/img/fig6-7.png" alt="img"></p>
<p>挑战：无论如何，所有参与者都同意路由规则，否则请求将被发送到错误的节点。</p>
<p>方案一：</p>
<p>许多分布式数据系统都依赖于一个独立的协调服务，比如ZooKeeper来跟踪集群元数据。</p>
<ul>
<li>每个节点在ZooKeeper中注册自己，ZooKeeper维护分区到节点的可靠映射</li>
<li>只要分区分配发生的改变，或者集群中添加或删除了一个节点，ZooKeeper就会通知路由层使路由信息保持最新状态。</li>
</ul>
<p>方案二：</p>
<p>在节点之间使用<strong>流言协议（gossip protocol）</strong> 来传播群集状态的变化。</p>
<ul>
<li>请求可以发送到任意节点，该节点会转发到包含所请求的分区的适当节点。如上图中的方法1</li>
</ul>
<h3 id="执行并行查询"><a href="#执行并行查询" class="headerlink" title="执行并行查询"></a>执行并行查询</h3><p><strong>大规模并行处理（MPP, Massively parallel processing）</strong>，MPP查询优化器将这个复杂的查询分解成许多执行阶段和分区，其中许多可以在数据库集群的不同节点上并行执行</p>
<h1 id="第七章-事务"><a href="#第七章-事务" class="headerlink" title="第七章-事务"></a>第七章-事务</h1><p>事务是应用程序将多个读写操作组合成一个逻辑单元的一种方式，整个事务要么成功（<strong>提交（commit）</strong>）要么失败（<strong>中止（abort）</strong>，<strong>回滚（rollback）</strong>）。如果失败，应用程序可以安全地重试。</p>
<p>提供一层抽象，给应用程序一种并发、软硬件问题均不会存在的假象。</p>
<h2 id="ACID的含义"><a href="#ACID的含义" class="headerlink" title="ACID的含义"></a>ACID的含义</h2><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>一般来说，原子是指不能分解成小部分的东西。</p>
<p>在多线程编程中，如果一个线程执行一个原子操作，这意味着另一个线程无法看到该操作的一半结果。</p>
<p>ACID的原子性中，描述了当客户想进行多次写入，在一些写操作处理完之后出现故障时，<strong>能够在错误时中止事务，丢弃该事务进行的所有写入变更的能力</strong></p>
<h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p>ACID的上下文中，<strong>一致性</strong>是指数据库在应用程序的特定概念中处于“良好状态”</p>
<p><strong>you have certain statements about your data that must always be true</strong>, 比如在会计系统中，所有账户整体上必须借贷相抵</p>
<p>原子性，隔离性和持久性是数据库的属性，而一致性（在ACID意义上）是应用程序的属性</p>
<h3 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h3><p><strong>同时执行的事务是相互隔离的</strong>：它们不能相互冒犯</p>
<h3 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h3><p><strong>持久性</strong> 是一个承诺，即一旦事务成功完成，即使发生硬件故障或数据库崩溃，写入的任何数据也不会丢失。</p>
<h2 id="单对象和多对象操作"><a href="#单对象和多对象操作" class="headerlink" title="单对象和多对象操作"></a>单对象和多对象操作</h2><p>多对象事务需要某种方式来确定哪些读写操作属于同一个事务，在关系型数据库中，通常基于客户端与数据库服务器的TCP连接：在任何特定连接上，<code>BEGIN TRANSACTION</code> 和 <code>COMMIT</code> 语句之间的所有内容，被认为是同一事务的一部分。</p>
<h3 id="单对象写入"><a href="#单对象写入" class="headerlink" title="单对象写入"></a>单对象写入</h3><p>对单节点上的单个对象（例如键值对）上提供原子性和隔离性</p>
<h3 id="多对象事务的需求"><a href="#多对象事务的需求" class="headerlink" title="多对象事务的需求"></a>多对象事务的需求</h3><p>场景：</p>
<ul>
<li>在关系数据模型中，一个表中的行通常具有对另一个表中的行的外键引用</li>
<li>当需要更新非规范化的信息时，需要一次更新多个文档</li>
<li>每次更改值时都需要更新索引</li>
</ul>
<p>针对多对象，<strong>若没有原子性，错误处理就要复杂得多，若缺乏隔离性，就会导致并发问题</strong></p>
<h3 id="处理错误和中止"><a href="#处理错误和中止" class="headerlink" title="处理错误和中止"></a>处理错误和中止</h3><p>事务的一个关键特性是，如果发生错误，它可以中止并安全地重试。如若未被ACID，则会终止整个事务，而不是保留半完成的状态</p>
<p>然而，有些数据库则选择，做尽可能多的事，运行遇到错误时，它不会撤消它已经完成的事情，此时，从错误中恢复就是应用程序的责任了。</p>
<p>中止重试的潜在问题：</p>
<ul>
<li>如果事务实际上成功了，但是在服务器试图向客户端确认提交成功时网络发生故障，那么重试事务会导致事务被执行两次</li>
<li>重试事务将使负载过大变得更糟</li>
<li>仅在临时性错误（例如，由于死锁，异常情况，临时性网络中断和故障切换）后才值得重试。在发生永久性错误（例如，违反约束）之后重试是毫无意义的。</li>
<li>如果事务在数据库之外也有副作用，即使事务被中止，也可能发生这些副作用</li>
<li>如果客户端进程在重试中失效，任何试图写入数据库的数据都将丢失。</li>
</ul>
<h2 id="弱隔离级别"><a href="#弱隔离级别" class="headerlink" title="弱隔离级别"></a>弱隔离级别</h2><p>当一个事务读取由另一个事务同时修改的数据时，或者当两个事务试图同时修改相同的数据时，并发问题（竞争条件）才会出现。而且并发BUG很难通过测试找到。</p>
<p>因此，数据库提供了<strong>事务隔离（transaction isolation）</strong> 来隐藏应用程序开发者的并发问题。</p>
<p><strong>可序列化（serializable）</strong> 的隔离等级意味着数据库保证事务的效果如同连续运行。</p>
<p>然而，为了性能，系统通常使用较弱的隔离级别来防止一部分，而不是全部的并发问题</p>
<h3 id="读已提交-Read-Commited"><a href="#读已提交-Read-Commited" class="headerlink" title="读已提交(Read Commited)"></a>读已提交(Read Commited)</h3><p>保证：</p>
<ul>
<li>从数据库读时，只能看到已提交的数据（没有<strong>脏读（ no dirty reads）</strong>）</li>
<li>写入数据库时，只会覆盖已经写入的数据（没有<strong>脏写（no dirty writes）</strong>）。</li>
</ul>
<h4 id="No-dirty-reads"><a href="#No-dirty-reads" class="headerlink" title="No dirty reads"></a>No dirty reads</h4><p>脏读(dirty reads): 假定一个事务已经将一些数据写入数据库，但事务还没有提交或中止。另一个事务可以看到未提交的数据吗？如果是的话，那就叫做<strong>脏读</strong></p>
<p>避免脏读的原因：</p>
<ul>
<li>如果事务需要更新多个对象，脏读取意味着另一个事务可能会只看到一部分更新</li>
<li>如果事务中止，则所有写入操作都需要回滚，若数据库允许脏读，就意味着一个事务可能会看到稍后需要回滚的数据，即从未实际提交给数据库的数据。</li>
</ul>
<h4 id="No-dirty-writes"><a href="#No-dirty-writes" class="headerlink" title="No dirty writes"></a>No dirty writes</h4><p>如果两个事务同时尝试更新数据库中的相同对象，会发生什么情况？通常认为后面的写入会覆盖前面的写入。如果先前的写入是尚未提交事务的一部分，又会发生什么情况，后面的写入会覆盖一个尚未提交的值？这被称作<strong>脏写</strong>。</p>
<p>在<strong>读已提交</strong>的隔离级别上运行的事务必须防止脏写，通常是延迟第二次写入，直到第一次写入事务提交或中止为止。</p>
<p>避免脏写的原因：</p>
<ul>
<li>如果事务更新多个对象，脏写会导致不好的结果，比如，来自不同事务的冲突写入可能会混淆在一起。</li>
<li>Read commited并不能防止两个计数器增量之间的竞争状态。</li>
</ul>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>防止脏写: </p>
<blockquote>
<p> 使用<strong>行锁（row-level lock）</strong>，当事务想要修改特定对象（row or ducument）时，它必须首先获得该对象的锁。然后必须持有该锁直到事务被提交或中止。一次只有一个事务可持有任何给定对象的锁；如果另一个事务要写入同一个对象，则必须等到第一个事务提交或中止后，才能获取该锁并继续。</p>
</blockquote>
<p>防止脏读：</p>
<blockquote>
<p>也可以用锁，不过有性能问题，不采用。因此，通常对于写入的每个对象，数据库都会记住旧的已提交值，和由当前持有写入锁的事务设置的新值。当事务正在进行时，任何其他读取对象的事务都会拿到旧值。 只有当新值提交后，事务才会切换到读取新值。</p>
</blockquote>
<h3 id="快照隔离和可重复读"><a href="#快照隔离和可重复读" class="headerlink" title="快照隔离和可重复读"></a>快照隔离和可重复读</h3><p><img src="https://github.com/Vonng/ddia/raw/master/img/fig7-6.png" alt="img"></p>
<p>这种异常被称为<strong>不可重复读（nonrepeatable read）\</strong>或**读取偏差（read skew）**。</p>
<p>对于read commited来说，这种情况是可容忍的，然而以下情况则不可</p>
<ul>
<li>备份，备份进程运行时，数据库仍然会接受写入操作。因此备份可能会包含一些旧的部分和一些新的部分。</li>
<li>分析查询和完整性检查，一个查询，扫描大部分的数据库，查询在不同时间点观察数据库的不同部分，则可能会返回毫无意义的结果</li>
</ul>
<p>使用<strong>快照隔离（snapshot isolation）</strong>，每个事务都从数据库的<strong>一致快照（consistent snapshot）</strong> 中读取。也就是说，事务可以看到事务开始时在数据库中提交的所有数据。即使这些数据随后被另一个事务更改，每个事务也<strong>只能</strong>看到该特定时间点的旧数据。</p>
<h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>也通常使用写锁来防止脏写，这意味着进行写入的事务会阻止另一个事务修改同一个对象。但是读取不需要任何锁定。性能角度，<strong>读不阻塞写，写不阻塞读</strong></p>
<p>数据库必须可能保留一个对象的几个不同的提交版本，因为各种正在进行的事务可能需要看到数据库在不同的时间点的状态。因为它并排维护着多个版本的对象，所以这种技术被称为<strong>多版本并发控制（MVCC, multi-version concurrentcy control）</strong>。</p>
<p><img src="https://github.com/Vonng/ddia/raw/master/img/fig7-7.png" alt="img"></p>
<p>表中的每一行都有一个 <code>created_by</code> 字段，其中包含将该行插入到表中的的事务ID。</p>
<p>每行都有一个 <code>deleted_by</code> 字段，删除时，将 <code>deleted_by</code> 字段设置为请求删除的事务的ID来标记为删除。其中，update转换为一个delete和create</p>
<h4 id="一致性快照的可见性规则"><a href="#一致性快照的可见性规则" class="headerlink" title="一致性快照的可见性规则"></a>一致性快照的可见性规则</h4><p>当一个事务从数据库中读取时，事务ID用于决定它可以看见哪些对象，看不见哪些对象。工作流程：</p>
<ol>
<li>在每次事务开始时，数据库列出当时所有其他在运行（尚未提交或尚未中止）的事务清单，即使在它之后提交了，这些事务已执行的任何写入也都会被忽略。</li>
<li>被已中止的事务所执行的任何写入都将被忽略。</li>
<li>由具有较晚事务ID（即，在当前事务开始之后开始的）的事务所做的任何写入都被忽略，而不管这些事务是否已经提交。</li>
<li>所有其他写入，对应用都是可见的。</li>
</ol>
<p>一个对象可见的条件：</p>
<ul>
<li>读事务开始时，创建该对象的事务已经提交。</li>
<li>对象未被标记为删除，或如果被标记为删除，请求删除的事务在读事务开始时尚未提交。</li>
</ul>
<h4 id="索引和快照隔离"><a href="#索引和快照隔离" class="headerlink" title="索引和快照隔离"></a>索引和快照隔离</h4><p>索引如何在多版本数据库中工作？一种选择是使索引简单地指向对象的所有版本，并且需要索引查询来过滤掉当前事务不可见的任何对象版本</p>
<h4 id="可重复读与命名混淆"><a href="#可重复读与命名混淆" class="headerlink" title="可重复读与命名混淆"></a>可重复读与命名混淆</h4><p>快照隔离是一个有用的隔离级别，特别对于只读事务而言。但是，许多数据库实现了它，却用不同的名字来称呼。在Oracle中称为<strong>可序列化（Serializable）\</strong>的，在PostgreSQL和MySQL中称为**可重复读（repeatable read）**</p>
<h3 id="防止丢失更新"><a href="#防止丢失更新" class="headerlink" title="防止丢失更新"></a>防止丢失更新</h3><p>如果应用从数据库中读取一些值，修改它并写回修改的值（读取-修改-写入序列，<em>read-modify-write-cycle</em>），则可能会发生丢失更新的问题。例如，如果两个事务同时执行，则其中一个的修改可能会丢失，因为第二个写入的内容并没有包括第一个事务的修改。</p>
<p>场景：</p>
<ul>
<li>增加计数器或更新账户余额（需要读取当前值，计算新值并写回更新后的值）</li>
<li>在复杂值中进行本地修改：例如，将元素添加到JSON文档中的一个列表（需要解析文档，进行更改并写回修改的文档）</li>
<li>两个用户同时编辑wiki页面，每个用户通过将整个页面内容发送到服务器来保存其更改，覆写数据库中当前的任何内容。</li>
</ul>
<h4 id="原子写"><a href="#原子写" class="headerlink" title="原子写"></a>原子写</h4><p>使用原子操作，通常是最好的解决方案。</p>
<p>方法一，原子操作通常通过在读取对象时，获取其上的排它锁来实现，以便更新完成之前没有其他事务可以读取它。</p>
<p>方法二，强制所有的原子操作在单一线程上执行</p>
<h4 id="显式锁定"><a href="#显式锁定" class="headerlink" title="显式锁定"></a>显式锁定</h4><p>让应用程序显式地锁定将要更新的对象。应用程序可以执行读取-修改-写入序列，如果任何其他事务尝试同时读取同一个对象，则强制等待，直到第一个<strong>读取-修改-写入序列</strong>完成</p>
<h4 id="自动检测丢失的更新"><a href="#自动检测丢失的更新" class="headerlink" title="自动检测丢失的更新"></a>自动检测丢失的更新</h4><p>允许它们并行执行，如果事务管理器检测到丢失更新，则中止事务并强制它们重试其<strong>读取-修改-写入序列</strong></p>
<p>优点：数据库可以结合快照隔离高效地执行此检查；它不需要应用代码使用任何特殊的数据库功能</p>
<h4 id="比较并设置（CAS）"><a href="#比较并设置（CAS）" class="headerlink" title="比较并设置（CAS）"></a>比较并设置（CAS）</h4><p><strong>比较并设置（CAS, Compare And Set）</strong>，只有当前值从上次读取时一直未改变，才允许更新发生</p>
<h4 id="冲突解决和复制"><a href="#冲突解决和复制" class="headerlink" title="冲突解决和复制"></a>冲突解决和复制</h4><p>最后写入胜利（LWW）的冲突解决方法很容易丢失更新，不幸的是，LWW是许多复制数据库中的默认方案。</p>
<h3 id="写入偏差与幻读"><a href="#写入偏差与幻读" class="headerlink" title="写入偏差与幻读"></a>写入偏差与幻读</h3><p><img src="https://github.com/Vonng/ddia/raw/master/img/fig7-8.png" alt="img"></p>
<h4 id="写偏差-write-skew"><a href="#写偏差-write-skew" class="headerlink" title="写偏差(write skew)"></a>写偏差(write skew)</h4><p>如果两个事务读取相同的对象，然后更新其中一些对象（不同的事务可能更新不同的对象），则可能发生写入偏差。</p>
<p>例子：</p>
<ul>
<li><strong><em>会议室预订系统</em></strong>，当有人想要预订时，首先检查是否存在相互冲突的预订（即预订时间范围重叠的同一房间），如果没有找到，则创建会议。快照隔离并不能防止另一个用户同时插入冲突的会议。</li>
<li><p><strong><em>多人游戏</em></strong>，玩家将两个不同的棋子移动到棋盘上的相同位置，或者采取其他违反游戏规则的行为。</p>
</li>
<li><p><strong><em>抢注用户名</em></strong>，在每个用户拥有唯一用户名的网站上，两个用户可能会尝试同时创建具有相同用户名的帐户。</p>
</li>
<li><strong><em>防止双重开支</em></strong>，允许用户花钱或积分的服务，需要检查用户的支付数额不超过其余额。有了写入偏差，可能会发生两个支出项目同时插入，一起导致余额变为负值，但这两个事务都不会注意到另一个。</li>
</ul>
<h4 id="导致写入偏差的幻读"><a href="#导致写入偏差的幻读" class="headerlink" title="导致写入偏差的幻读"></a>导致写入偏差的幻读</h4><p>上述例子，基本遵循规律</p>
<ol>
<li>一个<code>SELECT</code>查询找出符合条件的行，并检查是否符合一些要求。</li>
<li>按照第一个查询的结果，应用代码决定是否继续。（可能会继续操作，也可能中止并报错）</li>
<li>如果应用决定继续操作，就执行写入（插入、更新或删除），并提交事务。</li>
</ol>
<p>一个事务中的写入改变另一个事务的搜索查询的结果，被称为<strong>幻读</strong>（快照隔离避免了只读查询中幻读）</p>
<h4 id="物化冲突"><a href="#物化冲突" class="headerlink" title="物化冲突"></a>物化冲突</h4><p>将幻读变为数据库中一组具体行上的锁冲突</p>
<h2 id="Serializability-可序列化"><a href="#Serializability-可序列化" class="headerlink" title="Serializability(可序列化)"></a>Serializability(可序列化)</h2><p>能有效解决写入偏差，幻读等问题。</p>
<p>可序列化（Serializability ）隔离通常被认为是<strong>最强</strong>的隔离级别。它保证即使事务可以并行执行，最终的结果也是一样的，就好像它们没有任何并发性，连续挨个执行一样。</p>
<p>因此数据库保证，如果事务在单独运行时正常运行，则它们在并发运行时继续保持正确 —— 换句话说，数据库可以防止所有可能的竞争条件。</p>
<p>如何实现？</p>
<h3 id="真-串行执行"><a href="#真-串行执行" class="headerlink" title="真*串行执行"></a>真*串行执行</h3><p>最简之法，<strong>完全不要并发</strong>：在单个线程上按顺序一次只执行一个事务。</p>
<p>这样做就完全绕开了检测/防止事务间冲突的问题，由此产生的隔离，正是可序列化的定义。</p>
<p>能实际运用的原因：</p>
<ul>
<li>RAM足够便宜了，许多场景现在都可以将完整的活跃数据集保存在内存中</li>
<li>数据库设计人员意识到OLTP事务通常很短，而且只进行少量的读写操作。相比之下，长时间的OLAP，通常是只读的</li>
</ul>
<h4 id="在存储过程中封装事务"><a href="#在存储过程中封装事务" class="headerlink" title="在存储过程中封装事务"></a>在存储过程中封装事务</h4><p>即使用存储过程，将各个阶段的操作合并为单个事务</p>
<h4 id="串行执行小结"><a href="#串行执行小结" class="headerlink" title="串行执行小结"></a>串行执行小结</h4><ul>
<li>每个事务都必须小而快，只要有一个缓慢的事务，就会拖慢所有事务处理。</li>
<li>仅限于活跃数据集可以放入内存的情况</li>
<li>写入吞吐量必须低到能在单个CPU核上处理，如若不然，事务需要能划分至单个分区，且不需要跨分区协调。</li>
<li>跨分区事务是可能的，但是它们的使用程度有很大的限制。</li>
</ul>
<h3 id="两阶段锁定（2PL）"><a href="#两阶段锁定（2PL）" class="headerlink" title="两阶段锁定（2PL）"></a>两阶段锁定（2PL）</h3><p>只要没有写入，就允许多个事务同时读取同一个对象。但对象只要有写入（修改或删除），就需要<strong>独占访问（exclusive access）</strong> 权限：</p>
<ul>
<li>如果事务A读取了一个对象，并且事务B想要写入该对象，那么B必须等到A提交或中止才能继续。（这确保B不能在A底下意外地改变对象。）</li>
<li>如果事务A写入了一个对象，并且事务B想要读取该对象，则B必须等到A提交或中止才能继续。（读取旧版本的对象在2PL下是不可接受的。）</li>
</ul>
<h4 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h4><p>为数据库中每个对象添加锁来实现的。锁可以处于<strong>共享模式（shared mode）\</strong>或**独占模式（exclusive mode**</p>
<ul>
<li>若事务要读取对象，则须先以共享模式获取锁。允许多个事务同时持有共享锁。但如果另一个事务已经在对象上持有排它锁，则这些事务必须等待。</li>
<li>若事务要写入一个对象，它必须首先以独占模式获取该锁。没有其他事务可以同时持有锁（无论是共享模式还是独占模式），所以如果对象上存在任何锁，该事务必须等待。</li>
<li>如果事务先读取再写入对象，则它可能会将其共享锁升级为独占锁。升级锁的工作与直接获得排他锁相同。</li>
<li>事务获得锁之后，必须继续持有锁直到事务结束（提交或中止）。这就是“两阶段”这个名字的来源：第一阶段（当事务正在执行时）获取锁，第二阶段（在事务结束时）释放所有的锁。</li>
</ul>
<p>死锁发生：事务A等待事务B释放它的锁，反之亦然。数据库会自动检测，并中止其中一个。</p>
<h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p>一部分是由于获取和释放所有这些锁的开销，但更重要的是由于并发性的降低。</p>
<p>只需要一个缓慢的事务，或者一个访问大量数据并获取许多锁的事务，就能把系统的其他部分拖慢。</p>
<p>当事务由于死锁而被中止并被重试时，它需要从头重做它的工作。如果死锁很频繁，这可能意味着巨大的浪费。</p>
<h4 id="谓词锁"><a href="#谓词锁" class="headerlink" title="谓词锁"></a>谓词锁</h4><p>它类似于前面描述的共享/排它锁，但不属于特定的对象（例如，表中的一行），它属于所有符合某些<strong>搜索条件</strong>的对象</p>
<h4 id="索引范围锁"><a href="#索引范围锁" class="headerlink" title="索引范围锁"></a>索引范围锁</h4><p>如果活跃事务持有很多锁，检查匹配的锁会非常耗时。因此，大多数使用2PL的数据库实际上实现了<strong>索引范围锁</strong>（也称为<strong>间隙锁（next-key locking </strong>），这是一个简化的近似版谓词锁</p>
<p>在房间预订数据库中，您可能会在<code>room_id</code>列上有一个索引，并且/或者在<code>start_time</code> 和 <code>end_time</code>上有索引（否则前面的查询在大型数据库上的速度会非常慢）</p>
<ul>
<li>设您的索引位于<code>room_id</code>上，并且数据库使用此索引查找123号房间的现有预订。现在数据库可以简单地将共享锁附加到这个索引项上，指示事务已搜索123号房间用于预订。</li>
<li>或者，如果数据库使用基于时间的索引来查找现有预订，那么它可以将共享锁附加到该索引中的一系列值，指示事务已经将12:00~13:00时间段标记为用于预定。</li>
</ul>
<p>现在，如果另一个事务想要插入，更新或删除同一个房间和/或重叠时间段的预订，则它将不得不更新索引的相同部分，此时，它会遇到共享锁，它将被迫等到锁被释放。</p>
<h3 id="序列化快照隔离（SSI）"><a href="#序列化快照隔离（SSI）" class="headerlink" title="序列化快照隔离（SSI）"></a>序列化快照隔离（SSI）</h3><p>很有前途</p>
<h4 id="悲观与乐观的并发控制"><a href="#悲观与乐观的并发控制" class="headerlink" title="悲观与乐观的并发控制"></a>悲观与乐观的并发控制</h4><p>两阶段锁(2PL)是一种所谓的<strong>悲观并发控制机制</strong>。意味着，如果有事情可能出错（如另一个事务所持有的锁所表示的），最好等到情况安全后再做任何事情。这就像互斥，用于保护多线程编程中的数据结构。</p>
<p><strong>序列化快照隔离</strong>是一种<strong>乐观（optimistic）</strong> 的并发控制技术。意味着，如果存在潜在的危险也不阻止事务，而是继续执行事务，希望一切都会好起来。当一个事务想要提交时，数据库检查是否有什么不好的事情发生（比如，隔离是否被违反）；如果是的话，事务将被中止，并且必须重试。</p>
<p>SSI基于快照隔离，事务中的所有读取都是来自数据库的一致性快照。SSI添加了一种算法来检测写入之间的序列化冲突，并确定要中止哪些事务。</p>
<h4 id="基于过时前提的决策"><a href="#基于过时前提的决策" class="headerlink" title="基于过时前提的决策"></a>基于过时前提的决策</h4><p>事务从数据库读取一些数据，检查查询的结果，并根据它看到的结果决定采取一些操作（写入数据库）。但是，在快照隔离的情况下，原始查询的结果在事务提交时可能不再是最新的，因为数据可能在同一时间被修改。</p>
<p>事务基于一个<strong>前提（premise）</strong> 采取行动（事务开始时候的事实，例如：“目前有两名医生正在值班”）</p>
<h4 id="检测旧MVCC读取"><a href="#检测旧MVCC读取" class="headerlink" title="检测旧MVCC读取"></a>检测旧MVCC读取</h4><p>数据库需要跟踪一个事务由于MVCC可见性规则而忽略另一个事务的写入。当事务想要提交时，数据库检查是否有任何被忽略的写入现在已经被提交。如果是这样，事务必须中止。</p>
<h4 id="检测影响之前读取的写入"><a href="#检测影响之前读取的写入" class="headerlink" title="检测影响之前读取的写入"></a>检测影响之前读取的写入</h4><p>第二种情况要考虑的是另一个事务在读取数据之后修改数据。</p>
<p><img src="https://github.com/Vonng/ddia/raw/master/img/fig7-11.png" alt="img"></p>
<p>如果在<code>shift_id</code>上有索引，则数据库可以使用索引项1234 来记录事务42 和43 读取这个数据的事实。</p>
<p>当事务写入数据库时，它必须在索引中查找最近曾读取受影响数据的其他事务。并通知其他事务：你们读过的数据可能不是最新的啦。</p>
<h4 id="可序列化的快照隔离的性能"><a href="#可序列化的快照隔离的性能" class="headerlink" title="可序列化的快照隔离的性能"></a>可序列化的快照隔离的性能</h4><p>有很多细节影响。例如，跟踪事务的读取和写入的<strong>粒度</strong>，粒度越细，准确度越高，但性能损耗也越高。事务可以读取被另一个事务覆盖的信息。</p>
<p>与两阶段锁定相比，可序列化快照隔离的最大优点是一个事务不需要阻塞等待另一个事务所持有的锁。</p>
<p>中止率显著影响SSI的整体表现，对于慢事务，SSI可能比两阶段锁定或串行执行更不敏感。</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ul>
<li><strong><em>脏读</em></strong>： 一个客户端读取到另一个客户端尚未提交的写入。<strong>读已提交</strong>或更强的隔离级别可以防止脏读。</li>
<li><strong><em>脏写</em></strong>： 一个客户端覆盖写入了另； 一个客户端尚未提交的写入。几乎所有的事务实现都可以防止脏写。</li>
<li><strong><em>读取偏差（不可重复读）</em></strong>：  在同一个事务中，客户端在不同的时间点会看见数据库的不同状态。<strong>快照隔离</strong>，通常使用<strong>多版本并发控制（MVCC）</strong> 来实现</li>
<li><strong><em>更新丢失</em></strong>： 两个客户端同时执行<strong>读取-修改-写入序列</strong>。其中一个写操作，在没有合并另一个写入变更情况下，直接覆盖了另一个写操作的结果。所以导致数据丢失。</li>
<li><strong><em>写偏差</em></strong>： 一个事务读取一些东西，根据它所看到的值作出决定，并将该决定写入数据库。但是，写入时，该决定的前提不再是真实的。只有可序列化的隔离才能防止这种异常。</li>
<li><strong><em>幻读</em></strong>： 事务读取符合某些搜索条件的对象。另一个客户端进行写入，影响搜索结果。快照隔离可以防止直接的幻像读取，但是写入偏差上下文中的幻读需要特殊处理，例如索引范围锁定。</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/08/08/【读书笔记】设计数据密集型应用/" rel="next" title="设计数据密集型应用之数据系统基础">
                <i class="fa fa-chevron-left"></i> 设计数据密集型应用之数据系统基础
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Eren Ming</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/erenming" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:erenming233@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#第五章-复制"><span class="nav-number">1.</span> <span class="nav-text">第五章-复制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Leaders-and-Followers-单Leader"><span class="nav-number">1.1.</span> <span class="nav-text">Leaders and Followers(单Leader)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#同步还是异步复制"><span class="nav-number">1.2.</span> <span class="nav-text">同步还是异步复制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#设置新的Followers"><span class="nav-number">1.3.</span> <span class="nav-text">设置新的Followers</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#处理节点宕机"><span class="nav-number">1.4.</span> <span class="nav-text">处理节点宕机</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Follower-failure：Catch-up-recovery"><span class="nav-number">1.4.1.</span> <span class="nav-text">Follower failure：Catch-up recovery</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Leader-failure-Failure-故障切换"><span class="nav-number">1.4.2.</span> <span class="nav-text">Leader failure: Failure(故障切换)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Implementation-of-Replication-Logs"><span class="nav-number">1.5.</span> <span class="nav-text">Implementation of Replication Logs</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#statement-based-replication"><span class="nav-number">1.5.1.</span> <span class="nav-text">statement-based replication</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Write-ahead-log-WAL-传输"><span class="nav-number">1.5.2.</span> <span class="nav-text">Write-ahead log(WAL) 传输</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Logical-row-based-log-replication"><span class="nav-number">1.5.3.</span> <span class="nav-text">Logical(row-based)log replication</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Trigger-based-replication"><span class="nav-number">1.5.4.</span> <span class="nav-text">Trigger-based replication</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Porblems-with-Replication-Lag"><span class="nav-number">1.6.</span> <span class="nav-text">Porblems with Replication Lag</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Reading-Your-Owen-Writes"><span class="nav-number">1.6.1.</span> <span class="nav-text">Reading Your Owen Writes</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#单调读"><span class="nav-number">1.6.2.</span> <span class="nav-text">单调读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Consistent-Prefix-Reads"><span class="nav-number">1.6.3.</span> <span class="nav-text">Consistent Prefix Reads</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution-for-Replication-Lag"><span class="nav-number">1.7.</span> <span class="nav-text">Solution for Replication Lag</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Multi-Leader-Replication-多主复制"><span class="nav-number">1.8.</span> <span class="nav-text">Multi-Leader Replication(多主复制)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#应用场景"><span class="nav-number">1.8.1.</span> <span class="nav-text">应用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#处理写冲突"><span class="nav-number">1.8.2.</span> <span class="nav-text">处理写冲突</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#避免写冲突"><span class="nav-number">1.8.2.1.</span> <span class="nav-text">避免写冲突</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#收敛到一致的状态"><span class="nav-number">1.8.2.2.</span> <span class="nav-text">收敛到一致的状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#自定义冲突解决"><span class="nav-number">1.8.2.3.</span> <span class="nav-text">自定义冲突解决</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#拓扑结构"><span class="nav-number">1.8.3.</span> <span class="nav-text">拓扑结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Leaderless-Replication-无主复制"><span class="nav-number">1.9.</span> <span class="nav-text">Leaderless Replication(无主复制)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#单节点故障时写入"><span class="nav-number">1.9.0.1.</span> <span class="nav-text">单节点故障时写入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Read-pair-and-anti-entropy"><span class="nav-number">1.9.0.2.</span> <span class="nav-text">Read pair and anti-entropy</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Read-repair"><span class="nav-number">1.9.0.2.1.</span> <span class="nav-text">Read repair</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Anti-entropy-process"><span class="nav-number">1.9.0.2.2.</span> <span class="nav-text">Anti-entropy process</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Quorums-法定人数-for-reading-and-writing"><span class="nav-number">1.9.1.</span> <span class="nav-text">Quorums(法定人数) for reading and writing</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Quorums的局限性"><span class="nav-number">1.9.2.</span> <span class="nav-text">Quorums的局限性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#监控staleness-陈旧度"><span class="nav-number">1.9.2.1.</span> <span class="nav-text">监控staleness(陈旧度)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Sloppy-Quorums-and-Hinted-Handoff"><span class="nav-number">1.9.3.</span> <span class="nav-text">Sloppy Quorums and Hinted Handoff</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多数据中心"><span class="nav-number">1.9.4.</span> <span class="nav-text">多数据中心</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#检测并发写"><span class="nav-number">1.9.5.</span> <span class="nav-text">检测并发写</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Last-wirte-wins-discharding-current-wirtes"><span class="nav-number">1.9.5.1.</span> <span class="nav-text">Last wirte wins(discharding current wirtes)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#The-“happens-before”-relationship-and-concurrency"><span class="nav-number">1.9.5.2.</span> <span class="nav-text">The “happens-before” relationship and concurrency</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#捕获”happens-before”关系"><span class="nav-number">1.9.5.3.</span> <span class="nav-text">捕获”happens-before”关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#合并同时写入的值"><span class="nav-number">1.9.5.4.</span> <span class="nav-text">合并同时写入的值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#版本向量"><span class="nav-number">1.9.5.5.</span> <span class="nav-text">版本向量</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">1.10.</span> <span class="nav-text">总结</span></a></li></ol><li class="nav-item nav-level-1"><a class="nav-link" href="#第六章-分区"><span class="nav-number">2.</span> <span class="nav-text">第六章-分区</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#分区与复制"><span class="nav-number">2.0.1.</span> <span class="nav-text">分区与复制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Key-Value-类数据的分区"><span class="nav-number">2.0.2.</span> <span class="nav-text">Key-Value 类数据的分区</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#通过Key-Range分区"><span class="nav-number">2.0.2.1.</span> <span class="nav-text">通过Key Range分区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#通过Hash-of-Key-分区"><span class="nav-number">2.0.2.2.</span> <span class="nav-text">通过Hash of Key 分区</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#负载倾斜与消除热点"><span class="nav-number">2.0.3.</span> <span class="nav-text">负载倾斜与消除热点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分区以及二级索引"><span class="nav-number">2.0.4.</span> <span class="nav-text">分区以及二级索引</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基于文档分区二级索引"><span class="nav-number">2.0.4.1.</span> <span class="nav-text">基于文档分区二级索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#基于关键词-Term-分区二级索引"><span class="nav-number">2.0.4.2.</span> <span class="nav-text">基于关键词(Term)分区二级索引</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分区再平衡"><span class="nav-number">2.0.5.</span> <span class="nav-text">分区再平衡</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#平衡策略"><span class="nav-number">2.0.6.</span> <span class="nav-text">平衡策略</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#反面教材：hash-mod-N"><span class="nav-number">2.0.6.1.</span> <span class="nav-text">反面教材：hash mod N</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#固定数量的分区"><span class="nav-number">2.0.6.2.</span> <span class="nav-text">固定数量的分区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#动态分区"><span class="nav-number">2.0.6.3.</span> <span class="nav-text">动态分区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#按节点比例分区"><span class="nav-number">2.0.6.4.</span> <span class="nav-text">按节点比例分区</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#运维：手动还是自动平衡"><span class="nav-number">2.0.7.</span> <span class="nav-text">运维：手动还是自动平衡</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#请求路由"><span class="nav-number">2.1.</span> <span class="nav-text">请求路由</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#执行并行查询"><span class="nav-number">2.1.1.</span> <span class="nav-text">执行并行查询</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第七章-事务"><span class="nav-number">3.</span> <span class="nav-text">第七章-事务</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ACID的含义"><span class="nav-number">3.1.</span> <span class="nav-text">ACID的含义</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#原子性"><span class="nav-number">3.1.1.</span> <span class="nav-text">原子性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一致性"><span class="nav-number">3.1.2.</span> <span class="nav-text">一致性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#隔离性"><span class="nav-number">3.1.3.</span> <span class="nav-text">隔离性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#持久性"><span class="nav-number">3.1.4.</span> <span class="nav-text">持久性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#单对象和多对象操作"><span class="nav-number">3.2.</span> <span class="nav-text">单对象和多对象操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#单对象写入"><span class="nav-number">3.2.1.</span> <span class="nav-text">单对象写入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多对象事务的需求"><span class="nav-number">3.2.2.</span> <span class="nav-text">多对象事务的需求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#处理错误和中止"><span class="nav-number">3.2.3.</span> <span class="nav-text">处理错误和中止</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#弱隔离级别"><span class="nav-number">3.3.</span> <span class="nav-text">弱隔离级别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#读已提交-Read-Commited"><span class="nav-number">3.3.1.</span> <span class="nav-text">读已提交(Read Commited)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#No-dirty-reads"><span class="nav-number">3.3.1.1.</span> <span class="nav-text">No dirty reads</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#No-dirty-writes"><span class="nav-number">3.3.1.2.</span> <span class="nav-text">No dirty writes</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实现"><span class="nav-number">3.3.1.3.</span> <span class="nav-text">实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#快照隔离和可重复读"><span class="nav-number">3.3.2.</span> <span class="nav-text">快照隔离和可重复读</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#实现-1"><span class="nav-number">3.3.2.1.</span> <span class="nav-text">实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#一致性快照的可见性规则"><span class="nav-number">3.3.2.2.</span> <span class="nav-text">一致性快照的可见性规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#索引和快照隔离"><span class="nav-number">3.3.2.3.</span> <span class="nav-text">索引和快照隔离</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#可重复读与命名混淆"><span class="nav-number">3.3.2.4.</span> <span class="nav-text">可重复读与命名混淆</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#防止丢失更新"><span class="nav-number">3.3.3.</span> <span class="nav-text">防止丢失更新</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#原子写"><span class="nav-number">3.3.3.1.</span> <span class="nav-text">原子写</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#显式锁定"><span class="nav-number">3.3.3.2.</span> <span class="nav-text">显式锁定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#自动检测丢失的更新"><span class="nav-number">3.3.3.3.</span> <span class="nav-text">自动检测丢失的更新</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#比较并设置（CAS）"><span class="nav-number">3.3.3.4.</span> <span class="nav-text">比较并设置（CAS）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#冲突解决和复制"><span class="nav-number">3.3.3.5.</span> <span class="nav-text">冲突解决和复制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#写入偏差与幻读"><span class="nav-number">3.3.4.</span> <span class="nav-text">写入偏差与幻读</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#写偏差-write-skew"><span class="nav-number">3.3.4.1.</span> <span class="nav-text">写偏差(write skew)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#导致写入偏差的幻读"><span class="nav-number">3.3.4.2.</span> <span class="nav-text">导致写入偏差的幻读</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#物化冲突"><span class="nav-number">3.3.4.3.</span> <span class="nav-text">物化冲突</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Serializability-可序列化"><span class="nav-number">3.4.</span> <span class="nav-text">Serializability(可序列化)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#真-串行执行"><span class="nav-number">3.4.1.</span> <span class="nav-text">真*串行执行</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#在存储过程中封装事务"><span class="nav-number">3.4.1.1.</span> <span class="nav-text">在存储过程中封装事务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#串行执行小结"><span class="nav-number">3.4.1.2.</span> <span class="nav-text">串行执行小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#两阶段锁定（2PL）"><span class="nav-number">3.4.2.</span> <span class="nav-text">两阶段锁定（2PL）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#实现-2"><span class="nav-number">3.4.2.1.</span> <span class="nav-text">实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#性能"><span class="nav-number">3.4.2.2.</span> <span class="nav-text">性能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#谓词锁"><span class="nav-number">3.4.2.3.</span> <span class="nav-text">谓词锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#索引范围锁"><span class="nav-number">3.4.2.4.</span> <span class="nav-text">索引范围锁</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#序列化快照隔离（SSI）"><span class="nav-number">3.4.3.</span> <span class="nav-text">序列化快照隔离（SSI）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#悲观与乐观的并发控制"><span class="nav-number">3.4.3.1.</span> <span class="nav-text">悲观与乐观的并发控制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#基于过时前提的决策"><span class="nav-number">3.4.3.2.</span> <span class="nav-text">基于过时前提的决策</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#检测旧MVCC读取"><span class="nav-number">3.4.3.3.</span> <span class="nav-text">检测旧MVCC读取</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#检测影响之前读取的写入"><span class="nav-number">3.4.3.4.</span> <span class="nav-text">检测影响之前读取的写入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#可序列化的快照隔离的性能"><span class="nav-number">3.4.3.5.</span> <span class="nav-text">可序列化的快照隔离的性能</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结-1"><span class="nav-number">3.5.</span> <span class="nav-text">总结</span></a></li></ol></li></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  #<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Eren Ming</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://erenming.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'https://erenming.com/2020/09/05/【读书笔记】设计数据密集型应用-第二部分/';
          this.page.identifier = '2020/09/05/【读书笔记】设计数据密集型应用-第二部分/';
          this.page.title = '【读书笔记】设计数据密集型应用-第二部分';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://erenming.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  














  





  

  

  

  
  

  

  

  

</body>
</html>
