<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Algorithm on Nothing Special</title>
    <link>https://erenming.github.io/tags/algorithm/</link>
    <description>Recent content in Algorithm on Nothing Special</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Fri, 04 Nov 2022 13:27:25 +0800</lastBuildDate><atom:link href="https://erenming.github.io/tags/algorithm/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[刷题总结]二分搜索</title>
      <link>https://erenming.github.io/posts/algorithm-binary-search/</link>
      <pubDate>Fri, 04 Nov 2022 13:27:25 +0800</pubDate>
      
      <guid>https://erenming.github.io/posts/algorithm-binary-search/</guid>
      <description>二分搜索算法，又称折半搜索，是一种通过寻找中点并不断减半搜索范围的算法，时间复杂度为O(logN)，其算法流程大致如下所述：
 首先，其必须作用于有序数组上，找到中点并与目标值进行比较 若目标值比中点小，则将搜索范围缩小为左半数组；反之则将搜索范围缩小为右半数组 重复1，2步骤，直到终点与目标值相等  二分搜索的算法流程看起来很简单，然而实际的题目可能会有各种变化和细节，因此写好一个二分搜索算法并不简单。
在我看来，二分搜索的关键点在于问题的划分点以及子集的选择，而这两块也最容易产生变体：
  有序性变体：目标序列并非严格有序，或者说有序性需要你自行构造
  二分选择变体：左右子集的选择算法往往不尽相同
  此外，我们需要特别注意细节，因此编写中应当尽量使用else if而非else，力求覆盖到每种case
解题框架 func search(nums []int, target int) int {  lo, hi := 0, n-1  for less(lo, hi) {  mid := getmid(lo, hi)  if equalcase(mid, target) {  // 1. 先考虑相等情况  } else if lesscase(target, mid) {  // 2. 再考虑其他情况  } else if ...  } } 题目详解 33.</description>
    </item>
    
  </channel>
</rss>
