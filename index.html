<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Eren with you">
<meta property="og:url" content="https://erenming.com/index.html">
<meta property="og:site_name" content="Eren with you">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Eren with you">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://erenming.com/">





  <title>Eren with you</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Eren with you</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://erenming.com/2020/11/22/【读书笔记】设计数据密集型应用-第三部分/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Eren Ming">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eren with you">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/11/22/【读书笔记】设计数据密集型应用-第三部分/" itemprop="url">【读书笔记】设计数据密集型应用-第三部分</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-11-22T13:27:58+08:00">
                2020-11-22
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/11/22/【读书笔记】设计数据密集型应用-第三部分/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/11/22/【读书笔记】设计数据密集型应用-第三部分/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第10章-批处理"><a href="#第10章-批处理" class="headerlink" title="第10章-批处理"></a>第10章-批处理</h1><p>系统分类：</p>
<ul>
<li>服务(在线系统)：服务等待客户端的请求或指令到达。会尽快地返回结果</li>
<li>批处理系统(离线系统)：拥有大量的输入数据，通过跑一个job来处理它，并生成输出数据</li>
<li>流处理系统(near-real-time system)：stream job operates on events <strong>shortly</strong> after they happen, whereas a batch job operates on a fixed set of input data</li>
</ul>
<h2 id="使用unix工具的批处理"><a href="#使用unix工具的批处理" class="headerlink" title="使用unix工具的批处理"></a>使用unix工具的批处理</h2><p>使用unix工具处理日志文件: </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cat /var/log/nginx/access.log | #1</span><br><span class="line">	awk '&#123;print $7&#125;' | #2</span><br><span class="line">	sort             | #3</span><br><span class="line">	uniq -c          | #4</span><br><span class="line">	sort -r -n       | #5</span><br><span class="line">	head -n 5          #6</span><br></pre></td></tr></table></figure>
<p>使用程序处理：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">counts = Hash.new(<span class="number">0</span>)         <span class="comment"># 1</span></span><br><span class="line">File.open(<span class="string">'/var/log/nginx/access.log'</span>) <span class="keyword">do</span> <span class="params">|file|</span> </span><br><span class="line">    file.each <span class="keyword">do</span> <span class="params">|line|</span></span><br><span class="line">        url = line.split[<span class="number">6</span>]  <span class="comment"># 2</span></span><br><span class="line">        counts[url] += <span class="number">1</span>     <span class="comment"># 3</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">top5 = counts.map&#123;<span class="params">|url, count|</span> [count, url] &#125;.sort.reverse[<span class="number">0</span>...<span class="number">5</span>] <span class="comment"># 4</span></span><br><span class="line">top5.each&#123;<span class="params">|count, url|</span> puts <span class="string">"<span class="subst">#&#123;count&#125;</span> <span class="subst">#&#123;url&#125;</span>"</span> &#125;                   <span class="comment"># 5</span></span><br></pre></td></tr></table></figure>
<p>上述两者对比？</p>
<ul>
<li>当不同的URL数量较小时，程序处理较好。因为它读入内存的hash表</li>
<li>当数据量非常大时。命令行更好，因为sort命令会通过溢出磁盘的技术适配大数据，且能利用磁盘顺序IO的性能优势</li>
</ul>
<h3 id="Unix哲学"><a href="#Unix哲学" class="headerlink" title="Unix哲学"></a>Unix哲学</h3><ol>
<li>让程序只做好一件事。新功能新程序，而非添加功能</li>
<li>每个程序的输出都能成为另外一个程序的输入。即程序只是数据的过滤器</li>
<li>尽早地设计构建原型</li>
<li>优先使用工具来减轻编程任务，即使是曲线救国的方式</li>
</ol>
<p>Unix 如何实现的组合性？</p>
<h4 id="统一的接口"><a href="#统一的接口" class="headerlink" title="统一的接口"></a>统一的接口</h4><p>Unix中使用文件(fd)来表示，它只是一串有序的字节序列。</p>
<p>(web中则使用URL作为接口)</p>
<h4 id="分离逻辑与布线"><a href="#分离逻辑与布线" class="headerlink" title="分离逻辑与布线"></a>分离逻辑与布线</h4><p>用户可以以他们想要的方式链接输入与输出，而该程序不知道也不关心从哪里输入、后又输出到哪里</p>
<h4 id="透明度和实验"><a href="#透明度和实验" class="headerlink" title="透明度和实验"></a>透明度和实验</h4><p>Unix 工具非常易于调试。</p>
<p>Unix命令的输入文件通常被视为不可变。这样你可以随意尝试，而不会损坏原始数据</p>
<p>可以在任何时候结束管道，这很便于调试。</p>
<p>可以某个阶段的数据输出保存到文件中，并可以使用该文件作为下一阶段的输入。</p>
<h2 id="MapReduce和分布式文件系统"><a href="#MapReduce和分布式文件系统" class="headerlink" title="MapReduce和分布式文件系统"></a>MapReduce和分布式文件系统</h2><p>MapReduce就像Unix工具一样，不过是分布在数千台机器上。</p>
<p>MapReduce的job通过在分布式文件系统上写文件来作为类似Unix中的stdin和stdout</p>
<h3 id="MapReduce任务执行"><a href="#MapReduce任务执行" class="headerlink" title="MapReduce任务执行"></a>MapReduce任务执行</h3><p>处理模式：</p>
<ol>
<li>读取一组input文件，并拆解成记录(records)。</li>
<li>调用mapper函数，从每条记录中提取一对键值对。</li>
<li>按照键来排序所有键值对(MapReduce默认执行)</li>
<li>调用reduce函数编列排序后的键值对。</li>
</ol>
<h4 id="Mapper"><a href="#Mapper" class="headerlink" title="Mapper"></a>Mapper</h4><p>负责从input文件中提取键值对</p>
<h4 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a>Reducer</h4><p>MapReduce框架拉去由mapper生成的键值对，收集同一键的所有值，并在改值列表上迭代调用reducer</p>
<h3 id="分布式执行"><a href="#分布式执行" class="headerlink" title="分布式执行"></a>分布式执行</h3><p>数据的分布由框架层负责，基本上采用一种就近原则：即会在存有input文件副本的节点上执行mapper，可以节省网络传输数据的开销。</p>
<p>对于reducer，通过对键哈希以确保相同键的键值对会被传递到同一reducer。</p>
<p>键值对必须排序，通常是按阶段排序。只要mapper读取完input文件，并写完排序后的output文件后，reducer就会开始获取output文件。</p>
<p>reducer获取文件，合并且保留有序性，最后对记录处理。</p>
<h3 id="MapReduce工作流"><a href="#MapReduce工作流" class="headerlink" title="MapReduce工作流"></a>MapReduce工作流</h3><p>如同Unix命令一样，单个MapReduce任务作用有限，通常是多个任务组合成工作流。</p>
<p>MapReduce并不原生支持，而是用过input&amp;output文件（目录）来实现。且默认是前一个MapReduce任务完全结束后才能开始下一个</p>
<h3 id="Reduce-Side-Join-and-Grouping"><a href="#Reduce-Side-Join-and-Grouping" class="headerlink" title="Reduce-Side Join and Grouping"></a>Reduce-Side Join and Grouping</h3><p>如何处理join以及group呢？（类似SQL中的）</p>
<h4 id="join"><a href="#join" class="headerlink" title="join"></a>join</h4><p>例如user_info <-> user_activity_event表：</-></p>
<p>通常是获取user_info的一个副本，并放置与user_activity_event表所在机器的文件系统上，最后再执行任务。</p>
<p>Sort-meger join: 通过归并排序的方式，reducer将两个mapper的output合并</p>
<p>将相关的数据放在一起</p>
<h4 id="group-by"><a href="#group-by" class="headerlink" title="group by"></a>group by</h4><p>设置mapper，使得它生成的键值对是以目标分组键为键。随后分区和排序过程将所有相同键的记录传递到reducer。</p>
<p>处理倾斜数据？</p>
<p>由于存在热点数据的情况(如处理明星相关的分组)，会导致负载不均等问题。如何处理？</p>
<ul>
<li>预先跑一份样本数据来判断哪些键是热点键</li>
<li>显示指定热点键</li>
</ul>
<p>然后使用随机话的策略来减轻热点数据的分区</p>
<h3 id="Map-Side-Join"><a href="#Map-Side-Join" class="headerlink" title="Map-Side Join"></a>Map-Side Join</h3><h4 id="Brocadcast-hash-join"><a href="#Brocadcast-hash-join" class="headerlink" title="Brocadcast hash join"></a>Brocadcast hash join</h4><p>两个连接输入之一很小，所以它并没有分区，而且能被完全加载进一个哈希表中。因此，你可以为连接输入大端的每个分区启动一个Mapper，将输入小端的散列表加载到每个Mapper中，然后扫描大端，一次一条记录，并为每条记录查询散列表。</p>
<h4 id="Partitioned-hash-joins"><a href="#Partitioned-hash-joins" class="headerlink" title="Partitioned hash joins"></a>Partitioned hash joins</h4><p> 如果两个连接输入以相同的方式分区（使用相同的键，相同的散列函数和相同数量的分区），则可以独立地对每个分区应用散列表方法。</p>
<h2 id="批处理工作流的输出"><a href="#批处理工作流的输出" class="headerlink" title="批处理工作流的输出"></a>批处理工作流的输出</h2><ul>
<li>建立索引：批处理处理文档并输出索引</li>
<li>键值存储：批处理处理数据并输出键值对到数据库(或者写入文件，数据库程序再读文件)</li>
</ul>
<h3 id="批处理输出的哲学"><a href="#批处理输出的哲学" class="headerlink" title="批处理输出的哲学"></a>批处理输出的哲学</h3><p>任何先前的输出都被新的输出完全取代，且无任何副作用。</p>
<h2 id="Hadoop和分布式数据库的对比"><a href="#Hadoop和分布式数据库的对比" class="headerlink" title="Hadoop和分布式数据库的对比"></a>Hadoop和分布式数据库的对比</h2><h4 id="存储多样性"><a href="#存储多样性" class="headerlink" title="存储多样性"></a>存储多样性</h4><p>Hadoop会以原始的形式手机数据，后续再处理数据模型的设计。而传统数据库必须提前设计好数据模型</p>
<p>不加区分的数据存储转移了负担：数据集生成者不需要强制转换为标准格式，数据的解释称为消费者的问题（如文档数据库）</p>
<h4 id="处理模型多样性"><a href="#处理模型多样性" class="headerlink" title="处理模型多样性"></a>处理模型多样性</h4><p>由于可以自定义编写各种处理函数，因此可以处理各种各样的数据模型</p>
<h4 id="针对频繁故障的设计"><a href="#针对频繁故障的设计" class="headerlink" title="针对频繁故障的设计"></a>针对频繁故障的设计</h4><p>两种设计思路：处理故障和使用内存磁盘的方式。</p>
<p>批处理是离线任务，故障敏感，因此不像MPP那样终止整个查询，而是以单个任务的粒度重试。</p>
<p>而且总是积极地将数据写入磁盘，一方面是容错另一方面是弥补能存不足</p>
<p>为何这样设计？是因为故障率往往会很高，不仅是硬件错误，更是软件问题（如k8s之类的优先级任务，应用不广）</p>
<h2 id="MapReduce-之后"><a href="#MapReduce-之后" class="headerlink" title="MapReduce 之后"></a>MapReduce 之后</h2><h3 id="物化中间状态"><a href="#物化中间状态" class="headerlink" title="物化中间状态"></a>物化中间状态</h3><p>materialization（物化）：将中间状态写入到文件的过程</p>
<p>MapReduce通常是全量物化，缺点？</p>
<ul>
<li>任务只能在前置任务都完成后才能执行</li>
<li>mapper往往是多余的，例如简单地读取reducer生成的数据</li>
<li>数据副本针对临时文件往往是多余的</li>
</ul>
<h3 id="工作流引擎"><a href="#工作流引擎" class="headerlink" title="工作流引擎"></a>工作流引擎</h3><p>将工作流显示地建模为数据从多个处理阶段通过，这样的系统成为数据流引擎(dataflow engines)</p>
<p>与MapReduce的不同（优点）？</p>
<ul>
<li>没有所谓的mapper、reducer。而是将每个函数成为operators（算子），引擎听过各种选项来链接各个算子</li>
<li>排序只在必要的地方执行</li>
<li>没有不必要的mapper</li>
<li>算子可以在数据就绪后就开始，而不是等待前置任务完全完成</li>
</ul>
<h4 id="容错"><a href="#容错" class="headerlink" title="容错"></a>容错</h4><p>通过将中间状态保存在文件系统上，故障时，通过其他节点的可用数据重新，若还不行则重新计算原始数据。</p>
<p>如何实现该机制？</p>
<ul>
<li><p>例如SPARK使用RDD来跟踪数据是如何计算的（使用了哪些分析，用来哪些算子等）</p>
</li>
<li><p>必须知道计算是否是确定性的，即给出相同输入，是否输出相同输出。若不确定，则下游算子将无法处理矛盾。通常对于不确定的算子，一般是杀死下游算子，并重新计算</p>
</li>
<li>针对大数据量的，则可以物化中间态。减少开销</li>
</ul>
<h4 id="关于物化"><a href="#关于物化" class="headerlink" title="关于物化"></a>关于物化</h4><p>类比Unix，MapReduce是将每个命令的输出写入文件来实现。</p>
<p>而如同flink之类的，则是基于管道思想，将算子的增量传递给其他算子，而无需等待输入完成。</p>
<h3 id="图与迭代处理"><a href="#图与迭代处理" class="headerlink" title="图与迭代处理"></a>图与迭代处理</h3><p>针对图的数据模型，如何处理？</p>
<h4 id="Pregel处理模型"><a href="#Pregel处理模型" class="headerlink" title="Pregel处理模型"></a>Pregel处理模型</h4><p>思想：一个顶点“发送消息“给另一个顶点，通常这些消息沿着图的边进行发送。</p>
<p>每次迭代，为每个顶点调用一个函数，将所有发送给它的消息再传递给他。不断迭代直到图处理完毕(与图处理算法的递归闭包处理方式类似)</p>
<h4 id="容错-1"><a href="#容错-1" class="headerlink" title="容错"></a>容错</h4><p>当开始下一个迭代时，前置的迭代必须完全结束，且所有消息都必须拷贝到所有其他顶点</p>
<h2 id="高级API和语言"><a href="#高级API和语言" class="headerlink" title="高级API和语言"></a>高级API和语言</h2><h3 id="像声明式转变"><a href="#像声明式转变" class="headerlink" title="像声明式转变"></a>像声明式转变</h3><p>尝试性地加入声明式是可行的，应用只是简单地说明那些链接是必须的，查询优化器绝地如何最好地执行链接。</p>
<p>引入声明式的部分，又保有原来的自定义算子的方式，将大大提高可用性。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>批处理：input数据是有界的，是一个已知的，固定大小的数据集合。</p>
<p>而流处理则是无界的，即，你任然有一个任务，但是输入数据是无限的</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://erenming.com/2020/09/05/【读书笔记】设计数据密集型应用-第二部分/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Eren Ming">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eren with you">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/09/05/【读书笔记】设计数据密集型应用-第二部分/" itemprop="url">【读书笔记】设计数据密集型应用-第二部分</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-09-05T17:24:59+08:00">
                2020-09-05
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/09/05/【读书笔记】设计数据密集型应用-第二部分/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/09/05/【读书笔记】设计数据密集型应用-第二部分/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>分布式数据，replication and partition</p>
<ul>
<li>Replication: keeping a <strong>copy</strong> of the same data on sevral differrent nodes, or in different locations</li>
<li>Partition: <strong>splittion</strong> a big databse into smaller subsets called partitions so that different partitions can be assigned to different nodes(called <em>sharding</em>)</li>
</ul>
<h1 id="第五章-复制"><a href="#第五章-复制" class="headerlink" title="第五章-复制"></a>第五章-复制</h1><p>复制的作用：</p>
<ul>
<li>数据物理上靠近用户</li>
<li>允许部分节点故障而系统正常，提高可靠性</li>
<li>水平扩展机器数可提高吞吐量</li>
</ul>
<h2 id="Leaders-and-Followers-单Leader"><a href="#Leaders-and-Followers-单Leader" class="headerlink" title="Leaders and Followers(单Leader)"></a>Leaders and Followers(单Leader)</h2><p>如何确保所有节点都获得数据？使用<em>leader-based replication</em>方案</p>
<ul>
<li>选择其中一个副本作为主节点，客户端的写请求必须通过leader</li>
<li>其他副本作为从节点，leader收到请求并发送relication log给followers。followers获取到后再写数据</li>
<li>读请求可通过任何节点读取</li>
</ul>
<p>MySQL、PostgreSQL，Kafka等均通过该方案实现</p>
<h2 id="同步还是异步复制"><a href="#同步还是异步复制" class="headerlink" title="同步还是异步复制"></a>同步还是异步复制</h2><p>同步复制：主节点等待从节点写入数据完成</p>
<p>异步复制：主节点不等待从节点写入数据完成，而直接返回</p>
<p>优缺点：</p>
<ul>
<li>同步优点：能确保从节点的数据与主节点保持一致性</li>
<li>同步缺点：主从节点之间由于各种原因，导致写操作阻塞。从而阻塞后续的写请求</li>
</ul>
<p>通常，主节点与一个从节点保持同步，与其他保持异步。而实际中，完全异步的架构也是很普遍的，这可能会导致数据丢失，可通过<em>共识</em>解决</p>
<h2 id="设置新的Followers"><a href="#设置新的Followers" class="headerlink" title="设置新的Followers"></a>设置新的Followers</h2><p>简单地拷贝数据是不可行的，因为数据是在不断变化的。也许能锁磁盘来解决，但是显然会影响性能。</p>
<ol>
<li>主节点创建自身快照</li>
<li>复制快照到从节点</li>
<li>新的从节点请求从快照创建时间点之后的数据并写入</li>
<li>follower处理完back log之后，我们为<em>caught up</em></li>
</ol>
<h2 id="处理节点宕机"><a href="#处理节点宕机" class="headerlink" title="处理节点宕机"></a>处理节点宕机</h2><h3 id="Follower-failure：Catch-up-recovery"><a href="#Follower-failure：Catch-up-recovery" class="headerlink" title="Follower failure：Catch-up recovery"></a>Follower failure：Catch-up recovery</h3><p>根据log，节点知道失败前的最后一个事务的具体时间点，follower恢复后只需向主节点请求改时间点之后的数据即可。</p>
<h3 id="Leader-failure-Failure-故障切换"><a href="#Leader-failure-Failure-故障切换" class="headerlink" title="Leader failure: Failure(故障切换)"></a>Leader failure: Failure(故障切换)</h3><p>自动流程：</p>
<ol>
<li>确认leader失败。很简单，超时-心跳机制</li>
<li><p>选择个一个新leader。通过其他节点或者控制器选举leader，通常来说是拥有数据最新的（减少数据丢失）</p>
</li>
<li><p>使用leader重新配置整个系统。系统需要保证原leader只能变成follower并认同新leader</p>
</li>
</ol>
<p>潜在问题：</p>
<ul>
<li>原leader拥有未同步的数据，重新加入集群后，跟新leader的数据会有冲突。通过丢去未同步的数据处理，持久性未满足</li>
<li>抛弃数据造成灾难，尤其是与其他系统协作时</li>
<li>某些情况下，两个节点认为自身为leader，我们成为<em>split brain</em>(脑裂)</li>
<li>判定leader失败的超时时间多少合适？网络、负载等等原因都会影响心跳时间</li>
</ul>
<h2 id="Implementation-of-Replication-Logs"><a href="#Implementation-of-Replication-Logs" class="headerlink" title="Implementation of Replication Logs"></a>Implementation of Replication Logs</h2><p>介绍Leader-based replication 是如何实现的</p>
<h3 id="statement-based-replication"><a href="#statement-based-replication" class="headerlink" title="statement-based replication"></a>statement-based replication</h3><p>leader记录每条写请求(statement，语句)，并发送给followers。听起来很简单，但是缺点也多</p>
<ul>
<li>任何非确定性的语句都会有问题，例如NOW()函数</li>
<li>语句如果存在顺序关系，例如<code>UPDATE</code>操作，也会存在问题（除非保证顺序）</li>
<li>语句有副作用，例如触发器，存储过程等</li>
</ul>
<h3 id="Write-ahead-log-WAL-传输"><a href="#Write-ahead-log-WAL-传输" class="headerlink" title="Write-ahead log(WAL) 传输"></a>Write-ahead log(WAL) 传输</h3><p>诸如基于log-structure以及B-Tree的数据库，都会有有一个append-only log。</p>
<p>leader将数据的log发送到各个followers，follower再通过它建立一个与leader一样的copy。广泛应用PostgreSQL等</p>
<p>缺点：</p>
<ul>
<li>log记录的数据过于底层，例如包含哪些磁盘中的哪些字节改变。</li>
<li>数据库版本升级时，版本之间并不兼容，需要停机升级</li>
</ul>
<h3 id="Logical-row-based-log-replication"><a href="#Logical-row-based-log-replication" class="headerlink" title="Logical(row-based)log replication"></a>Logical(row-based)log replication</h3><p>替代底层log，而使用逻辑上的log来表示，其通常是一系列的记录来代表写请求。例如插入，log则包含所有列的新值。</p>
<p>由于其与底层存储解耦了，因此易于兼容不同版本，且能被外部系统解析使用。应用于MySQL中的binlog等</p>
<h3 id="Trigger-based-replication"><a href="#Trigger-based-replication" class="headerlink" title="Trigger-based replication"></a>Trigger-based replication</h3><p>上述均为数据库底层实现，若需要更高的灵活性，则可使用trigger-based的方式。它让你注册一些用户代码，在数据变化时自动触发执行</p>
<h2 id="Porblems-with-Replication-Lag"><a href="#Porblems-with-Replication-Lag" class="headerlink" title="Porblems with Replication Lag"></a>Porblems with Replication Lag</h2><p>relication lag：the delay between a write happening on the leader and being reflected on a follower(leader与follower之间的数据延迟)</p>
<p>通常来说，followers的数据经常会落后于leader，这种状态通常很短。但是一旦lag过长，则会出大问题。如何解决？</p>
<h3 id="Reading-Your-Owen-Writes"><a href="#Reading-Your-Owen-Writes" class="headerlink" title="Reading Your Owen Writes"></a>Reading Your Owen Writes</h3><p><img src="https://github.com/Vonng/ddia/raw/master/img/fig5-3.png" alt="img"></p>
<p>用户修改了，再次查询时可能还是老的。</p>
<p>使用<em>read-after-write consistency</em> 、或称为<code>read-your-writes consistency</code>来保证一致性，即保证用户再次查询时能查到其更新的，这对其他用户不保证。</p>
<p>方案：</p>
<ul>
<li>当获取某些刚修改的数据时，只通过leader查询</li>
<li>常见情况下，可对数据标记，例如更新时间，若更新时间小于1分钟，则从leader中读取</li>
<li>客户端记住最近写的时间戳，然后判读读取</li>
</ul>
<h3 id="单调读"><a href="#单调读" class="headerlink" title="单调读"></a>单调读</h3><p><img src="https://github.com/Vonng/ddia/raw/master/img/fig5-4.png" alt="img"></p>
<p>由于同步时间的不确定性，用户可能发现修改了的数据又复原了，出现时光倒流现象。</p>
<p><em>monotonic reads</em>，使用单调读技术来确保这种情况不会发生。</p>
<p>方案：确保每个用户总是从单个副本中读取</p>
<h3 id="Consistent-Prefix-Reads"><a href="#Consistent-Prefix-Reads" class="headerlink" title="Consistent Prefix Reads"></a>Consistent Prefix Reads</h3><p><img src="https://github.com/Vonng/ddia/raw/master/img/fig5-5.png" alt="img"></p>
<p>本来带有顺序含义的语句，由于复制延迟，第三方观测下顺序异常导致的混乱。例如，聊天的对话顺序</p>
<p>使用<em>consistent prefix reads</em>(一致性前缀读)来避免。</p>
<p>方案：</p>
<ul>
<li>保证任何因果关系的写入都写入到同一个partition。</li>
<li>显式跟踪因果依赖关系的算法。例如<em>happens-before</em>技术</li>
</ul>
<h2 id="Solution-for-Replication-Lag"><a href="#Solution-for-Replication-Lag" class="headerlink" title="Solution for Replication Lag"></a>Solution for Replication Lag</h2><p>使用最终一致性以及分布式事务等</p>
<h2 id="Multi-Leader-Replication-多主复制"><a href="#Multi-Leader-Replication-多主复制" class="headerlink" title="Multi-Leader Replication(多主复制)"></a>Multi-Leader Replication(多主复制)</h2><p>单Leader缺点：所有写入必须经过它。</p>
<p>多Leader缺点：同一数据可能会在不同数据中心被同时处理，需要解决因此带来的<strong>冲突</strong>。</p>
<p>多leader下，每个leader都担任其他leader的follower</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li>性能：多数据中心下，写请求被本地数据中心处理，随后与其他数据中心异步复制</li>
<li>可用性：能有效容忍某个数据中心挂掉</li>
<li><p>网络性能：数据中心间的网络往往很拥堵且不稳定，单leader无法应对，而多leader至少本地能处理用户请求</p>
</li>
<li><p>客户端离线操作：客户端(例如手机设备等)本机类比作为一个datacenter</p>
</li>
<li>协同编辑：多人协同编辑应用，每个设备都类比作为一个datacenter</li>
</ul>
<h3 id="处理写冲突"><a href="#处理写冲突" class="headerlink" title="处理写冲突"></a>处理写冲突</h3><h4 id="避免写冲突"><a href="#避免写冲突" class="headerlink" title="避免写冲突"></a>避免写冲突</h4><p>同一地区或者同一一批设备的写请求都通过同一leader写入。例如通过hash路由的方式等</p>
<h4 id="收敛到一致的状态"><a href="#收敛到一致的状态" class="headerlink" title="收敛到一致的状态"></a>收敛到一致的状态</h4><p>通过一些方法将不同状态的数据收敛到同一状态。</p>
<p>方案：</p>
<ul>
<li>使用LWW(last write wins)技术，即每次写入都绑定一个唯一ID（UUID，时间戳等），选择最大的ID并丢弃其他</li>
<li>给副本绑定ID，选择ID大的副本里的数据</li>
<li>通过某种方式合并，例如字母顺序最大者</li>
<li>或者用数据结构保留冲突，提示用户自己解决</li>
</ul>
<h4 id="自定义冲突解决"><a href="#自定义冲突解决" class="headerlink" title="自定义冲突解决"></a>自定义冲突解决</h4><p>允许用户编写冲突解决逻辑，并在读、写操作是执行。</p>
<ul>
<li>写时：只要检测到冲突即会执行</li>
<li>读时：检测到冲突，会保存所有冲突。用户读取时，提示用户解决，并回写结果。</li>
</ul>
<h3 id="拓扑结构"><a href="#拓扑结构" class="headerlink" title="拓扑结构"></a>拓扑结构</h3><p><img src="https://github.com/Vonng/ddia/raw/master/img/fig5-8.png" alt="img"></p>
<ul>
<li>环形：节点收到来自前一个节点的写请求并传递给下一个节点</li>
<li>星形：一个指定的节点传递给掐所有节点</li>
<li>All-to-all：<ul>
<li>优点：能避免环形以及星形的单点故障影响其他节点的问题</li>
<li>缺点：节点间网络的速率不同，一些复制消息将超过其他消息</li>
</ul>
</li>
</ul>
<h2 id="Leaderless-Replication-无主复制"><a href="#Leaderless-Replication-无主复制" class="headerlink" title="Leaderless Replication(无主复制)"></a>Leaderless Replication(无主复制)</h2><p>无主复制中，写请求通常是直接发送到所有副本中，或者通过coordinator代表客户端写入。</p>
<h4 id="单节点故障时写入"><a href="#单节点故障时写入" class="headerlink" title="单节点故障时写入"></a>单节点故障时写入</h4><p>无主复制中，故障切换是不存在的。节点故障时，只要剩余节点能承认写入即可。</p>
<p>当原节点恢复，将会存在数据不一致的现象，如何解决？</p>
<blockquote>
<p>客户端接收所有副本的返回数据，并选择最新的。通常使用Version numbers来确定</p>
</blockquote>
<h4 id="Read-pair-and-anti-entropy"><a href="#Read-pair-and-anti-entropy" class="headerlink" title="Read pair and anti-entropy"></a>Read pair and anti-entropy</h4><h5 id="Read-repair"><a href="#Read-repair" class="headerlink" title="Read repair"></a>Read repair</h5><p>客户端读取并行所有节点的数据，能检测到stale responses，并回写新数据到老节点</p>
<h5 id="Anti-entropy-process"><a href="#Anti-entropy-process" class="headerlink" title="Anti-entropy process"></a>Anti-entropy process</h5><p>后台进程不断地检测不同节点检测数据差异，并补齐。</p>
<h3 id="Quorums-法定人数-for-reading-and-writing"><a href="#Quorums-法定人数-for-reading-and-writing" class="headerlink" title="Quorums(法定人数) for reading and writing"></a>Quorums(法定人数) for reading and writing</h3><p>定义：只要<code>w + r &gt; n</code>，则客户端总能获得最新的数据。遵守该规则的r与w称为<em>quorums read and write</em></p>
<blockquote>
<p>n: 副本数；r: 读请求时，至少得有r个节点能返回数据；w: 写请求至少要被w个节点确认</p>
</blockquote>
<h3 id="Quorums的局限性"><a href="#Quorums的局限性" class="headerlink" title="Quorums的局限性"></a>Quorums的局限性</h3><ul>
<li>如果两个写入同时发生，不清楚哪一个先发生。</li>
<li>如果写操作在某些副本上成功，而在其他节点上失败（例如，因为某些节点上的磁盘已满），在小于w个副本上写入成功</li>
<li>如果携带新值的节点失败，需要读取其他带有旧值的副本。</li>
</ul>
<p>Dynamo风格可以忍受最终一致性，但是无法绝对保证。更强有力的保证通常需要<strong>事务</strong>或<strong>共识</strong></p>
<h4 id="监控staleness-陈旧度"><a href="#监控staleness-陈旧度" class="headerlink" title="监控staleness(陈旧度)"></a>监控staleness(陈旧度)</h4><p>监视你的数据库是否返回最新的结果是很重要的，如果显著落后，应该提醒您，以便您可以调查原因（例如，网络中的问题或超载节点）。</p>
<h3 id="Sloppy-Quorums-and-Hinted-Handoff"><a href="#Sloppy-Quorums-and-Hinted-Handoff" class="headerlink" title="Sloppy Quorums and Hinted Handoff"></a>Sloppy Quorums and Hinted Handoff</h3><p>写和读仍然需要w和r成功的响应, 只不过把把一些请求暂时寄宿在可达节点上，等不可达节点恢复后再传递到目标节点上</p>
<h3 id="多数据中心"><a href="#多数据中心" class="headerlink" title="多数据中心"></a>多数据中心</h3><p>自然支持，quorums只需在一个数据中心满足即可。</p>
<h3 id="检测并发写"><a href="#检测并发写" class="headerlink" title="检测并发写"></a>检测并发写</h3><p>Dynamo-stype允许客户端并发写同一key。存在事件以不同顺序到达不同的节点。</p>
<p><img src="https://github.com/Vonng/ddia/raw/master/img/fig5-12.png" alt="img"></p>
<p>如果每个节点只是简单地覆盖对应key的值，则会出现不一致现象。因此需要解决冲突</p>
<h4 id="Last-wirte-wins-discharding-current-wirtes"><a href="#Last-wirte-wins-discharding-current-wirtes" class="headerlink" title="Last wirte wins(discharding current wirtes)"></a>Last wirte wins(discharding current wirtes)</h4><p>保存”recent”值，并允许“older”值被覆盖或丢弃。使用一些标识来区分”rencent”以及”older”</p>
<h4 id="The-“happens-before”-relationship-and-concurrency"><a href="#The-“happens-before”-relationship-and-concurrency" class="headerlink" title="The “happens-before” relationship and concurrency"></a>The “happens-before” relationship and concurrency</h4><p>只要有两个操作A和B，就有三种可能性：A在B之前发生，或者B在A之前发生(因果关系)，或者A和B并发。</p>
<p>如果一个操作发生在另一个操作之前，则后面的操作应该覆盖较早的操作，但是如果这些操作是并发的，则存在需要解决的冲突。</p>
<h4 id="捕获”happens-before”关系"><a href="#捕获”happens-before”关系" class="headerlink" title="捕获”happens-before”关系"></a>捕获”happens-before”关系</h4><p><img src="https://github.com/Vonng/ddia/raw/master/img/fig5-13.png" alt="img"></p>
<h4 id="合并同时写入的值"><a href="#合并同时写入的值" class="headerlink" title="合并同时写入的值"></a>合并同时写入的值</h4><p>如果多个操作并发发生，则客户端必须通过合并并发写入的值来擦屁股。</p>
<h4 id="版本向量"><a href="#版本向量" class="headerlink" title="版本向量"></a>版本向量</h4><p>使用单个版本号(上图)来捕获操作之间的依赖关系，但是当多个副本并发接受写入时，这是不够的。</p>
<p> 所有副本的版本号集合称为<strong>版本向量（version vector）</strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>单主复制是非常流行的，因为它很容易理解，不需要担心冲突解决。在出现故障节点，网络中断和延迟峰值的情况下，多领导者和无领导者复制可以更加稳健，但以更难以推理并仅提供非常弱的一致性保证为代价。</p>
<p>多领导者和无领导者复制方法所固有的并发问题：因为他们允许多个写入并发发生冲突。我们研究了一个数据库可能使用的算法来确定一个操作是否发生在另一个操作之前，或者它们是否同时发生。</p>
<h1 id="第六章-分区"><a href="#第六章-分区" class="headerlink" title="第六章-分区"></a>第六章-分区</h1><p>复制提高了数据容错性。</p>
<p>但是当数据量大，且查询吞吐量大时，我就必须把数据拆开并分布到不同分区上(partitions or sharding)。这体现了可扩展性</p>
<h3 id="分区与复制"><a href="#分区与复制" class="headerlink" title="分区与复制"></a>分区与复制</h3><p>分区与复制往往是同时存在的，同一个分区有多个副本，多个副本归属不同分区</p>
<h3 id="Key-Value-类数据的分区"><a href="#Key-Value-类数据的分区" class="headerlink" title="Key-Value 类数据的分区"></a>Key-Value 类数据的分区</h3><p>偏斜(skewed): 分区不公平，导致部分分区拥有较多的数据和查询压力</p>
<p>热点(hopt spot): 由于分区不公平，部分节点承受了过高的负载</p>
<p>如何避免不公平的现象呢？</p>
<h4 id="通过Key-Range分区"><a href="#通过Key-Range分区" class="headerlink" title="通过Key Range分区"></a>通过Key Range分区</h4><p>将连续的keys划分成多个段，并分配个每个分区。如下图的单词分区</p>
<p><img src="https://github.com/Vonng/ddia/raw/master/img/fig6-2.png" alt="img"></p>
<p>为了避免skewed，需要针对数据实际分布来分区。例如单词始子母，书籍1只有A,B，而书籍12却有TUVWXYZ</p>
<p>优点：可以让keys保持排序，这样范围查询将变得很容易</p>
<p>缺点：特定的访问模式容易导致热点现象。</p>
<blockquote>
<p>比如时间戳作为key，按天分区，则当天的时序数据都会往同一分区写，造成热点。此时你可以选择数据源作为key</p>
</blockquote>
<h4 id="通过Hash-of-Key-分区"><a href="#通过Hash-of-Key-分区" class="headerlink" title="通过Hash of Key 分区"></a>通过Hash of Key 分区</h4><p>通过给定key的哈希值来决定分区。已知哈希值的范围后，再按分数区划分范围来指定分区。</p>
<p><img src="https://github.com/Vonng/ddia/raw/master/img/fig6-3.png" alt="img"></p>
<p>有点：分区公平</p>
<p>缺点：范围查询困难</p>
<p>折中方案：使用<em>compound primary key</em>(组合主键)，即将多个列组合成一个key。其中key中的第一部分取用hash后分区，剩余部分做为排序所用的连接索引</p>
<h3 id="负载倾斜与消除热点"><a href="#负载倾斜与消除热点" class="headerlink" title="负载倾斜与消除热点"></a>负载倾斜与消除热点</h3><p>尽管hash的方法能帮助减少热点，但并不能完全避免。比如微博明星出轨现象，对同一key的大量请求，同样会造成热点现象。</p>
<p>这只能应用程序自己处理，例如在key前面或者后面append上随机数字。当然有利必有弊，这将导致其他低吞吐量的key产生不必要的性能损耗</p>
<h3 id="分区以及二级索引"><a href="#分区以及二级索引" class="headerlink" title="分区以及二级索引"></a>分区以及二级索引</h3><h4 id="基于文档分区二级索引"><a href="#基于文档分区二级索引" class="headerlink" title="基于文档分区二级索引"></a>基于文档分区二级索引</h4><p>有利于写，不利于读</p>
<p><img src="https://github.com/Vonng/ddia/raw/master/img/fig6-4.png" alt="img"></p>
<p>每个分区维护自身的二级索引，并覆盖自身分区内的所有文档数据。因此又称，本地索引(<em>local index</em>)</p>
<p>缺点：</p>
<ul>
<li>索引往往会分布在多个分区里。在读取时，会造成<strong>分散/聚集（scatter/gather）</strong>现象，读取二级索引较为低效。</li>
</ul>
<h4 id="基于关键词-Term-分区二级索引"><a href="#基于关键词-Term-分区二级索引" class="headerlink" title="基于关键词(Term)分区二级索引"></a>基于关键词(Term)分区二级索引</h4><p>有利于读，不利于写</p>
<p><img src="https://github.com/Vonng/ddia/raw/master/img/fig6-5.png" alt="img"></p>
<p><strong>关键词分区（term-partitioned）</strong>，因为我们寻找的关键词决定了索引的分区方式。是一种全局的分区方式，又称<strong>全局索引</strong></p>
<p>优点：使读取更有效率：不需要<strong>分散/收集</strong>所有分区，客户端只需要向包含关键词的分区发出请求</p>
<p>缺点：写入速度较慢且较为复杂，因为写入单个文档现在可能会影响索引的多个分区。而且，通常更新全局二级索引都是异步的，你写入后查询并不能立即生效</p>
<h3 id="分区再平衡"><a href="#分区再平衡" class="headerlink" title="分区再平衡"></a>分区再平衡</h3><p>定义：更改都需要数据和请求从一个节点移动到另一个节点。 将负载从集群中的一个节点向另一个节点移动的过程，称为称为<strong>再平衡（reblancing）</strong></p>
<p>最低要求：</p>
<ul>
<li>再平衡之后，负载（数据存储，读取和写入请求）应该在集群中的节点之间公平地共享。</li>
<li>再平衡发生时，数据库应该继续接受读取和写入。</li>
<li>节点之间只移动必须的数据，以便快速再平衡，并减少网络和磁盘I/O负载。</li>
</ul>
<h3 id="平衡策略"><a href="#平衡策略" class="headerlink" title="平衡策略"></a>平衡策略</h3><h4 id="反面教材：hash-mod-N"><a href="#反面教材：hash-mod-N" class="headerlink" title="反面教材：hash mod N"></a>反面教材：hash mod N</h4><p>为什么我们不使用<strong><em>mod</em></strong>（许多编程语言中的％运算符）？</p>
<p>因为，如果节点数量N发生变化，大多数密钥将需要从一个节点移动到另一个节点，这过于昂贵了</p>
<h4 id="固定数量的分区"><a href="#固定数量的分区" class="headerlink" title="固定数量的分区"></a>固定数量的分区</h4><p>创建比节点更多的分区，并为每个节点分配多个分区</p>
<p>如果一个节点被添加到集群中，新节点可以从当前每个节点中<strong>窃取</strong>一些分区，直到分区再次公平分配。</p>
<p><img src="https://github.com/Vonng/ddia/raw/master/img/fig6-6.png" alt="img"></p>
<p>优点：简单</p>
<p>缺点： 如果数据集的总大小难以预估，选择正确的分区数是困难的。</p>
<blockquote>
<p>如果分区非常大，再平衡和从节点故障恢复变得昂贵。但是，如果分区太小，则会产生太多的开销。</p>
</blockquote>
<h4 id="动态分区"><a href="#动态分区" class="headerlink" title="动态分区"></a>动态分区</h4><p>当分区增长到超过配置的大小时，会被分成两个分区，每个分区约占一半的数据。与之相反，如果大量数据被删除并且分区缩小到某个阈值以下，则可以将其与相邻分区合并。此过程与B树底层发生的过程类似</p>
<p>注意，数据集开始时很小，直到达到第一个分区的分割点，所有写入操作都必须由单个节点处理，而其他节点则处于空闲状态。使用<strong>预分割（pre-splitting）</strong>避免</p>
<p>优点：分区数量适应总数据量</p>
<h4 id="按节点比例分区"><a href="#按节点比例分区" class="headerlink" title="按节点比例分区"></a>按节点比例分区</h4><p>使分区数与节点数成正比，即每个节点具有固定数量的分区。</p>
<p>当一个新节点加入集群时，它随机选择固定数量的现有分区进行拆分，然后获取每个分区的一半数据，另外一半保留。</p>
<p>随机化可能会产生不公平的分区，可以通过增大分区数来平均化(Cassandra每个节点默认就256个分区)</p>
<h3 id="运维：手动还是自动平衡"><a href="#运维：手动还是自动平衡" class="headerlink" title="运维：手动还是自动平衡"></a>运维：手动还是自动平衡</h3><p>全自动重新平衡可以很方便，但是自动化与自动故障检测相结合可能十分危险。例如误判过载的节点已经死亡</p>
<h2 id="请求路由"><a href="#请求路由" class="headerlink" title="请求路由"></a>请求路由</h2><p>当客户想要发出请求时，如何知道要连接哪个节点？使用<strong>服务发现(service discovery)</strong> 技术</p>
<p><img src="https://github.com/Vonng/ddia/raw/master/img/fig6-7.png" alt="img"></p>
<p>挑战：无论如何，所有参与者都同意路由规则，否则请求将被发送到错误的节点。</p>
<p>方案一：</p>
<p>许多分布式数据系统都依赖于一个独立的协调服务，比如ZooKeeper来跟踪集群元数据。</p>
<ul>
<li>每个节点在ZooKeeper中注册自己，ZooKeeper维护分区到节点的可靠映射</li>
<li>只要分区分配发生的改变，或者集群中添加或删除了一个节点，ZooKeeper就会通知路由层使路由信息保持最新状态。</li>
</ul>
<p>方案二：</p>
<p>在节点之间使用<strong>流言协议（gossip protocol）</strong> 来传播群集状态的变化。</p>
<ul>
<li>请求可以发送到任意节点，该节点会转发到包含所请求的分区的适当节点。如上图中的方法1</li>
</ul>
<h3 id="执行并行查询"><a href="#执行并行查询" class="headerlink" title="执行并行查询"></a>执行并行查询</h3><p><strong>大规模并行处理（MPP, Massively parallel processing）</strong>，MPP查询优化器将这个复杂的查询分解成许多执行阶段和分区，其中许多可以在数据库集群的不同节点上并行执行</p>
<h1 id="第七章-事务"><a href="#第七章-事务" class="headerlink" title="第七章-事务"></a>第七章-事务</h1><p>事务是应用程序将多个读写操作组合成一个逻辑单元的一种方式，整个事务要么成功（<strong>提交（commit）</strong>）要么失败（<strong>中止（abort）</strong>，<strong>回滚（rollback）</strong>）。如果失败，应用程序可以安全地重试。</p>
<p>提供一层抽象，给应用程序一种并发、软硬件问题均不会存在的假象。</p>
<h2 id="ACID的含义"><a href="#ACID的含义" class="headerlink" title="ACID的含义"></a>ACID的含义</h2><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>一般来说，原子是指不能分解成小部分的东西。</p>
<p>在多线程编程中，如果一个线程执行一个原子操作，这意味着另一个线程无法看到该操作的一半结果。</p>
<p>ACID的原子性中，描述了当客户想进行多次写入，在一些写操作处理完之后出现故障时，<strong>能够在错误时中止事务，丢弃该事务进行的所有写入变更的能力</strong></p>
<h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p>ACID的上下文中，<strong>一致性</strong>是指数据库在应用程序的特定概念中处于“良好状态”</p>
<p><strong>you have certain statements about your data that must always be true</strong>, 比如在会计系统中，所有账户整体上必须借贷相抵</p>
<p>原子性，隔离性和持久性是数据库的属性，而一致性（在ACID意义上）是应用程序的属性</p>
<h3 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h3><p><strong>同时执行的事务是相互隔离的</strong>：它们不能相互冒犯</p>
<h3 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h3><p><strong>持久性</strong> 是一个承诺，即一旦事务成功完成，即使发生硬件故障或数据库崩溃，写入的任何数据也不会丢失。</p>
<h2 id="单对象和多对象操作"><a href="#单对象和多对象操作" class="headerlink" title="单对象和多对象操作"></a>单对象和多对象操作</h2><p>多对象事务需要某种方式来确定哪些读写操作属于同一个事务，在关系型数据库中，通常基于客户端与数据库服务器的TCP连接：在任何特定连接上，<code>BEGIN TRANSACTION</code> 和 <code>COMMIT</code> 语句之间的所有内容，被认为是同一事务的一部分。</p>
<h3 id="单对象写入"><a href="#单对象写入" class="headerlink" title="单对象写入"></a>单对象写入</h3><p>对单节点上的单个对象（例如键值对）上提供原子性和隔离性</p>
<h3 id="多对象事务的需求"><a href="#多对象事务的需求" class="headerlink" title="多对象事务的需求"></a>多对象事务的需求</h3><p>场景：</p>
<ul>
<li>在关系数据模型中，一个表中的行通常具有对另一个表中的行的外键引用</li>
<li>当需要更新非规范化的信息时，需要一次更新多个文档</li>
<li>每次更改值时都需要更新索引</li>
</ul>
<p>针对多对象，<strong>若没有原子性，错误处理就要复杂得多，若缺乏隔离性，就会导致并发问题</strong></p>
<h3 id="处理错误和中止"><a href="#处理错误和中止" class="headerlink" title="处理错误和中止"></a>处理错误和中止</h3><p>事务的一个关键特性是，如果发生错误，它可以中止并安全地重试。如若未被ACID，则会终止整个事务，而不是保留半完成的状态</p>
<p>然而，有些数据库则选择，做尽可能多的事，运行遇到错误时，它不会撤消它已经完成的事情，此时，从错误中恢复就是应用程序的责任了。</p>
<p>中止重试的潜在问题：</p>
<ul>
<li>如果事务实际上成功了，但是在服务器试图向客户端确认提交成功时网络发生故障，那么重试事务会导致事务被执行两次</li>
<li>重试事务将使负载过大变得更糟</li>
<li>仅在临时性错误（例如，由于死锁，异常情况，临时性网络中断和故障切换）后才值得重试。在发生永久性错误（例如，违反约束）之后重试是毫无意义的。</li>
<li>如果事务在数据库之外也有副作用，即使事务被中止，也可能发生这些副作用</li>
<li>如果客户端进程在重试中失效，任何试图写入数据库的数据都将丢失。</li>
</ul>
<h2 id="弱隔离级别"><a href="#弱隔离级别" class="headerlink" title="弱隔离级别"></a>弱隔离级别</h2><p>当一个事务读取由另一个事务同时修改的数据时，或者当两个事务试图同时修改相同的数据时，并发问题（竞争条件）才会出现。而且并发BUG很难通过测试找到。</p>
<p>因此，数据库提供了<strong>事务隔离（transaction isolation）</strong> 来隐藏应用程序开发者的并发问题。</p>
<p><strong>可序列化（serializable）</strong> 的隔离等级意味着数据库保证事务的效果如同连续运行。</p>
<p>然而，为了性能，系统通常使用较弱的隔离级别来防止一部分，而不是全部的并发问题</p>
<h3 id="读已提交-Read-Commited"><a href="#读已提交-Read-Commited" class="headerlink" title="读已提交(Read Commited)"></a>读已提交(Read Commited)</h3><p>保证：</p>
<ul>
<li>从数据库读时，只能看到已提交的数据（没有<strong>脏读（ no dirty reads）</strong>）</li>
<li>写入数据库时，只会覆盖已经写入的数据（没有<strong>脏写（no dirty writes）</strong>）。</li>
</ul>
<h4 id="No-dirty-reads"><a href="#No-dirty-reads" class="headerlink" title="No dirty reads"></a>No dirty reads</h4><p>脏读(dirty reads): 假定一个事务已经将一些数据写入数据库，但事务还没有提交或中止。另一个事务可以看到未提交的数据吗？如果是的话，那就叫做<strong>脏读</strong></p>
<p>避免脏读的原因：</p>
<ul>
<li>如果事务需要更新多个对象，脏读取意味着另一个事务可能会只看到一部分更新</li>
<li>如果事务中止，则所有写入操作都需要回滚，若数据库允许脏读，就意味着一个事务可能会看到稍后需要回滚的数据，即从未实际提交给数据库的数据。</li>
</ul>
<h4 id="No-dirty-writes"><a href="#No-dirty-writes" class="headerlink" title="No dirty writes"></a>No dirty writes</h4><p>如果两个事务同时尝试更新数据库中的相同对象，会发生什么情况？通常认为后面的写入会覆盖前面的写入。如果先前的写入是尚未提交事务的一部分，又会发生什么情况，后面的写入会覆盖一个尚未提交的值？这被称作<strong>脏写</strong>。</p>
<p>在<strong>读已提交</strong>的隔离级别上运行的事务必须防止脏写，通常是延迟第二次写入，直到第一次写入事务提交或中止为止。</p>
<p>避免脏写的原因：</p>
<ul>
<li>如果事务更新多个对象，脏写会导致不好的结果，比如，来自不同事务的冲突写入可能会混淆在一起。</li>
<li>Read commited并不能防止两个计数器增量之间的竞争状态。</li>
</ul>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>防止脏写: </p>
<blockquote>
<p> 使用<strong>行锁（row-level lock）</strong>，当事务想要修改特定对象（row or ducument）时，它必须首先获得该对象的锁。然后必须持有该锁直到事务被提交或中止。一次只有一个事务可持有任何给定对象的锁；如果另一个事务要写入同一个对象，则必须等到第一个事务提交或中止后，才能获取该锁并继续。</p>
</blockquote>
<p>防止脏读：</p>
<blockquote>
<p>也可以用锁，不过有性能问题，不采用。因此，通常对于写入的每个对象，数据库都会记住旧的已提交值，和由当前持有写入锁的事务设置的新值。当事务正在进行时，任何其他读取对象的事务都会拿到旧值。 只有当新值提交后，事务才会切换到读取新值。</p>
</blockquote>
<h3 id="快照隔离和可重复读"><a href="#快照隔离和可重复读" class="headerlink" title="快照隔离和可重复读"></a>快照隔离和可重复读</h3><p><img src="https://github.com/Vonng/ddia/raw/master/img/fig7-6.png" alt="img"></p>
<p>这种异常被称为<strong>不可重复读（nonrepeatable read）\</strong>或**读取偏差（read skew）**。</p>
<p>对于read commited来说，这种情况是可容忍的，然而以下情况则不可</p>
<ul>
<li>备份，备份进程运行时，数据库仍然会接受写入操作。因此备份可能会包含一些旧的部分和一些新的部分。</li>
<li>分析查询和完整性检查，一个查询，扫描大部分的数据库，查询在不同时间点观察数据库的不同部分，则可能会返回毫无意义的结果</li>
</ul>
<p>使用<strong>快照隔离（snapshot isolation）</strong>，每个事务都从数据库的<strong>一致快照（consistent snapshot）</strong> 中读取。也就是说，事务可以看到事务开始时在数据库中提交的所有数据。即使这些数据随后被另一个事务更改，每个事务也<strong>只能</strong>看到该特定时间点的旧数据。</p>
<h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>也通常使用写锁来防止脏写，这意味着进行写入的事务会阻止另一个事务修改同一个对象。但是读取不需要任何锁定。性能角度，<strong>读不阻塞写，写不阻塞读</strong></p>
<p>数据库必须可能保留一个对象的几个不同的提交版本，因为各种正在进行的事务可能需要看到数据库在不同的时间点的状态。因为它并排维护着多个版本的对象，所以这种技术被称为<strong>多版本并发控制（MVCC, multi-version concurrentcy control）</strong>。</p>
<p><img src="https://github.com/Vonng/ddia/raw/master/img/fig7-7.png" alt="img"></p>
<p>表中的每一行都有一个 <code>created_by</code> 字段，其中包含将该行插入到表中的的事务ID。</p>
<p>每行都有一个 <code>deleted_by</code> 字段，删除时，将 <code>deleted_by</code> 字段设置为请求删除的事务的ID来标记为删除。其中，update转换为一个delete和create</p>
<h4 id="一致性快照的可见性规则"><a href="#一致性快照的可见性规则" class="headerlink" title="一致性快照的可见性规则"></a>一致性快照的可见性规则</h4><p>当一个事务从数据库中读取时，事务ID用于决定它可以看见哪些对象，看不见哪些对象。工作流程：</p>
<ol>
<li>在每次事务开始时，数据库列出当时所有其他在运行（尚未提交或尚未中止）的事务清单，即使在它之后提交了，这些事务已执行的任何写入也都会被忽略。</li>
<li>被已中止的事务所执行的任何写入都将被忽略。</li>
<li>由具有较晚事务ID（即，在当前事务开始之后开始的）的事务所做的任何写入都被忽略，而不管这些事务是否已经提交。</li>
<li>所有其他写入，对应用都是可见的。</li>
</ol>
<p>一个对象可见的条件：</p>
<ul>
<li>读事务开始时，创建该对象的事务已经提交。</li>
<li>对象未被标记为删除，或如果被标记为删除，请求删除的事务在读事务开始时尚未提交。</li>
</ul>
<h4 id="索引和快照隔离"><a href="#索引和快照隔离" class="headerlink" title="索引和快照隔离"></a>索引和快照隔离</h4><p>索引如何在多版本数据库中工作？一种选择是使索引简单地指向对象的所有版本，并且需要索引查询来过滤掉当前事务不可见的任何对象版本</p>
<h4 id="可重复读与命名混淆"><a href="#可重复读与命名混淆" class="headerlink" title="可重复读与命名混淆"></a>可重复读与命名混淆</h4><p>快照隔离是一个有用的隔离级别，特别对于只读事务而言。但是，许多数据库实现了它，却用不同的名字来称呼。在Oracle中称为<strong>可序列化（Serializable）\</strong>的，在PostgreSQL和MySQL中称为**可重复读（repeatable read）**</p>
<h3 id="防止丢失更新"><a href="#防止丢失更新" class="headerlink" title="防止丢失更新"></a>防止丢失更新</h3><p>如果应用从数据库中读取一些值，修改它并写回修改的值（读取-修改-写入序列，<em>read-modify-write-cycle</em>），则可能会发生丢失更新的问题。例如，如果两个事务同时执行，则其中一个的修改可能会丢失，因为第二个写入的内容并没有包括第一个事务的修改。</p>
<p>场景：</p>
<ul>
<li>增加计数器或更新账户余额（需要读取当前值，计算新值并写回更新后的值）</li>
<li>在复杂值中进行本地修改：例如，将元素添加到JSON文档中的一个列表（需要解析文档，进行更改并写回修改的文档）</li>
<li>两个用户同时编辑wiki页面，每个用户通过将整个页面内容发送到服务器来保存其更改，覆写数据库中当前的任何内容。</li>
</ul>
<h4 id="原子写"><a href="#原子写" class="headerlink" title="原子写"></a>原子写</h4><p>使用原子操作，通常是最好的解决方案。</p>
<p>方法一，原子操作通常通过在读取对象时，获取其上的排它锁来实现，以便更新完成之前没有其他事务可以读取它。</p>
<p>方法二，强制所有的原子操作在单一线程上执行</p>
<h4 id="显式锁定"><a href="#显式锁定" class="headerlink" title="显式锁定"></a>显式锁定</h4><p>让应用程序显式地锁定将要更新的对象。应用程序可以执行读取-修改-写入序列，如果任何其他事务尝试同时读取同一个对象，则强制等待，直到第一个<strong>读取-修改-写入序列</strong>完成</p>
<h4 id="自动检测丢失的更新"><a href="#自动检测丢失的更新" class="headerlink" title="自动检测丢失的更新"></a>自动检测丢失的更新</h4><p>允许它们并行执行，如果事务管理器检测到丢失更新，则中止事务并强制它们重试其<strong>读取-修改-写入序列</strong></p>
<p>优点：数据库可以结合快照隔离高效地执行此检查；它不需要应用代码使用任何特殊的数据库功能</p>
<h4 id="比较并设置（CAS）"><a href="#比较并设置（CAS）" class="headerlink" title="比较并设置（CAS）"></a>比较并设置（CAS）</h4><p><strong>比较并设置（CAS, Compare And Set）</strong>，只有当前值从上次读取时一直未改变，才允许更新发生</p>
<h4 id="冲突解决和复制"><a href="#冲突解决和复制" class="headerlink" title="冲突解决和复制"></a>冲突解决和复制</h4><p>最后写入胜利（LWW）的冲突解决方法很容易丢失更新，不幸的是，LWW是许多复制数据库中的默认方案。</p>
<h3 id="写入偏差与幻读"><a href="#写入偏差与幻读" class="headerlink" title="写入偏差与幻读"></a>写入偏差与幻读</h3><p><img src="https://github.com/Vonng/ddia/raw/master/img/fig7-8.png" alt="img"></p>
<h4 id="写偏差-write-skew"><a href="#写偏差-write-skew" class="headerlink" title="写偏差(write skew)"></a>写偏差(write skew)</h4><p>如果两个事务读取相同的对象，然后更新其中一些对象（不同的事务可能更新不同的对象），则可能发生写入偏差。</p>
<p>例子：</p>
<ul>
<li><strong><em>会议室预订系统</em></strong>，当有人想要预订时，首先检查是否存在相互冲突的预订（即预订时间范围重叠的同一房间），如果没有找到，则创建会议。快照隔离并不能防止另一个用户同时插入冲突的会议。</li>
<li><p><strong><em>多人游戏</em></strong>，玩家将两个不同的棋子移动到棋盘上的相同位置，或者采取其他违反游戏规则的行为。</p>
</li>
<li><p><strong><em>抢注用户名</em></strong>，在每个用户拥有唯一用户名的网站上，两个用户可能会尝试同时创建具有相同用户名的帐户。</p>
</li>
<li><strong><em>防止双重开支</em></strong>，允许用户花钱或积分的服务，需要检查用户的支付数额不超过其余额。有了写入偏差，可能会发生两个支出项目同时插入，一起导致余额变为负值，但这两个事务都不会注意到另一个。</li>
</ul>
<h4 id="导致写入偏差的幻读"><a href="#导致写入偏差的幻读" class="headerlink" title="导致写入偏差的幻读"></a>导致写入偏差的幻读</h4><p>上述例子，基本遵循规律</p>
<ol>
<li>一个<code>SELECT</code>查询找出符合条件的行，并检查是否符合一些要求。</li>
<li>按照第一个查询的结果，应用代码决定是否继续。（可能会继续操作，也可能中止并报错）</li>
<li>如果应用决定继续操作，就执行写入（插入、更新或删除），并提交事务。</li>
</ol>
<p>一个事务中的写入改变另一个事务的搜索查询的结果，被称为<strong>幻读</strong>（快照隔离避免了只读查询中幻读）</p>
<h4 id="物化冲突"><a href="#物化冲突" class="headerlink" title="物化冲突"></a>物化冲突</h4><p>将幻读变为数据库中一组具体行上的锁冲突</p>
<h2 id="Serializability-可序列化"><a href="#Serializability-可序列化" class="headerlink" title="Serializability(可序列化)"></a>Serializability(可序列化)</h2><p>能有效解决写入偏差，幻读等问题。</p>
<p>可序列化（Serializability ）隔离通常被认为是<strong>最强</strong>的隔离级别。它保证即使事务可以并行执行，最终的结果也是一样的，就好像它们没有任何并发性，连续挨个执行一样。</p>
<p>因此数据库保证，如果事务在单独运行时正常运行，则它们在并发运行时继续保持正确 —— 换句话说，数据库可以防止所有可能的竞争条件。</p>
<p>如何实现？</p>
<h3 id="真-串行执行"><a href="#真-串行执行" class="headerlink" title="真*串行执行"></a>真*串行执行</h3><p>最简之法，<strong>完全不要并发</strong>：在单个线程上按顺序一次只执行一个事务。</p>
<p>这样做就完全绕开了检测/防止事务间冲突的问题，由此产生的隔离，正是可序列化的定义。</p>
<p>能实际运用的原因：</p>
<ul>
<li>RAM足够便宜了，许多场景现在都可以将完整的活跃数据集保存在内存中</li>
<li>数据库设计人员意识到OLTP事务通常很短，而且只进行少量的读写操作。相比之下，长时间的OLAP，通常是只读的</li>
</ul>
<h4 id="在存储过程中封装事务"><a href="#在存储过程中封装事务" class="headerlink" title="在存储过程中封装事务"></a>在存储过程中封装事务</h4><p>即使用存储过程，将各个阶段的操作合并为单个事务</p>
<h4 id="串行执行小结"><a href="#串行执行小结" class="headerlink" title="串行执行小结"></a>串行执行小结</h4><ul>
<li>每个事务都必须小而快，只要有一个缓慢的事务，就会拖慢所有事务处理。</li>
<li>仅限于活跃数据集可以放入内存的情况</li>
<li>写入吞吐量必须低到能在单个CPU核上处理，如若不然，事务需要能划分至单个分区，且不需要跨分区协调。</li>
<li>跨分区事务是可能的，但是它们的使用程度有很大的限制。</li>
</ul>
<h3 id="两阶段锁定（2PL）"><a href="#两阶段锁定（2PL）" class="headerlink" title="两阶段锁定（2PL）"></a>两阶段锁定（2PL）</h3><p>只要没有写入，就允许多个事务同时读取同一个对象。但对象只要有写入（修改或删除），就需要<strong>独占访问（exclusive access）</strong> 权限：</p>
<ul>
<li>如果事务A读取了一个对象，并且事务B想要写入该对象，那么B必须等到A提交或中止才能继续。（这确保B不能在A底下意外地改变对象。）</li>
<li>如果事务A写入了一个对象，并且事务B想要读取该对象，则B必须等到A提交或中止才能继续。（读取旧版本的对象在2PL下是不可接受的。）</li>
</ul>
<h4 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h4><p>为数据库中每个对象添加锁来实现的。锁可以处于<strong>共享模式（shared mode）\</strong>或**独占模式（exclusive mode**</p>
<ul>
<li>若事务要读取对象，则须先以共享模式获取锁。允许多个事务同时持有共享锁。但如果另一个事务已经在对象上持有排它锁，则这些事务必须等待。</li>
<li>若事务要写入一个对象，它必须首先以独占模式获取该锁。没有其他事务可以同时持有锁（无论是共享模式还是独占模式），所以如果对象上存在任何锁，该事务必须等待。</li>
<li>如果事务先读取再写入对象，则它可能会将其共享锁升级为独占锁。升级锁的工作与直接获得排他锁相同。</li>
<li>事务获得锁之后，必须继续持有锁直到事务结束（提交或中止）。这就是“两阶段”这个名字的来源：第一阶段（当事务正在执行时）获取锁，第二阶段（在事务结束时）释放所有的锁。</li>
</ul>
<p>死锁发生：事务A等待事务B释放它的锁，反之亦然。数据库会自动检测，并中止其中一个。</p>
<h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p>一部分是由于获取和释放所有这些锁的开销，但更重要的是由于并发性的降低。</p>
<p>只需要一个缓慢的事务，或者一个访问大量数据并获取许多锁的事务，就能把系统的其他部分拖慢。</p>
<p>当事务由于死锁而被中止并被重试时，它需要从头重做它的工作。如果死锁很频繁，这可能意味着巨大的浪费。</p>
<h4 id="谓词锁"><a href="#谓词锁" class="headerlink" title="谓词锁"></a>谓词锁</h4><p>它类似于前面描述的共享/排它锁，但不属于特定的对象（例如，表中的一行），它属于所有符合某些<strong>搜索条件</strong>的对象</p>
<h4 id="索引范围锁"><a href="#索引范围锁" class="headerlink" title="索引范围锁"></a>索引范围锁</h4><p>如果活跃事务持有很多锁，检查匹配的锁会非常耗时。因此，大多数使用2PL的数据库实际上实现了<strong>索引范围锁</strong>（也称为<strong>间隙锁（next-key locking </strong>），这是一个简化的近似版谓词锁</p>
<p>在房间预订数据库中，您可能会在<code>room_id</code>列上有一个索引，并且/或者在<code>start_time</code> 和 <code>end_time</code>上有索引（否则前面的查询在大型数据库上的速度会非常慢）</p>
<ul>
<li>设您的索引位于<code>room_id</code>上，并且数据库使用此索引查找123号房间的现有预订。现在数据库可以简单地将共享锁附加到这个索引项上，指示事务已搜索123号房间用于预订。</li>
<li>或者，如果数据库使用基于时间的索引来查找现有预订，那么它可以将共享锁附加到该索引中的一系列值，指示事务已经将12:00~13:00时间段标记为用于预定。</li>
</ul>
<p>现在，如果另一个事务想要插入，更新或删除同一个房间和/或重叠时间段的预订，则它将不得不更新索引的相同部分，此时，它会遇到共享锁，它将被迫等到锁被释放。</p>
<h3 id="序列化快照隔离（SSI）"><a href="#序列化快照隔离（SSI）" class="headerlink" title="序列化快照隔离（SSI）"></a>序列化快照隔离（SSI）</h3><p>很有前途</p>
<h4 id="悲观与乐观的并发控制"><a href="#悲观与乐观的并发控制" class="headerlink" title="悲观与乐观的并发控制"></a>悲观与乐观的并发控制</h4><p>两阶段锁(2PL)是一种所谓的<strong>悲观并发控制机制</strong>。意味着，如果有事情可能出错（如另一个事务所持有的锁所表示的），最好等到情况安全后再做任何事情。这就像互斥，用于保护多线程编程中的数据结构。</p>
<p><strong>序列化快照隔离</strong>是一种<strong>乐观（optimistic）</strong> 的并发控制技术。意味着，如果存在潜在的危险也不阻止事务，而是继续执行事务，希望一切都会好起来。当一个事务想要提交时，数据库检查是否有什么不好的事情发生（比如，隔离是否被违反）；如果是的话，事务将被中止，并且必须重试。</p>
<p>SSI基于快照隔离，事务中的所有读取都是来自数据库的一致性快照。SSI添加了一种算法来检测写入之间的序列化冲突，并确定要中止哪些事务。</p>
<h4 id="基于过时前提的决策"><a href="#基于过时前提的决策" class="headerlink" title="基于过时前提的决策"></a>基于过时前提的决策</h4><p>事务从数据库读取一些数据，检查查询的结果，并根据它看到的结果决定采取一些操作（写入数据库）。但是，在快照隔离的情况下，原始查询的结果在事务提交时可能不再是最新的，因为数据可能在同一时间被修改。</p>
<p>事务基于一个<strong>前提（premise）</strong> 采取行动（事务开始时候的事实，例如：“目前有两名医生正在值班”）</p>
<h4 id="检测旧MVCC读取"><a href="#检测旧MVCC读取" class="headerlink" title="检测旧MVCC读取"></a>检测旧MVCC读取</h4><p>数据库需要跟踪一个事务由于MVCC可见性规则而忽略另一个事务的写入。当事务想要提交时，数据库检查是否有任何被忽略的写入现在已经被提交。如果是这样，事务必须中止。</p>
<h4 id="检测影响之前读取的写入"><a href="#检测影响之前读取的写入" class="headerlink" title="检测影响之前读取的写入"></a>检测影响之前读取的写入</h4><p>第二种情况要考虑的是另一个事务在读取数据之后修改数据。</p>
<p><img src="https://github.com/Vonng/ddia/raw/master/img/fig7-11.png" alt="img"></p>
<p>如果在<code>shift_id</code>上有索引，则数据库可以使用索引项1234 来记录事务42 和43 读取这个数据的事实。</p>
<p>当事务写入数据库时，它必须在索引中查找最近曾读取受影响数据的其他事务。并通知其他事务：你们读过的数据可能不是最新的啦。</p>
<h4 id="可序列化的快照隔离的性能"><a href="#可序列化的快照隔离的性能" class="headerlink" title="可序列化的快照隔离的性能"></a>可序列化的快照隔离的性能</h4><p>有很多细节影响。例如，跟踪事务的读取和写入的<strong>粒度</strong>，粒度越细，准确度越高，但性能损耗也越高。事务可以读取被另一个事务覆盖的信息。</p>
<p>与两阶段锁定相比，可序列化快照隔离的最大优点是一个事务不需要阻塞等待另一个事务所持有的锁。</p>
<p>中止率显著影响SSI的整体表现，对于慢事务，SSI可能比两阶段锁定或串行执行更不敏感。</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ul>
<li><strong><em>脏读</em></strong>： 一个客户端读取到另一个客户端尚未提交的写入。<strong>读已提交</strong>或更强的隔离级别可以防止脏读。</li>
<li><strong><em>脏写</em></strong>： 一个客户端覆盖写入了另； 一个客户端尚未提交的写入。几乎所有的事务实现都可以防止脏写。</li>
<li><strong><em>读取偏差（不可重复读）</em></strong>：  在同一个事务中，客户端在不同的时间点会看见数据库的不同状态。<strong>快照隔离</strong>，通常使用<strong>多版本并发控制（MVCC）</strong> 来实现</li>
<li><strong><em>更新丢失</em></strong>： 两个客户端同时执行<strong>读取-修改-写入序列</strong>。其中一个写操作，在没有合并另一个写入变更情况下，直接覆盖了另一个写操作的结果。所以导致数据丢失。</li>
<li><strong><em>写偏差</em></strong>： 一个事务读取一些东西，根据它所看到的值作出决定，并将该决定写入数据库。但是，写入时，该决定的前提不再是真实的。只有可序列化的隔离才能防止这种异常。</li>
<li><strong><em>幻读</em></strong>： 事务读取符合某些搜索条件的对象。另一个客户端进行写入，影响搜索结果。快照隔离可以防止直接的幻像读取，但是写入偏差上下文中的幻读需要特殊处理，例如索引范围锁定。</li>
</ul>
<h1 id="第八章-分布式系统的麻烦"><a href="#第八章-分布式系统的麻烦" class="headerlink" title="第八章-分布式系统的麻烦"></a>第八章-分布式系统的麻烦</h1><h2 id="故障与部分失效"><a href="#故障与部分失效" class="headerlink" title="故障与部分失效"></a>故障与部分失效</h2><p>当你在一台计算机上编写一个程序时，它通常会以一种相当可预测的方式运行：无论是工作还是不工作。因为计算机设计目的就是<strong>总是正确地计算</strong></p>
<p><strong>部分失效（partial failure）</strong>： 部分正常工作，系统其它部分则被不可预料地破坏了。</p>
<p><strong>不确定性的（nonderterministic）</strong>：如果你试图做任何涉及多个节点和网络的事情，它有时可能会工作，有时会出现不可预知的失败。</p>
<h2 id="云计算与超级计算机"><a href="#云计算与超级计算机" class="headerlink" title="云计算与超级计算机"></a>云计算与超级计算机</h2><p>超级计算机：高性能计算（HPC）领域，计算密集型科学计算任务，如天气预报或分子动力学。（垂直扩展的极致），类似于单个计算机</p>
<p>云计算：通常与多租户数据中心，连接IP网络的商品计算机（通常是以太网），弹性/按需资源分配以及计量计费等相关联。</p>
<p>分布式系统更接近于云计算</p>
<h2 id="不可靠的网络"><a href="#不可靠的网络" class="headerlink" title="不可靠的网络"></a>不可靠的网络</h2><p><strong>异步分组网络（asynchronous packet networks）</strong>，一个节点可以向另一个节点发送一个消息（一个数据包），但是网络不能保证它什么时候到达，或者是否到达。</p>
<p>处理这个问题的通常方法是<strong>超时（Timeout）</strong>，在一段时间之后放弃等待，并且认为响应不会到达。</p>
<h3 id="实际的网络错误"><a href="#实际的网络错误" class="headerlink" title="实际的网络错误"></a>实际的网络错误</h3><p>一句话，并非永远可靠。需要你做额外处理，假设。</p>
<h3 id="检测故障"><a href="#检测故障" class="headerlink" title="检测故障"></a>检测故障</h3><p>系统需要自动检测故障节点。例如，负载平衡器需要停止向已死亡的节点转发请求。</p>
<p>网络不定，加重判断难度：</p>
<ul>
<li>如果节点在处理请求时发生崩溃，则无法知道远程节点实际处理了多少数据</li>
<li>节点操作系统上，添加脚本，可以通知其他节点有关该崩溃的信息</li>
</ul>
<p>总的来说，必须假设你根本就没有得到任何回应。可以重试几次，等待超时过期，并且如果在超时时间内没有收到响应，则最终声明节点已经死亡。</p>
<h3 id="超时与无穷的延迟"><a href="#超时与无穷的延迟" class="headerlink" title="超时与无穷的延迟"></a>超时与无穷的延迟</h3><p>超时应该是多少？</p>
<ul>
<li>过多？意味着长时间等待，期间，用户可能不得不等待，或者看到错误信息。</li>
<li>过短？错误地判断节点失效（例如节点只是暂时地高负载）的风险更高，而转移节点，这会给其他节点和网络带来额外的负担，从而更加恶化情况</li>
</ul>
<p>如何估算？2d+r？实际情况下，都无法保证，异步网络具有无限的延迟，服务器并不能保证它们可以在一定的最大时间内处理请求。</p>
<h4 id="网络拥塞和排队"><a href="#网络拥塞和排队" class="headerlink" title="网络拥塞和排队"></a>网络拥塞和排队</h4><p>网络上数据包延迟的可变性通常是由于排队，例如</p>
<ul>
<li>CPU内核当前都处于繁忙状态，网络传入请求将被操作系统排队</li>
<li>TCP执行<strong>流量控制</strong>，意味着在数据甚至进入网络之前，在发送者处需要进行额外的排队</li>
</ul>
<p>解决办法：</p>
<ul>
<li>通过实验方式选择超时：测量延长的网络往返时间和多台机器的分布，以确定延迟的预期可变性</li>
<li>连续测量响应时间及其变化：根据观察到的响应时间分布自动调整超时时间</li>
</ul>
<h3 id="同步网络-vs-异步网络"><a href="#同步网络-vs-异步网络" class="headerlink" title="同步网络 vs 异步网络"></a>同步网络 vs 异步网络</h3><p>同步网络：即使数据经过多个路由器，也不会受到排队的影响，因为呼叫的16位空间已经在网络的下一跳中保留了下来（电话通信）</p>
<p>存在的问题，利用率低，吞吐量低。</p>
<p>异步网络：如TCP协议，是try best策略</p>
<h2 id="不可靠的时钟"><a href="#不可靠的时钟" class="headerlink" title="不可靠的时钟"></a>不可靠的时钟</h2><p>通信不即时：消息通过网络从一台机器传送到另一台机器需要时间。</p>
<p>时钟硬件设备也不一定稳定正确</p>
<h3 id="单调钟与时钟"><a href="#单调钟与时钟" class="headerlink" title="单调钟与时钟"></a>单调钟与时钟</h3><h4 id="时钟："><a href="#时钟：" class="headerlink" title="时钟："></a>时钟：</h4><p>根据某个日历，返回当前日期和时间。如timestamp, date之类</p>
<h4 id="单调钟："><a href="#单调钟：" class="headerlink" title="单调钟："></a>单调钟：</h4><p>单调钟适用于测量持续时间（时间间隔）。</p>
<p>NTP协议检测到计算机的本地石英钟比NTP服务器要更快或更慢，可以调整单调钟向前走的频率</p>
<p>在分布式系统中，使用单调钟测量<strong>经过时间（elapsed time）</strong></p>
<h3 id="时钟同步与准确性"><a href="#时钟同步与准确性" class="headerlink" title="时钟同步与准确性"></a>时钟同步与准确性</h3><p> 单调钟不需要同步，但是时钟需要根据NTP服务器或其他外部时间源来设置才能有用。而外部来源不可靠</p>
<p>石英钟不够精确：它会<strong>漂移（drifts）</strong>（运行速度快于或慢于预期）。且NTP同步也会由于各种因素而不稳定</p>
<p>当然，如果你足够在乎这件事并投入大量资源，可以达到非常好的时钟精度</p>
<h3 id="依赖同步时钟"><a href="#依赖同步时钟" class="headerlink" title="依赖同步时钟"></a>依赖同步时钟</h3><p>时钟的缺陷：一天可能不会有精确的86,400秒，<strong>时钟</strong>可能会前后跳跃，而一个节点上的时间可能与另一个节点上的时间完全不同。</p>
<p>如果使用需要同步时钟的软件，必须仔细监控所有机器之间的时钟偏移，时钟偏离太远则宣布该节点死亡</p>
<h4 id="有序事件的时间戳"><a href="#有序事件的时间戳" class="headerlink" title="有序事件的时间戳"></a>有序事件的时间戳</h4><p>依赖时钟，在多个节点上对事件进行排序，例如LWW策略？不可取，因为时钟不可靠。</p>
<p>how？<strong>逻辑时钟（logic clock）</strong>，基于递增计数器而不是振荡石英晶体，对于排序事件来说是更安全的选择。例如tx_id</p>
<h4 id="时钟读数存在置信区间"><a href="#时钟读数存在置信区间" class="headerlink" title="时钟读数存在置信区间"></a>时钟读数存在置信区间</h4><p>将时钟读数视为一个时间点是没有意义的——它更像是一段时间范围: </p>
<blockquote>
<p> 例如，一个系统可能以95％的置信度认为当前时间处于本分钟内的第10.3秒和10.5秒之间，它可能没法比这更精确了</p>
</blockquote>
<h4 id="全局快照的同步时钟"><a href="#全局快照的同步时钟" class="headerlink" title="全局快照的同步时钟"></a>全局快照的同步时钟</h4><p>分布式系统，由于需要协调，（跨所有分区）全局单调递增的事务ID会很难生成。</p>
<p>可行： 为了确保事务时间戳反映因果关系，在提交读写事务之前，Spanner在提交读写事务时，会故意等待置信区间长度的时间</p>
<h3 id="进程暂停"><a href="#进程暂停" class="headerlink" title="进程暂停"></a>进程暂停</h3><p><strong>租约（lease）</strong>：类似一个带超时的锁，当一个节点获得一个租约时，它知道它在某段时间内自己是领导者，直到租约到期。</p>
<p> 如果节点发生故障，就会停止续期，所以当租约过期时，另一个节点可以接管。类似如下代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">while(true)&#123;</span><br><span class="line">	request=getIncomingRequest();</span><br><span class="line">	// 确保租约还剩下至少10秒</span><br><span class="line">	if (lease.expiryTimeMillis-System.currentTimeMillis()&lt; 10000)&#123;</span><br><span class="line">		lease = lease.renew();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if(lease.isValid())&#123; // 期间可能会发生进程暂停</span><br><span class="line">    	process(request);</span><br><span class="line">	&#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个线程可能会暂停很长时间？当然了，例如GC，虚拟机挂起，磁盘IO阻塞等等</p>
<p>分布式系统没有共享内存，只有通过不可靠网络发送的消息，因此：</p>
<blockquote>
<p> 分布式系统中的节点，必须假定其执行可能在任意时刻暂停相当长的时间，即使是在一个函数的中间。在暂停期间，其它部分在继续运转，甚至可能因为该节点没有响应，而宣告暂停节点的死亡。最终暂停的节点可能会继续运行，在再次检查自己的时钟之前，甚至可能不会意识到自己进入了睡眠。</p>
</blockquote>
<h4 id="响应时间保证"><a href="#响应时间保证" class="headerlink" title="响应时间保证"></a>响应时间保证</h4><p><strong>硬实时（hard real-time）</strong>可行，例如飞机系统中。但是实现昂贵，例如在系统中提供<strong>实时保证</strong>需要各级软件栈的支持，且会降低延迟、吞吐等</p>
<h4 id="限制垃圾收集的影响"><a href="#限制垃圾收集的影响" class="headerlink" title="限制垃圾收集的影响"></a>限制垃圾收集的影响</h4><p>只用垃圾收集器来处理短命对象（这些对象要快速收集），并定期在积累大量长寿对象（因此需要完整GC）之前重新启动进程</p>
<h2 id="知识、真相与谎言"><a href="#知识、真相与谎言" class="headerlink" title="知识、真相与谎言"></a>知识、真相与谎言</h2><h3 id="真理由多数所定义"><a href="#真理由多数所定义" class="headerlink" title="真理由多数所定义"></a>真理由多数所定义</h3><p>节点自身并没问题，但是由于网络、GC等会被误判死亡。</p>
<p>因此，分布式系统不能完全依赖单个节点。决策需要来自多个节点的最小投票数，以减少对于某个特定节点的依赖。</p>
<h4 id="leader-and-lock"><a href="#leader-and-lock" class="headerlink" title="leader and lock"></a>leader and lock</h4><p><img src="https://github.com/Vonng/ddia/raw/master/img/fig8-4.png" alt="img"></p>
<p><strong>图8-4 分布式锁的实现不正确：客户端1认为它仍然具有有效的租约，即使它已经过期，从而破坏了存储中的文件</strong></p>
<p>即使一个节点认为它是“<strong>天选者（the choosen one）</strong>”（分区的负责人，锁的持有者，成功获取用户名的用户的请求处理程序），但这并不一定意味着有法定人数的节点同意</p>
<h4 id="防护令牌"><a href="#防护令牌" class="headerlink" title="防护令牌"></a>防护令牌</h4><p>资源方需要确保一个被误认为自己是“天选者”的节点不能扰乱系统的其它部分，使用<strong>防护（fencing）</strong></p>
<p><img src="https://github.com/Vonng/ddia/raw/master/img/fig8-5.png" alt="img"></p>
<p>假设每次锁定服务器授予锁或租约时，它还会返回一个<strong>防护令牌（fencing token）</strong>，这个数字在每次授予锁定时都会增加</p>
<h3 id="拜占庭故障"><a href="#拜占庭故障" class="headerlink" title="拜占庭故障"></a>拜占庭故障</h3><p>如果节点可能声称其实际上没有收到特定的消息（欺骗行为）。这种行为被称为<strong>拜占庭故障（Byzantine fault）</strong>，<strong>在不信任的环境中达成共识的问题被称为拜占庭将军问题</strong></p>
<p> 当一个系统在部分节点发生故障、不遵守协议、甚至恶意攻击、扰乱网络时仍然能继续正确工作，称之为<strong>拜占庭容错（Byzantine fault-tolerant）</strong>的</p>
<p>例如web 服务的输入验证，数据清洗和输出转义等，即是容错行为。</p>
<h3 id="系统模型与现实"><a href="#系统模型与现实" class="headerlink" title="系统模型与现实"></a>系统模型与现实</h3><p>时机模型。</p>
<ul>
<li><strong><em>同步模型</em></strong>：假设网络延迟，进程暂停和和时钟误差都是有界限的</li>
<li><strong><em>部分同步模型</em></strong>：一个系统在大多数情况下像一个同步系统一样运行，但有时候会超出网络延迟，进程暂停和时钟漂移的界限。<strong>实际</strong></li>
<li><strong><em>异步模型</em></strong>：一个算法不允许对时机做任何假设。场景很有限</li>
</ul>
<p>节点故障模型</p>
<ul>
<li><strong><em>崩溃-停止故障</em></strong>：假设一个节点只能以一种方式失效，即通过崩溃。意味着节点可能在任意时刻突然停止响应，此后该节点永远消失</li>
<li><strong><em>崩溃-恢复故障</em></strong>：假设节点可能会在任何时候崩溃，但也许会在未知的时间之后再次开始响应。<strong>实际</strong></li>
<li><strong><em>拜占庭（任意）故障</em></strong>： 节点可以做（绝对意义上的）任何事情，包括试图戏弄和欺骗其他节点</li>
</ul>
<h4 id="算法的正确性"><a href="#算法的正确性" class="headerlink" title="算法的正确性"></a>算法的正确性</h4><p>分布式算法的属性。</p>
<ul>
<li><strong><em>唯一性</em></strong>：  没有两个防护令牌请求返回相同的值。</li>
<li><strong><em>单调序列</em></strong>：if request x returned token tx, and request y returned token ty, and x competed before y began, then tx &lt; ty</li>
<li><strong><em>可用性</em></strong>:  请求防护令牌并且不会崩溃的节点，最终会收到响应。</li>
</ul>
<h4 id="安全性和活性"><a href="#安全性和活性" class="headerlink" title="安全性和活性"></a>安全性和活性</h4><p> 安全性通常被非正式地定义为，<strong>没有坏事发生</strong>，而活性通常就类似：<strong>最终好事发生</strong>。</p>
<ul>
<li>如果安全属性被违反，我们可以指向一个特定的时间点</li>
<li>活性属性反过来：it may not hold the point in time. But always hope that it may be satisfied in the fueture</li>
</ul>
<p>对于分布式算法，在系统模型的所有可能情况下，要求<strong>始终</strong>保持安全属性是常见的。即使所有节点崩溃，或者整个网络出现故障，算法必须确保它不会返回错误的结果。</p>
<p> 但是，对于活性属性，我们可以提出一些注意事项。例如部分同步模型的定义要求系统最终返回到同步状态——即任何网络中断的时间段只会持续一段有限的时间，然后进行修复。</p>
<h1 id="第九章-一致性和共识"><a href="#第九章-一致性和共识" class="headerlink" title="第九章-一致性和共识"></a>第九章-一致性和共识</h1><p>分布式系统有诸多可能错误，最简单的方法是让服务整体失败，并抛出错误。</p>
<p>然而，我们往往需要的是<em>可容错的分布式系统</em>，即使部分故障了，系统功能也是可用的。</p>
<p>因此， 构建容错系统的最好方法，就是找到带有实用保证的通用抽象，实现之，并让应用依赖这些保证。</p>
<h2 id="一致性的保证"><a href="#一致性的保证" class="headerlink" title="一致性的保证"></a>一致性的保证</h2><p>大多数带副本数据库，都提供了至少<strong>最终一致性</strong>的保证，又称<strong>收敛（convergence）</strong>，我们预计所有的副本最终会收敛到相同的值。</p>
<p>特点：非常弱的保证，并没有说什么时候副本会收敛。</p>
<p>与弱保证的数据库打交道时，你需要始终意识到它的局限性，而不是意外地作出太多假设。</p>
<p>数据库也会提供更强一致性模型的保证，当然这意味着容错和性能损失</p>
<h3 id="线性一致性"><a href="#线性一致性" class="headerlink" title="线性一致性"></a>线性一致性</h3><p><strong>线性一致性</strong>（linearizability），基本的想法是让一个系统看起来好像只有一个数据副本，而且所有的操作都是原子性的。</p>
<p>系统能保障读到的值是最近的，最新的。因此，线性一致性是一种<strong>新鲜度保证（recency guarantee）</strong></p>
<p>这是一种怎样的保证？</p>
<p><img src="https://github.com/Vonng/ddia/raw/master/img/fig9-3.png" alt="img"></p>
<p><strong>图9-3 任何一个读取返回新值后，所有后续读取（在相同或其他客户端上）也必须返回新值。</strong></p>
<p>下图，丨代表操作生效点</p>
<p><img src="https://github.com/Vonng/ddia/raw/master/img/fig9-4.png" alt="img"></p>
<p><strong>图9-4 可视化读取和写入看起来已经生效的时间点。 B的最后读取不是线性一致性的</strong></p>
<blockquote>
<p><strong>操作标记的连线总是按时间（从左到右）向前移动，而不是向后移动</strong></p>
</blockquote>
<h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><h4 id="lock-and-leader-election"><a href="#lock-and-leader-election" class="headerlink" title="lock and leader election"></a>lock and leader election</h4><p>单主系统通常是用锁来保证单一leader，而这个锁则必须是线性一致的。诸如Apache ZooKeeper和etcd之类的协调服务通常用于实现分布式锁和领导者选举。</p>
<p> 分布式锁也在一些分布式数据库中更多的粒度级别上使用</p>
<h4 id="约束与唯一性保证"><a href="#约束与唯一性保证" class="headerlink" title="约束与唯一性保证"></a>约束与唯一性保证</h4><p>例如，用户名或电子邮件地址必须唯一标识一个用户的场景</p>
<h4 id="跨信道的时序依赖"><a href="#跨信道的时序依赖" class="headerlink" title="跨信道的时序依赖"></a>跨信道的时序依赖</h4><p>由于系统中存在额外的信道，线性一致性的违背才被注意到。</p>
<p><img src="https://github.com/Vonng/ddia/raw/master/img/fig9-5.png" alt="img"></p>
<blockquote>
<p> <strong>如果它不是线性一致的，则存在竞争条件的风险：消息队列(图中的步骤3和4）可能比存储服务内部的复制更快</strong>。因为Web服务器和缩放器之间存在两个不同的信道</p>
</blockquote>
<h3 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h3><p>最简单就是真的只有一份数据，然而这显然不具备容错性。</p>
<p>系统容错通常都是用复制来解决。</p>
<ul>
<li><strong><em>单主复制（可能线性一致）</em></strong></li>
<li><strong><em>共识算法（线性一致）</em></strong>，与单主复制类似。然而，共识协议包含防止脑裂和陈旧副本的措施</li>
<li><strong><em>多主复制（非线性一致）</em></strong></li>
<li><strong><em>无主复制（也许不是线性一致的）</em></strong></li>
</ul>
<h3 id="代价"><a href="#代价" class="headerlink" title="代价"></a>代价</h3><p>由于必须是单主复制，因此多数据中心下，数据中心间网络中断会造成不可用。</p>
<ol>
<li><p>CAP理论。最初是作为一个经验法则提出，是一种权衡，鼓励数据库工程师向分布式无共享系统的设计领域深入探索。(实际参考价值不高)</p>
<blockquote>
<p>CAP有时以这种面目出现：一致性，可用性和分区容错性：三者只能择其二。不幸的是这种说法很有误导性【32】，因为网络分区是一种错误，所以它并不是一个选项：不管你喜不喜欢它都会发生</p>
</blockquote>
</li>
<li><p>通常，会<strong>为了提高性能</strong>而选择了牺牲线性一致性，而不是为了容错</p>
</li>
</ol>
<h2 id="顺序的保证"><a href="#顺序的保证" class="headerlink" title="顺序的保证"></a>顺序的保证</h2><p>顺序，操作是按照某种良好定义的顺序执行的，它反复地出现，是一个重要的基础性概念。</p>
<h3 id="顺序与因果"><a href="#顺序与因果" class="headerlink" title="顺序与因果"></a>顺序与因果</h3><p><strong>顺序</strong>反复出现有几个原因，其中一个原因是，它有助于保持<strong>因果关系</strong>。</p>
<p>因果关系对事件施加了一种<strong>顺序</strong>：因在果之前；消息发送在消息收取之前；问题发生在回答前等。</p>
<p>如果一个系统服从因果关系所规定的顺序，我们说它是<strong>因果一致（causally consistent）</strong></p>
<h4 id="因果顺序不是全序"><a href="#因果顺序不是全序" class="headerlink" title="因果顺序不是全序"></a>因果顺序不是全序</h4><p><strong>全序（total order）</strong>允许任意两个元素进行比较，所以如果有两个元素，你总是可以说出哪个更大，哪个更小。比如自然数。</p>
<p>而数学集合是<strong>偏序</strong>(partially ordered)</p>
<p>全序、偏序体现在一致性模型上：</p>
<ul>
<li>线性一致性：全序的</li>
<li>因果一致性：偏序的</li>
</ul>
<p>在线性一致的数据存储中是不存在并发操作的：必须有且仅有一条时间线，所有的操作都在这条时间线上，构成一个全序关系。</p>
<p> 并发意味着时间线会分岔然后合并 —— 在这种情况下，不同分支上的操作是无法比较的</p>
<h4 id="线性一致性强于因果一致性"><a href="#线性一致性强于因果一致性" class="headerlink" title="线性一致性强于因果一致性"></a>线性一致性强于因果一致性</h4><p>线性一致性隐含着因果关系：任何线性一致的系统都能正确保持因果性</p>
<h4 id="捕获因果关系"><a href="#捕获因果关系" class="headerlink" title="捕获因果关系"></a>捕获因果关系</h4><p>为了维持因果性，需要知道哪个操作发生在哪个其他操作之前（<strong>happened before</strong>）。</p>
<p> 为了确定<em>哪些操作发生在其他操作之前</em> ，因果一致性需要跟踪整个数据库中的因果依赖，而不仅仅是一个键</p>
<h3 id="序列号顺序"><a href="#序列号顺序" class="headerlink" title="序列号顺序"></a>序列号顺序</h3><p>使用<strong>序列号（sequence nunber）</strong>或<strong>时间戳（timestamp）</strong>来排序事件，时间戳用逻辑时钟。</p>
<p>因此，提供了全序关系：也就是说每操作都有一个唯一的序列号，而且总是可以比较两个序列号，确定哪一个更大</p>
<p>单主复制的数据库中，复制log使得写操作具备了因果一致性。</p>
<h4 id="非因果序列号生成器"><a href="#非因果序列号生成器" class="headerlink" title="非因果序列号生成器"></a>非因果序列号生成器</h4><p>如果主库不存在？一些方法</p>
<ul>
<li>每个节点都可以生成自己独立的一组序列号</li>
<li>可以将时钟（物理时钟）时间戳附加到每个操作上</li>
<li>预先分配序列号区块。例如1-1000， 1001-2000</li>
</ul>
<p>然而，这将无法满足因果一致。因为这些序列号生成不能正确地捕获跨节点的操作顺序，所以会出现因果关系的问题</p>
<h4 id="兰伯特时间戳-Lamport-timestamps"><a href="#兰伯特时间戳-Lamport-timestamps" class="headerlink" title="兰伯特时间戳(Lamport timestamps)"></a>兰伯特时间戳(Lamport timestamps)</h4><p>尽管上述的三个序列号生成器与因果不一致，但实际上有一个简单的方法来产生与因果关系一致的序列号，即兰伯特时间戳。</p>
<p>它由<em>(counter, node ID)</em>表示。</p>
<p><img src="https://github.com/Vonng/ddia/raw/master/img/fig9-8.png" alt="img"></p>
<p>提供<em>全序</em>：如果你有两个时间戳，则<strong>计数器</strong>值大者是更大的时间戳。如果计数器值相同，则节点ID越大的，时间戳越大。当一个节点收到最大计数器值大于自身计数器值的请求或响应时，它立即将自己的计数器设置为这个最大值。</p>
<h4 id="光有时间戳排序还不够"><a href="#光有时间戳排序还不够" class="headerlink" title="光有时间戳排序还不够"></a>光有时间戳排序还不够</h4><p>为何？</p>
<ul>
<li>因为它基于一种事实，即一旦你收集了系统中的所有用户名创建操作，你才能比较它们的时间戳</li>
<li>你只有在所有的操作都被收集之后，操作的全序才能显现</li>
<li>为了实诸如如用户名上的唯一约束这种东西，仅有操作的全序是不够的，你还需要知道这个全序何时会尘埃落定。</li>
</ul>
<h3 id="全序广播"><a href="#全序广播" class="headerlink" title="全序广播"></a>全序广播</h3><p>如果吞吐量超出单个主库的处理能力，这种情况下如何扩展系统；以及，如果主库失效，如何处理故障切换。问题被称为<strong>全序广播</strong>(total order broadcast)</p>
<p>全序广播通常被描述为在节点间交换消息的协议。 非正式地讲，它要满足两个安全属性：</p>
<ul>
<li><strong><em>可靠交付（reliable delivery）</em></strong>， 没有消息丢失：如果消息被传递到一个节点，它将被传递到所有节点。</li>
<li><strong><em>全序交付（totally ordered delivery）</em></strong>： 消息以相同的顺序传递给每个节点。</li>
</ul>
<p>正确的全序广播算法必须始终保证可靠性和有序性，即使节点或网络出现故障。</p>
<h4 id="使用全序广播"><a href="#使用全序广播" class="headerlink" title="使用全序广播"></a>使用全序广播</h4><p>广泛应用。如，数据库复制、实现可序列化的事务、顺序是在消息送达时被固化、实现提供防护令牌的锁服务。</p>
<h4 id="全序广播-VS-线性一致"><a href="#全序广播-VS-线性一致" class="headerlink" title="全序广播 VS 线性一致"></a>全序广播 VS 线性一致</h4><ul>
<li>可以使用全序广播实现线性一致的存储</li>
<li>同时，也可以使用线性一致的性存储来实现全序广播</li>
</ul>
<h2 id="分布式事务与共识"><a href="#分布式事务与共识" class="headerlink" title="分布式事务与共识"></a>分布式事务与共识</h2><p>简单来说，就是让多个节点对某件事达成共识</p>
<p>应用场景：</p>
<ul>
<li>选主：在单主数据库中，所有节点需要就哪个节点是领导者达成一致。否则脑裂情况下，数据会被破坏</li>
<li>原子提交：必须让所有节点对事务的结果达成一致，要不成功提交、要么失败回滚</li>
</ul>
<h3 id="原子提交与二阶段提交（2PC）"><a href="#原子提交与二阶段提交（2PC）" class="headerlink" title="原子提交与二阶段提交（2PC）"></a>原子提交与二阶段提交（2PC）</h3><p> 原子性可以防止失败的事务搅乱数据库，避免数据库陷入半成品结果和半更新状态。尤其是多对象事务、以及二级索引等。</p>
<h4 id="从单节点到分布式原子提交"><a href="#从单节点到分布式原子提交" class="headerlink" title="从单节点到分布式原子提交"></a>从单节点到分布式原子提交</h4><p>单节点上，原子性由数据引擎实现。而事务提交或终止的关键决定时刻是<em>磁盘写入完提交记录的时刻</em></p>
<p>而多节点时，容易出现，提交在某些节点上成功，而在其他节点上失败。</p>
<p>节点必须立刻提交，当它确信事务中的其他节点也将提交时。且事务提交必须是不可撤销的</p>
<h4 id="两阶段提交简介"><a href="#两阶段提交简介" class="headerlink" title="两阶段提交简介"></a>两阶段提交简介</h4><p>2PC中的提交/中止过程分为两个阶段（因此而得名）</p>
<p><img src="https://github.com/Vonng/ddia/raw/master/img/fig9-9.png" alt="img"></p>
<p> 2PC使用一个新组件：<strong>协调者（coordinator）</strong>。协调者通常作为一个库嵌入到原生程序中。</p>
<p>工作机理：</p>
<ol>
<li>应用开始在多个数据库节点上读写数据</li>
<li>当应用准备提交时，协调者开始阶段 1 ：它发送一个<strong>准备（prepare）</strong>请求到每个节点，询问它们是否能够提交</li>
<li>如果所有参与者都回答“是”，表示它们已经准备好提交，那么协调者在阶段 2 发出<strong>提交（commit）</strong>请求，然后提交真正发生。</li>
<li>如果任意一个参与者回复了“否”，则协调者在阶段2 中向所有节点发送<strong>中止（abort）</strong>请求。</li>
<li>最后，事务就提交了，这一事实会广播至所有的参与者中</li>
</ol>
<h4 id="系统承诺"><a href="#系统承诺" class="headerlink" title="系统承诺"></a>系统承诺</h4><p>细节：</p>
<ul>
<li>协调者必须把这个决定写到磁盘上的事务日志中，如果它随后就崩溃，恢复后也能知道自己所做的决定。这被称为<strong>提交点（commit point）</strong></li>
<li>一旦协调者的决定落盘，提交或放弃请求会发送给所有参与者。如果这个请求失败或超时，协调者必须永远保持重试，直到成功为止。没有回头路</li>
</ul>
<p>该协议包含两个关键的“不归路”点：</p>
<ol>
<li>当参与者投票“是”时，它承诺它稍后肯定能够提交（尽管协调者可能仍然选择放弃）</li>
<li>一旦协调者做出决定，这一决定是不可撤销的</li>
</ol>
<h4 id="协调者失效"><a href="#协调者失效" class="headerlink" title="协调者失效"></a>协调者失效</h4><p>完成2PC的唯一方法是等待协调者恢复</p>
<h3 id="实践中的分布式事务"><a href="#实践中的分布式事务" class="headerlink" title="实践中的分布式事务"></a>实践中的分布式事务</h3><p>分类：</p>
<ul>
<li><strong><em>数据库内部的分布式事务</em></strong>：分布式数据库支持数据库节点之间的内部事务</li>
<li><strong><em>异构分布式事务</em></strong>：参与者是两种或以上不同技术（例如来自不同提供商）</li>
</ul>
<h4 id="恰好一次的消息处理"><a href="#恰好一次的消息处理" class="headerlink" title="恰好一次的消息处理"></a>恰好一次的消息处理</h4><p>例如，消息队列中的一条消息可以被确认为已处理，当且仅当用于处理消息的数据库事务成功提交。这是通过在同一个事务中原子提交<strong>消息确认</strong>和<strong>数据库写入</strong>两个操作来实现的。</p>
<h4 id="XA事务"><a href="#XA事务" class="headerlink" title="XA事务"></a>XA事务</h4><p>XA事务是跨异构技术实现两阶段提交的标准</p>
<p> XA不是一个网络协议——它只是一个用来与事务协调者连接的C API（interface）</p>
<p> 事务协调者需要实现XA API。标准没有指明应该如何实现，但实际上协调者通常只是一个库，被加载到发起事务的应用的同一个进程中（而不是单独的服务）。它在事务中个跟踪所有的参与者，并在要求它们<strong>准备</strong>之后收集参与者的响应（通过驱动回调），并使用本地磁盘上的日志记录每次事务的决定（提交/中止）。</p>
<h4 id="怀疑时持有锁"><a href="#怀疑时持有锁" class="headerlink" title="怀疑时持有锁"></a>怀疑时持有锁</h4><p> 在事务提交或中止之前，数据库不能释放这些锁. 当这些锁被持有时，其他事务不能修改这些行</p>
<h4 id="从协调者故障中恢复"><a href="#从协调者故障中恢复" class="headerlink" title="从协调者故障中恢复"></a>从协调者故障中恢复</h4><p> 唯一的出路是让管理员手动决定提交还是回滚事务。</p>
<p> 许多XA的实现都有一个叫做<strong>启发式决策（heuristic decistions）<em>的紧急逃生舱口：允许参与者单方面决定放弃或提交一个存疑事务，而无需协调者做出最终决定</em></strong></p>
<h4 id="分布式事务的限制"><a href="#分布式事务的限制" class="headerlink" title="分布式事务的限制"></a>分布式事务的限制</h4><p>事务协调者本身就是一种数据库（存储了事务的结果），因此需要像其他重要数据库一样小心处理</p>
<h3 id="容错共识"><a href="#容错共识" class="headerlink" title="容错共识"></a>容错共识</h3><p>简单概括。</p>
<ol>
<li>一个或多个节点提议(propose)某些值</li>
<li>共识算法决定（decides）采用其中的某个值</li>
</ol>
<p>共识算法的属性：</p>
<ol>
<li><strong><em>一致同意（Uniform agreement）</em></strong>： 没有两个节点的决定不同。</li>
<li><strong><em>完整性（Integrity）</em></strong>：  没有节点决定两次。</li>
<li><strong><em>有效性（Validity）</em></strong>： 如果一个节点决定了值 <code>v</code> ，则 <code>v</code> 由某个节点所提议。</li>
<li><strong><em>终止（Termination）</em></strong>：由所有未崩溃的节点来最终决定值</li>
</ol>
<p><strong>一致同意</strong>和<strong>完整性</strong>属性定义了共识的核心思想：所有人都决定了相同的结果，一旦决定了，你就不能改变主意</p>
<p><strong>终止</strong>实现了容错的思想，2PC不符合终止属性的要求。任何共识算法都需要至少占总体<strong>多数（majority）</strong>的节点正确工作，以确保终止属性</p>
<p>共识算法假设不存在<strong>拜占庭式错误</strong></p>
<h4 id="共识算法和全序广播"><a href="#共识算法和全序广播" class="headerlink" title="共识算法和全序广播"></a>共识算法和全序广播</h4><p>Instead of proposing and deciding on a single value, which staticfying the properties. decide on a sequence of values, which makes them total broadcast algorithmes</p>
<h4 id="单领导者复制和共识"><a href="#单领导者复制和共识" class="headerlink" title="单领导者复制和共识"></a>单领导者复制和共识</h4><p>单主复制本质上就满足了全序广播，不过由于leader election存在，所以依然需要共识。</p>
<p>如果主库是由运维人员手动选择和配置的，那么你实际上拥有一种<strong>独裁类型</strong>的“共识算法”</p>
<h4 id="epoch-numbering-and-quorums"><a href="#epoch-numbering-and-quorums" class="headerlink" title="epoch numbering and quorums"></a>epoch numbering and quorums</h4><p>协议定义了一个<strong>时代编号</strong>（epoch number）</p>
<p>每次当现任领导被认为挂掉的时候，节点间就会开始一场投票，以选出一个新领导。这次选举被赋予一个递增的时代编号，因此时代编号是全序且单调递增的。如果两个不同的时代的领导者之间出现冲突（也许是因为前任领导者实际上并未死亡），那么带有更高时代编号的领导说了算。</p>
<p>在任何领导者被允许决定任何事情之前，必须先检查是否存在其他带有更高时代编号的领导者</p>
<p>必须从<strong>法定人数（quorum）</strong>的节点中获取选票</p>
<p>有两轮投票：第一次是为了选出一位领导者，第二次是对领导者的提议进行表决。关键的洞察在于，这两次投票的<strong>法定人群</strong>必须相互<strong>重叠（overlap）</strong>：如果一个提案的表决通过，则至少得有一个参与投票的节点也必须参加过最近的领导者选举</p>
<h4 id="共识的局限性"><a href="#共识的局限性" class="headerlink" title="共识的局限性"></a>共识的局限性</h4><p>共识系统通常依靠超时来检测失效的节点</p>
<p>共识系统总是需要严格多数来运转, 意味着你至少需要三个节点才能容忍单节点故障</p>
<p> 共识系统通常依靠超时来检测失效的节点，频繁的领导者选举会导致糟糕的性能表现</p>
<p> 有时共识算法对网络问题特别敏感，如果整个网络工作正常，但只有一条特定的网络连接一直不可靠，Raft可能会进入领导频繁二人转的局面</p>
<h3 id="成员与协调服务"><a href="#成员与协调服务" class="headerlink" title="成员与协调服务"></a>成员与协调服务</h3><p>提供了功能：</p>
<ul>
<li><strong><em>线性一致性的原子操作</em></strong>：</li>
<li><strong><em>操作的全序排序</em></strong>：防护令牌是每次锁被获取时单调增加的数字。 ZooKeeper通过全局排序操作来提供这个功能</li>
<li><strong><em>失效检测</em></strong>：客户端在ZooKeeper服务器上维护一个长期会话，并通过心跳保活</li>
<li><strong><em>变更通知</em></strong>：can watch for changes，通过订阅通知，客户端不用再通过频繁轮询的方式来找出变更</li>
</ul>
<h4 id="将工作分配给节点"><a href="#将工作分配给节点" class="headerlink" title="将工作分配给节点"></a>将工作分配给节点</h4><p>有效地协调资源，例如分配分区到节点上。</p>
<p>ZooKeeper提供了一种将协调节点（共识，操作排序和故障检测）的一些工作“外包”到外部服务的方式。可以报zookeeper理解为协调工作的外包服务商</p>
<h4 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h4><p>类似DNS，实际上DNS更好。</p>
<p>选主场景需要，如果你的共识系统已经知道领导是谁，那么也可以使用这些信息来帮助其他服务发现领导是谁</p>
<h4 id="成员服务"><a href="#成员服务" class="headerlink" title="成员服务"></a>成员服务</h4><p>成员服务确定哪些节点当前处于活动状态并且是群集的活动成员</p>
<h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><p>如果你只有一个节点，或者你愿意将决策的权能分配给单个节点，所有这些事都很简单</p>
<p>但如果该领导者失效，应对这种情况可以有三种方法</p>
<ul>
<li>等待领导者恢复，接受系统将在这段时间阻塞的事实。</li>
<li>人工故障切换</li>
<li>使用算法自动选择一个新的领导者。这种方法需要一种共识算法</li>
</ul>
<p>尽管单领导者数据库可以提供线性一致性，且无需对每个写操作都执行共识算法，但共识对于保持及变更领导权仍然是必须的</p>
<p>像ZooKeeper这样的工具为应用提供了“外包”的共识、故障检测和成员服务。它们扮演了重要的角色，虽说使用不易，但总比自己去开发一个好</p>
<p> 尽管如此，并不是所有系统都需要共识，例如无主和多主系统，系统中出现的冲突正是不同领导者之间没有达成共识的结果，但也这并没有关系：我们只是需要接受没有线性一致性的事实，并学会更好地与具有分支与合并版本历史的数据打交道。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://erenming.com/2020/08/08/【读书笔记】设计数据密集型应用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Eren Ming">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eren with you">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/08/【读书笔记】设计数据密集型应用/" itemprop="url">设计数据密集型应用之数据系统基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-08-08T11:28:27+08:00">
                2020-08-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/读万卷书/" itemprop="url" rel="index">
                    <span itemprop="name">读万卷书</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/08/08/【读书笔记】设计数据密集型应用/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/08/08/【读书笔记】设计数据密集型应用/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><h2 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h2><p>针对系统的容错设计，提高系统错误的抛出率，而不是忽略它(除了安全这种不可恢复类型的)，尽量避免failure</p>
<h4 id="硬件错误"><a href="#硬件错误" class="headerlink" title="硬件错误"></a>硬件错误</h4><ol>
<li>硬件自身容许设计</li>
<li>软件系统的灵活性与弹性。即容许整台机器异常，而不影响系统</li>
</ol>
<h4 id="软件错误"><a href="#软件错误" class="headerlink" title="软件错误"></a>软件错误</h4><ol>
<li>影响范围大，连锁反应，排查难。bug，依赖服务错误等</li>
<li>避免：考虑全面，全面测试，处理隔离，监控</li>
</ol>
<h4 id="人类错误"><a href="#人类错误" class="headerlink" title="人类错误"></a>人类错误</h4><ol>
<li>最小化犯错机会的方式设计系统，全面测试，允许从错误中恢复，监控</li>
</ol>
<h2 id="Scaliability-可扩展性"><a href="#Scaliability-可扩展性" class="headerlink" title="Scaliability(可扩展性)"></a>Scaliability(可扩展性)</h2><ol>
<li>Load描述，又称load parameters：CPU， 内存，网络等因素，这取决于系统的设计</li>
<li>性能描述：通常使用percentiles(百分位数)，99th, 98th等。<ul>
<li>监控度量percentiles: 使用计算窗口，即保存窗口时间内的数据，并计算排序。其他算法，forwar decay、t-digits等也可</li>
</ul>
</li>
<li><p>应对Load: </p>
<ul>
<li>纵向扩展：升级到更高性能的机器</li>
<li>水平扩展：将Load分摊到多台相似的虚拟机上</li>
</ul>
</li>
<li><p>扩展性是针对特定的假设来设计的，而假设可能是错误的。因此在应用初期，应该采取功能快速迭代的方式，而非基于假设的去支持扩展</p>
</li>
</ol>
<h2 id="Maintainability-可维护性"><a href="#Maintainability-可维护性" class="headerlink" title="Maintainability(可维护性)"></a>Maintainability(可维护性)</h2><ol>
<li>Operability，可操作&amp;运维性：提供监控指标、文档、好的默认配置、好的工具等</li>
<li>Simplicity，Managing Complexity：通过抽象降低复杂度</li>
<li>Evolvability，Making Change Easy：敏捷的工作模式，TDD，重构</li>
</ol>
<hr>
<h1 id="第二章：数据模型和查询语言"><a href="#第二章：数据模型和查询语言" class="headerlink" title="第二章：数据模型和查询语言"></a>第二章：数据模型和查询语言</h1><h2 id="关系型模型VS文档型模型"><a href="#关系型模型VS文档型模型" class="headerlink" title="关系型模型VS文档型模型"></a>关系型模型VS文档型模型</h2><ul>
<li>一对多关系：关系型使用外键；而文档型使用JSON-LIKE来表示树状结构(更方便)</li>
<li>多对一、多对多：两者并无区别，都是使用<code>relation model</code>(a relation(table) is simply a collection of tuples(rows))而非<code>network)(hierachical) model</code>(with access path)</li>
<li>对比：<ul>
<li>shcema灵活度：文档型更佳(schema-on-read)，数据结构是隐式的，只有读取时才会翻译出来。于关系型（write-on-read）</li>
<li>查询局部性优化：文档型更佳。关系型也能支持</li>
</ul>
</li>
</ul>
<h2 id="数据的查询语言"><a href="#数据的查询语言" class="headerlink" title="数据的查询语言"></a>数据的查询语言</h2><ul>
<li>声明式，例如SQL(database)、CSS&amp;HTML(web)，MapReduce(分组聚合，例如mongDB中的aggregate)。</li>
<li>命令式，例如通过函数查询。<strong>声明式更为推荐</strong></li>
</ul>
<h2 id="图数据模型"><a href="#图数据模型" class="headerlink" title="图数据模型"></a>图数据模型</h2><p>对于多对多较多，我们一般使用关系型模型，然而随着数据之间联系变得复杂，数据模型为<strong>图模型</strong>则更佳</p>
<h3 id="属性图"><a href="#属性图" class="headerlink" title="属性图"></a>属性图</h3><p>在属性图模型中，每个<strong>顶点（vertex）</strong>包括：</p>
<ul>
<li>唯一的标识符</li>
<li>一组 <strong>出边（outgoing edges）</strong></li>
<li>一组 <strong>入边（ingoing edges）</strong></li>
<li>一组属性（键值对）</li>
</ul>
<p>每条 <strong>边（edge）</strong> 包括：</p>
<ul>
<li>唯一标识符</li>
<li><strong>边的起点/尾部顶点（tail vertex）</strong></li>
<li><strong>边的终点/头部顶点（head vertex）</strong></li>
<li>描述两个顶点之间关系类型的标签</li>
<li>一组属性（键值对）</li>
</ul>
<p>Cypher声明式查询语言，语法方便简洁。举例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MATCH</span><br><span class="line">	(person) -[:BORN_IN]-&gt;  () -[:WITHIN*0..]-&gt; (us:Location &#123;name:&apos;United States&apos;&#125;),</span><br><span class="line">	(person) -[:LIVES_IN]-&gt; () -[:WITHIN*0..]-&gt; (eu:Location &#123;name:&apos;Europe&apos;&#125;)</span><br><span class="line">RETURN person.name</span><br></pre></td></tr></table></figure>
<h3 id="Triple-Stores-and-SPARQL"><a href="#Triple-Stores-and-SPARQL" class="headerlink" title="Triple-Stores and SPARQL"></a>Triple-Stores and SPARQL</h3><p>三元组模型：(subject, predicate, object)，(主，谓，宾)结构。例如(Jim, likes, bananas)</p>
<h3 id="DataLog"><a href="#DataLog" class="headerlink" title="DataLog"></a>DataLog</h3><p>是上述Cypher以及SPARQL之类查询语言的基础。通过在查询中组合以及递归重用相同的规则来实现查询，尤其针对复杂查询</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>演化：one big tree(hierarchical) -&gt; relation-model(because of many-to-many) -&gt; NoSQL -&gt; Graph</li>
<li>文档数据库通常应用于one-many或者无关系的数据场景</li>
<li>而图数据库，则应用于任何数据都可能与其他数据有关系（与文档数据库都是schema less）</li>
<li>尽管一种模型可以模拟另外一种模型，但是实际用起来往往很糟糕。因此要选择合适的</li>
</ul>
<h1 id="第三章-存储与检索"><a href="#第三章-存储与检索" class="headerlink" title="第三章 存储与检索"></a>第三章 存储与检索</h1><p>常见存储模型：log-structured, page-oriented</p>
<p>使用append-only data file的模式，可快速实现一个数据库，很多数据库都使用这一原理。</p>
<ul>
<li>更新或者添加记录，都会在文件末尾append一条log。写入性能优</li>
<li>然而查询时，需要遍历所有记录。读取性能差</li>
<li>因此不得不引入索引，索引是一种取自原始数据（一般是元信息）额外的数据结构。</li>
<li>但是维护索引需要额外性能，尤其是写入时。因此需要根据查询模式，构建索引，达到权衡</li>
</ul>
<h2 id="HASH-Index"><a href="#HASH-Index" class="headerlink" title="HASH Index"></a>HASH Index</h2><p>使用hash表来存储索引(in-memory)，其中键为实际key， 值为文件中实际记录的offset。</p>
<p>如何处理磁盘空间不足？将log文件划分为多个指定长度文件段(segment)，当达到长度阈值时，则起一个后台线程进行压缩，并同时合并不同的segment</p>
<h3 id="其他实践细节"><a href="#其他实践细节" class="headerlink" title="其他实践细节"></a>其他实践细节</h3><ul>
<li>文件格式。使用2进制</li>
<li>删除记录。删除时，标记为tombstore(假删除)，在合并压缩过程进行实际删除</li>
<li>crash recovery。通过保存索引的快照，实现快速重启。</li>
<li>Partially written records。支持checksum，可检测并忽略异常部分</li>
<li>并发控制。写操作保持同步，只允许一个线程进行写操作</li>
</ul>
<h3 id="Why-append-only-file-而不是直接更改文件"><a href="#Why-append-only-file-而不是直接更改文件" class="headerlink" title="Why append-only file 而不是直接更改文件"></a>Why append-only file 而不是直接更改文件</h3><ul>
<li>写操作总是有序的，可避免乱序写，从而提升性能（磁盘硬件原因，磁道扫描等）</li>
<li>并发和异常崩溃更简单</li>
<li>压缩合并机制可避免存储容量问题</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>Hash table 必须in memory。因此大量key-value等情况难以适合，尽管能利用磁盘，但是会大大提升复杂度并降低性能</li>
<li>range queries 效率低</li>
</ul>
<h2 id="SSTables-and-LSM-Trees"><a href="#SSTables-and-LSM-Trees" class="headerlink" title="SSTables and LSM-Trees"></a>SSTables and LSM-Trees</h2><p>更改文件格式，将所有segments中的键值对按照键进行排序。从而改进append-only file模式</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>合并segments非常简单且高效。使用归并排序的算法实现，且当存在同名key，我们保留最近segment中的key</li>
<li>无需将索引的keys都保存在内存中。大可只保留部分key的索引，依然key是有序的，则只需找到目前key前后的两个key的索引，获取offset在期间扫描即可</li>
<li>提高写入性能。我们可以将记录分组，然后在写入前压缩</li>
<li>range query 效率很高 </li>
</ol>
<h3 id="构建与维护"><a href="#构建与维护" class="headerlink" title="构建与维护"></a>构建与维护</h3><p>我们在内存中维护SSTable，通过使用树管理（红黑树、AVL-Tree）</p>
<ol>
<li>在写入时，添加到tree中。in-memory tree called a <em>memtable</em></li>
<li><p>当memtable大于一定阈值时，则将其作为SStable file保存在磁盘中（期间，我们新起一个memetable实例）</p>
</li>
<li><p>在读取时，按照memtable-&gt;recent SSTable file-&gt; older-SSTable file的属性查找</p>
</li>
<li>在一定的时机，进行合并与压缩</li>
</ol>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>意外崩溃时，会造成in-memory memtable内容丢失。可通过额外一个的append-only log file来避免</li>
</ol>
<h3 id="性能优化点"><a href="#性能优化点" class="headerlink" title="性能优化点"></a>性能优化点</h3><ol>
<li>Slow when looking up keys tha do not exist in the database. 可通过Boolm filters来解决</li>
<li>压缩合并的时机。分为<code>size-tired</code>以及<code>leveled</code>两种策略</li>
</ol>
<h2 id="B-Trees"><a href="#B-Trees" class="headerlink" title="B-Trees"></a>B-Trees</h2><p>B-trees break the database into fixed-size blocks or pages. </p>
<p>Each page can be identified using an address or location。a B-tree with n kesy always has a depth of O(logn)。</p>
<h3 id="使B-tree更可靠"><a href="#使B-tree更可靠" class="headerlink" title="使B-tree更可靠"></a>使B-tree更可靠</h3><ol>
<li>由于b-tree在写入时，是直接修改page的，期间发生崩溃容易造成一些异常（例如，孤儿页）。引入redo log</li>
<li>并发控制，</li>
</ol>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ol>
<li>页中只存储key的摘要，节省空间</li>
<li>pages能被放置在磁盘任意位置。为避免，会在写入时，重新排布tree。</li>
<li>添加额外的指针，例如连接叶子页，从而避免过多的跳转</li>
</ol>
<h2 id="其他索引"><a href="#其他索引" class="headerlink" title="其他索引"></a>其他索引</h2><ul>
<li>primary key index。例如标识关系数据库中的row，图数据库中的顶点</li>
<li>secondary indexes。例如关系数据库中以某列(user_id)作为索引。很容易通过key-value索引构建</li>
<li>index中存储值。例如聚簇索引（indexed row store in index），覆盖索引(聚簇&amp;非聚簇的折中，存indexed row的部分列)</li>
<li>多列索引。concatenated index（连接索引）, 将多个列组合而成，只能按照前后顺序生效</li>
<li>multi-dimensional(多维索引)。更为通用</li>
<li>全文搜索和模糊索引；内存数据库</li>
</ul>
<h2 id="事务处理或分析？"><a href="#事务处理或分析？" class="headerlink" title="事务处理或分析？"></a>事务处理或分析？</h2><p>数据处理模式。</p>
<ul>
<li>OLTP(online trasaction processing)。常见于交易、登录等事务，面向用户</li>
<li>OLAP(online transaction processing)。报表分析、聚合等，面向分析人员</li>
</ul>
<h3 id="Data-Warehousing"><a href="#Data-Warehousing" class="headerlink" title="Data Warehousing"></a>Data Warehousing</h3><p>OLTP系统通常需要保持高可用、低延迟，而直接对OLTP所用的数据库查询分析，容易产生不良影响。且OLTP相关数据库的索引也往往不适合OLAP</p>
<p>ETL(extract-transform-load)：Warehouse将其他系统的数据收集过来，转换analysis-friendly模式，清理并加载导入到data warehouse</p>
<p><img src="https://raw.githubusercontent.com/erenming/image-pool/master/blog/image-20200823212136999.png" alt="image-20200823212136999"></p>
<p>小公司业务量小，并不需要整套系统，简单SQL、报表分析工具都可以。</p>
<h3 id="Schemas-for-Analytics"><a href="#Schemas-for-Analytics" class="headerlink" title="Schemas for Analytics"></a>Schemas for Analytics</h3><ul>
<li>star schema: 实际的表处于中心，被它不同维度的信息表包围，它们之间的连接就如同星星</li>
<li>Snowflake schema: star schema的扩展，将周围表划分为更多的子维度表（少用）</li>
</ul>
<h3 id="Column-Oriented-Storage"><a href="#Column-Oriented-Storage" class="headerlink" title="Column-Oriented Storage"></a>Column-Oriented Storage</h3><p>将所有的值按照列区分开并各自单独存储在一起，而非将所有列的值合并为行存储。</p>
<p>因为分析往往只针对个别列，以行为维度存储会读取不必要的列数据</p>
<p>例如,</p>
<blockquote>
<p>column_1_key file contents: 1,2,3</p>
<p>column_2_key file contents: tom,jerry,john </p>
</blockquote>
<h3 id="Column-Comparession"><a href="#Column-Comparession" class="headerlink" title="Column Comparession"></a>Column Comparession</h3><p>使用bitmap encoding技术</p>
<h3 id="列存储的排序"><a href="#列存储的排序" class="headerlink" title="列存储的排序"></a>列存储的排序</h3><p>排序后，有助于压缩，以及查询</p>
<h3 id="列存储的写入"><a href="#列存储的写入" class="headerlink" title="列存储的写入"></a>列存储的写入</h3><p>所有的写入，首先会写入内存，添加到一个排序好的结构中，然后准备被写入磁盘（而非像B-Tree一样直接修改pages）</p>
<h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><p>Materiablized view: 针对sum、count等一类聚合后的结果数据的缓存。</p>
<p>Data cubes: 多维度的聚合缓存优化（例如商品的名称、购买日期两个维度，构成一个data cubes）。针对特定的查询很快（预先计算好了），例如每年的购买商品量</p>
<h1 id="第四章-编码与更新"><a href="#第四章-编码与更新" class="headerlink" title="第四章-编码与更新"></a>第四章-编码与更新</h1><p>应用总是在不断更新的，而相关的数据自然也得不断更新。同样，数据格式的更更新也会导致关联应用代码的更新。而应用代码的更新往往更麻烦。</p>
<p>为满足<code>making change easy</code>，我们必须让数据的更新满足，向前兼容以及向后兼容。</p>
<h2 id="数据编码的格式"><a href="#数据编码的格式" class="headerlink" title="数据编码的格式"></a>数据编码的格式</h2><p>编码(encoding)，将数据从内存表示转换为字节序列的过程。反之，称为解码(decoding)</p>
<h3 id="语言特定格式"><a href="#语言特定格式" class="headerlink" title="语言特定格式"></a>语言特定格式</h3><p>语言内置的编码格式，例如Python中的pickle等。通常不建议</p>
<h3 id="JSON-XML-and-Binary-Variants"><a href="#JSON-XML-and-Binary-Variants" class="headerlink" title="JSON, XML, and Binary Variants"></a>JSON, XML, and Binary Variants</h3><p>json, xml都是文本编码，且能自解释的，可读行非常高。</p>
<p>缺点：</p>
<ul>
<li>数据类型缺乏，例如JSON不能区分整数、浮点数</li>
<li>不支持二进制类型，不得不用base64转换，而这将导致增加额外33%的数据大小</li>
</ul>
<p>题外话，这跟让不同组织达成一致相比都不是缺点:)</p>
<p>二进制变体，如BSON, BJSON等</p>
<h3 id="Trift-and-Protocol-Buffers"><a href="#Trift-and-Protocol-Buffers" class="headerlink" title="Trift and Protocol Buffers"></a>Trift and Protocol Buffers</h3><p>当用于组织内部时，推广二进制编码往往没那么多压力。失去了可读性，但是体积更小，编解码更快</p>
<h4 id="Thrift-BinaryProtocol"><a href="#Thrift-BinaryProtocol" class="headerlink" title="Thrift BinaryProtocol"></a>Thrift BinaryProtocol</h4><p><img src="https://github.com/Vonng/ddia/raw/master/img/fig4-2.png" alt></p>
<h4 id="Thrift-CompactProtocol（与Protocol-Buffers基本相同）"><a href="#Thrift-CompactProtocol（与Protocol-Buffers基本相同）" class="headerlink" title="Thrift  CompactProtocol（与Protocol Buffers基本相同）"></a>Thrift  CompactProtocol（与Protocol Buffers基本相同）</h4><p><img src="https://github.com/Vonng/ddia/raw/master/img/fig4-3.png" alt></p>
<p>两者相对比：</p>
<ul>
<li>CompactProtocol体积更小</li>
<li>使用field tag替换字段名</li>
<li>使用<code>variable-length</code>表示数字。每个字节的头个位用来表示后续字节是否同属该数字值</li>
</ul>
<p>注意，required以及optional标记，只在运行时校验。数据表示均一致。</p>
<h5 id="字段更新时"><a href="#字段更新时" class="headerlink" title="字段更新时"></a>字段更新时</h5><blockquote>
<ul>
<li>可任意更改字段名，而不能更改tag number。</li>
<li>添加一个字段：<ul>
<li>向前兼容：老代码会直接忽略该字段</li>
<li>向后兼容：新字段必须为optional或者有默认值，以便读到老的数据时，可以忽略或取默认</li>
</ul>
</li>
</ul>
</blockquote>
<h5 id="字段类型更新时"><a href="#字段类型更新时" class="headerlink" title="字段类型更新时"></a>字段类型更新时</h5><blockquote>
<ul>
<li>会有丢失数据或丧失精度的风险。例如整数，32bit -&gt; 64bit。64读到32位填充0，32读到64无法满足而丢弃置空</li>
<li>ProtobufProtocol中的repeated标记表示同样的field tag出现若干次，可兼容optional</li>
</ul>
</blockquote>
<h3 id="Avro"><a href="#Avro" class="headerlink" title="Avro"></a>Avro</h3><p><img src="https://github.com/Vonng/ddia/raw/master/img/fig4-5.png" alt></p>
<p>相较上述Thrift、Protobuf，它没有field tag或者field name，因此必须使用相同的schema来读写。</p>
<p>写入端&amp;读取端，可拥有不同的schema，对于兼容性，可使用default value以及版本号来解决</p>
<h4 id="动态生成schema"><a href="#动态生成schema" class="headerlink" title="动态生成schema"></a>动态生成schema</h4><p>Avro可支持动态生成schema，可以方便地通过JSON，数据库表结构等直接生成Acro结构。</p>
<p>而ProtocolBufferdeng则不得不手动修改field tag与列名的映射</p>
<h2 id="数据流的模型"><a href="#数据流的模型" class="headerlink" title="数据流的模型"></a>数据流的模型</h2><h3 id="Dataflow-Through-Databases"><a href="#Dataflow-Through-Databases" class="headerlink" title="Dataflow Through Databases"></a>Dataflow Through Databases</h3><p>写入<->未来读取</-></p>
<p>向后兼容，否则的话未来的代码将不能读取之前的数据</p>
<p>向前兼容，老的代码可能会使用到新的数据，例如滚动升级</p>
<h4 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h4><p>数据的写入时间不同，Rewriting(migrationg)的方式，或者填入默认值（使用Avro模型）</p>
<p>使用归档存储</p>
<h3 id="Dataflow-Through-Services"><a href="#Dataflow-Through-Services" class="headerlink" title="Dataflow Through Services"></a>Dataflow Through Services</h3><p>请求<->返回</-></p>
<p>多用于在网络之中的传输，例如web service与client，service与service(SOA, 微服务)。</p>
<p>SOAP,REST</p>
<ul>
<li>REST更为广泛，路径代表资源，HTTP动词代表操作</li>
<li>SOAP则使用XML来定义</li>
</ul>
<p>REST也是源自RPC，不过相较RPC，其不像RPC一样把调用当错内部函数，而更像是个网络协议。</p>
<p>REST用于OPENAPI, 而RPC往往只能用在组织内部。</p>
<h4 id="兼容性-1"><a href="#兼容性-1" class="headerlink" title="兼容性"></a>兼容性</h4><p>服务端只需要针对request做向后兼容，对response做向前兼容。</p>
<ul>
<li>gRPC之类的使用内置的编码格式做兼容</li>
<li>SOAP使用XML schema做兼容</li>
<li>RESTful API使用增加可选请求参数，在返回体中添加新字段。最终可使用版本号</li>
</ul>
<h3 id="Message-Passing-Dataflow"><a href="#Message-Passing-Dataflow" class="headerlink" title="Message-Passing Dataflow"></a>Message-Passing Dataflow</h3><p>可以看做为异步消息传递系统</p>
<p>相较于RPC拥有BUffer作为缓存，提高可靠性。自动重传消息等等</p>
<h4 id="message-broker"><a href="#message-broker" class="headerlink" title="message broker"></a>message broker</h4><p>RabbitMQ, Kafka等等。消息传递给<code>query</code>或<code>topic</code>，broker确保消息传递给了<code>consumers</code>或<code>subscribers</code>。</p>
<p>数据格式：字节序列即可，JSON, ProtoBuf均可。</p>
<h4 id="分布式actor框架"><a href="#分布式actor框架" class="headerlink" title="分布式actor框架"></a>分布式actor框架</h4><p>以message broker作为桥梁，连接各个actor，从而提升扩展性，降低复杂性，避免线程、锁等</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://erenming.com/2020/08/02/【踩坑日记】一次抓包排查实战/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Eren Ming">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eren with you">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/02/【踩坑日记】一次抓包排查实战/" itemprop="url">【踩坑日记】一次抓包排查实战</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-08-02T11:00:43+08:00">
                2020-08-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/踩坑日记/" itemprop="url" rel="index">
                    <span itemprop="name">踩坑日记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/08/02/【踩坑日记】一次抓包排查实战/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/08/02/【踩坑日记】一次抓包排查实战/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="问题的发现"><a href="#问题的发现" class="headerlink" title="问题的发现"></a>问题的发现</h2><p>周五，本是一个风清气爽，令人愉悦的日子。我本还在美滋滋地等待着下班，然而天有不测，有用户反应容器日志看不到了，根据经验我知道，日志采集&amp;收集链路上很可能又发生了阻塞。</p>
<p>登录目标容器所在机器找到日志采集容器，并娴熟地敲下<code>docker logs --tail 200 -f &lt;container-id&gt;</code>命令，发现确实阻塞了，阻塞原因是上报日志的请求500了，从而不断重试导致日志采集阻塞。</p>
<p>随后，我找到收集端的容器，查看日志，发现确实有请求报500了，并且抛出了<code>Unknown value type</code>的错误，查看相关代码。</p>
<p>业务代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> _, err := jsonparser.ArrayEach(body, <span class="function"><span class="keyword">func</span><span class="params">(value []<span class="keyword">byte</span>, dataType jsonparser.ValueType, offset <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err <span class="comment">// 错误抛出点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>jsonparser包中代码：</p>
<p><img src="https://raw.githubusercontent.com/erenming/image-pool/master/blogimage-20200802113337369.png" alt="image-20200802113337369"></p>
<p>显然问题出在了对body的解析上，究竟是什么样的body导致了解析错误呢？接下来，就是tcpdump和wireshark上场的时候了。</p>
<h2 id="使用Tcpdump抓包"><a href="#使用Tcpdump抓包" class="headerlink" title="使用Tcpdump抓包"></a>使用Tcpdump抓包</h2><p>首先，我们通过tcpdump抓到相关的请求。由于日志采集端会不断重试，因此最简单的方法便是登录采集端所在机器，并敲下如下命令<code>tcpdump -i tunl0 dst port 7777 -w td.out</code> ，并等待10-20秒。</p>
<p>熟悉tcpdump的小伙伴，对这条命令显然已经心领神会了。尽管如此，这里我还是稍微解释下。</p>
<ul>
<li><code>-i tunl0</code>：-i 参数用来指定网卡，由于采集器并没有通过<code>eth0</code>。因此，实战中，有时发现命令正确缺抓不到包的情况时，不妨指定下别的网卡。网络错综复杂，不一定都会通过<code>eth0</code>网卡。</li>
<li><code>dst port 777</code>： 指定了目标端口作为过滤参数，收集端程序的端口号是7777</li>
<li><code>-w td.out</code>:  表明将抓包记录保存在td.out文件中，这是因为json body是用base64编码并使用gzip加密后传输的，因此我得使用wireshark来抽离出来。（主要还是wireshark太香了:)，界面友好，操作简单，功能强大）</li>
</ul>
<p>接着，我用<code>scp</code>命令将<code>td.out</code>文件拷到本地。并使用wireshar打开它</p>
<h2 id="使用Wireshark分析"><a href="#使用Wireshark分析" class="headerlink" title="使用Wireshark分析"></a>使用Wireshark分析</h2><p><img src="https://raw.githubusercontent.com/erenming/image-pool/master/blogimage-20200802120035766.png" alt></p>
<p>打开后，首先映入眼帘的则是上图内容，看起来很多？不要慌，由于我们排查的是http请求，在过滤栏里输入HTTP，过滤掉非HTTP协议的记录。</p>
<p><img src="https://raw.githubusercontent.com/erenming/image-pool/master/blog/image-20200802120641740.png" alt="image-20200802120641740"></p>
<p>我们可以很清楚地发现，所有的HTTP都是发往一个IP的，且长度都是59，显然这些请求都是日志采集端程序不断重试的请求。接下来，我们只需要将某个请求里的body提取出来查看即可。</p>
<p><img src="https://raw.githubusercontent.com/erenming/image-pool/master/blog/image-20200802120944352.png" alt="image-20200802120944352"></p>
<p>很幸运，wireshark提供了这种功能，如上图所示，我们成功提取出来body内容。为<code>bnVsbA==</code>，使用base64解码后为<code>null</code>。</p>
<h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>既然body的内容为null，那么调用<code>jsonparser.ArrayEach</code>报错也是意料之中的了，body内容必须得是一个JsonArray。</p>
<p>然而，采集端为何会发送body为null的请求呢，深入源码，发现了如下一段逻辑。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *jsonEncoder)</span> <span class="title">encode</span><span class="params">(obj []publisher.Event)</span> <span class="params">(*bytes.Buffer, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> events []<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> _, o := <span class="keyword">range</span> obj &#123;</span><br><span class="line">		m, err := transformMap(o)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			logp.Err(<span class="string">"Fail to transform map with err: %s"</span>, err)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		events = <span class="built_in">append</span>(events, m)</span><br><span class="line">	&#125;</span><br><span class="line">	data, err := json.Marshal(events)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrap(err, <span class="string">"fail to json marshal events"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于<code>transforMap</code>函数回对obj中的元素进行转换，成功后添加到events中。</p>
<p>但是，由于使用的是<code>var events []map[string]interface{}</code>这种声明方式，在Golang中，slice的零值为nil，因此events此时的值为nil。而当obj中所有的对象，被<code>transforMap</code>失败时，events使用json序列化后则为null了。</p>
<p>这里我们需改变evetns的声明方式，使用<code>events := make([]map[string]interface{}, 0)</code>或者<code>events := []map[string]interface{}{}</code>的方式替代，此时events被初始化了，并指向的是一个cap为0的slice对象，其序列化后为<code>[]</code>。</p>
<p>这样即使没有对象添加到events中，上报的也是一个空数组。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.cnblogs.com/ggjucheng/archive/2012/01/14/2322659.html" target="_blank" rel="noopener">https://www.cnblogs.com/ggjucheng/archive/2012/01/14/2322659.html</a></li>
<li><a href="https://www.k0rz3n.com/2017/04/17/wireshark/" target="_blank" rel="noopener">https://www.k0rz3n.com/2017/04/17/wireshark/</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://erenming.com/2020/06/27/record-a-goroutine-leak/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Eren Ming">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eren with you">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/27/record-a-goroutine-leak/" itemprop="url">【踩坑日记】一次goroutine泄露问题的排查定位</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-27T12:59:45+08:00">
                2020-06-27
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/踩坑日记/" itemprop="url" rel="index">
                    <span itemprop="name">踩坑日记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/06/27/record-a-goroutine-leak/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/06/27/record-a-goroutine-leak/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="问题的发现"><a href="#问题的发现" class="headerlink" title="问题的发现"></a>问题的发现</h2><p>前段时间，我们一个基于libbeat开发的日志采集服务经常发生OOM的告警，OOM的排查大都比较简单，直接查看目标容器的内存变化情况即可。如图所示</p>
<p><img src="https://raw.githubusercontent.com/erenming/image-pool/master/blog/WechatIMG25.jpeg" style="float:center; width:600px;height:500 px"></p>
<p>从上图可以看出，内存随着时间呈线增长的趋势，然后在到达阈值之后瞬间降为0，实际上就是OOM了。</p>
<p>相信稍微有点经验的同学，应该都能大致断定这是个内存泄露的问题了。而Go程序的内存泄露大部分则都是goroutine泄露导致的。</p>
<p>画外音</p>
<blockquote>
<p>这里，若你的程序并没有接入监控，那么也可以通过vmstat工具来人工观察内存的变化情况。不管怎样，我们需要的是能观察到内存随时间的变化情况。</p>
</blockquote>
<h2 id="问题代码段定位"><a href="#问题代码段定位" class="headerlink" title="问题代码段定位"></a>问题代码段定位</h2><p>既然知道了问题的大致方向，那自然也就有了排查思路了。</p>
<p>首先，既然是用Go编写的应用程序，那么很自然，我们就应该想到<code>pprof</code>工具，它会动态跟踪记录程序运行过程中的各项参数，并提供各种工具图表来帮助你定位问题，功能强大又好用。这里，如果你对<code>pprof</code>工具还不熟悉的，建议先行阅读<a href="https://golang.org/pkg/net/http/pprof/" target="_blank" rel="noopener">官方文档</a>或者Google一些入门教程。</p>
<p>接着，我通过添加启动参数<code>--pprof</code>，来激活预置的pprof端口服务。通常，我们会预置类似下面代码块，以便在出现问题的时候，激活pprof功能。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="string">"net/http/pprof"</span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> cfg.Pprof &#123;</span><br><span class="line">    http.ListenAndServe(<span class="string">":6060"</span>, <span class="literal">nil</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改完成后，我重启了docker容器。并在容器中执行<code>curl http://localhost:6060/debug/pprof/heap &gt; h1.out</code>以及<code>curl http://localhost:6060/debug/pprof/goroutine &gt; g1.out</code>命令获取heap和goroutine的信息。这里由于是排查内存问题，我就取了heap和goroutine的数据。</p>
<p>在间隔30分钟后（这个取决于内存的增长速率），我再次执行<code>curl http://localhost:6060/debug/pprof/heap &gt; h2.out</code>以及<code>curl http://localhost:6060/debug/pprof/goroutine &gt; g2.out</code>命令。</p>
<p>这里，我为什么要间隔30分钟取两次样本数据呢？还是因为我们需要的是变化情况，而非当前状态，这很关键。</p>
<p>内存泄露的原因有很多，比如http body未Close，channel阻塞导致goroutine泄露等等。</p>
<p>因此，首先需要排查一下是不是其他非goroutine泄露的原因导致内存泄露，我首先执行<code>go tool pprof --base h1.out h2.out</code>，进入交互界面，然后执行<code>top10</code>、<code>web</code>等命令。很不幸，我并没有发现什么异常。</p>
<p>随后，就是需要排查goroutine泄露了，执行<code>go tool pprof --base g1.out g2.out</code>，接着我执行<code>top5</code>命令，发现<code>runtime.gopark</code>积累了很多，然后我使用了<code>traces</code>命令，发现是<code>Next.func1</code>goroutine异常地多，使用<code>list Next.func1</code>发现，在71行有1315个goroutine阻塞了，在通过<code>web</code>检查也是同样的情况。很显然是这快代码有问题。那么究竟是什么原因导致的呢？</p>
<p><img src="https://raw.githubusercontent.com/erenming/image-pool/master/blog/leak1.png"></p>
<p>PS</p>
<blockquote>
<p>上图是我后面在本地压测复现时的图，当时排查生产环境时未截图记录，因此后续大家排查的时候一定要记录好。方便后续复盘、回顾所用。</p>
</blockquote>
<h2 id="根因探究"><a href="#根因探究" class="headerlink" title="根因探究"></a>根因探究</h2><p>看似，我们的重点都在<strong>问题的发现</strong>以及<strong>问题代码段定位</strong>上了，然而在我看来熟悉了上面排查思路以及<code>pprof</code>等工具的使用后，还是相对比较容易定位的。</p>
<p>而根因的探究，则需要你对应用程序的源码很熟悉才行，网上的教程由于用的都是很简单的demo，因此看起来似乎很容易就解决了，然而实际代码往往非常的庞大而复杂。因此这一步，需要你对应用程序的源码比较熟悉，这样才能快速准确的找到问题背后的原因。</p>
<p>实际上，由于我才接手这一块，在这一步上也卡了很久。最终，通过反复阅读源码和设计文档，并且与社区深度讨论之后，定位到了原因。</p>
<p>简单来说，这是由于这里的goroutine是依赖于第70行返回的<code>err</code>来判断并退出的，然而，由于在日志采集相关goroutine在执行关闭操作的过程中，有新的message被采集并发送到<code>r.ch</code>上，而此时从<code>r.ch</code>上消费的逻辑已暂停，从而即便后续关闭操作执行完成，<code>r.reader.Next()</code>返回错误，也会阻塞在第71行。具体想了解的可以查阅这个<a href="https://github.com/elastic/beats/issues/19193" target="_blank" rel="noopener">issue</a>。</p>
<p>可以看出，有效可靠地关闭goroutine是多么的重要，稍不留神就泄露了。</p>
<p><em>文章主要是记录了一次实际goroutine泄露的发现-排查-根因定位的全过程。对工具的介绍和使用，基本不涉及，你可以通过查阅其他资料学习</em></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://golang.org/pkg/net/http/pprof/" target="_blank" rel="noopener">https://golang.org/pkg/net/http/pprof/</a></li>
<li><a href="https://blog.detectify.com/2019/09/05/how-we-tracked-down-a-memory-leak-in-one-of-our-go-microservices/" target="_blank" rel="noopener">https://blog.detectify.com/2019/09/05/how-we-tracked-down-a-memory-leak-in-one-of-our-go-microservices/</a></li>
<li><a href="https://blog.wolfogre.com/posts/go-ppof-practice/#排查协程泄露" target="_blank" rel="noopener">https://blog.wolfogre.com/posts/go-ppof-practice/#%E6%8E%92%E6%9F%A5%E5%8D%8F%E7%A8%8B%E6%B3%84%E9%9C%B2</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//segmentfault.com/a/1190000016412013" target="_blank" rel="noopener">煎鱼 pprof实战</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//dave.cheney.net/high-performance-go-workshop/dotgo-paris.html" target="_blank" rel="noopener">dave.cheney</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://erenming.com/2020/04/08/go-reflec-usage-guide/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Eren Ming">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eren with you">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/08/go-reflec-usage-guide/" itemprop="url">Golang reflect使用指南</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-08T00:04:13+08:00">
                2020-04-08
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/04/08/go-reflec-usage-guide/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/04/08/go-reflec-usage-guide/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Go提供了各种变量、切片、结构体等等特性，我们可以非常方便的定义与使用它们。例如，当你想定义一个结构体的类型，只需要简单地定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而，当需要处理处理动态数据结构时，我们无法在编译阶段就知道未知数据的结构，其中一个非常经典的使用情景就是对Json串的Marshal。此时，就该<code>reflect</code>包出场了，它提供了在运行时创建、更新某种类型以及获取该类型的各种信息的能力，有了它，我们不仅能有效处理动态数据类型，还可以大大提高代码的复用性、可读性。</p>
<h2 id="Type"><a href="#Type" class="headerlink" title="Type"></a>Type</h2><p>在reflect包中，是用<code>Type</code>来描述Go中某个对象的类型，并提供了一系列方法，来获取类型的相关信息，一般通过调用<code>TypeOf</code>来获取一个任意变量的类型<code>Type</code>。</p>
<p>例如，<code>Name()</code>返回的就是该类型的具体名称，<code>String()</code>返回类型的字符串表示。</p>
<p>值得注意的是<code>Kind()</code>方法，它返回的是该类型的类别，这似乎有点拗口，但其实十分好理解，举个例子，<code>type A struct{}</code> ，它的类型是A而类别是struct。通常，在开始阶段，我们会先判断传入的interface的类别，从而避免panic。因为有些方法只适用于某种类别，随意使用的话代码很容易panic，例如<code>NumField()</code>方法，只能用以获取Kind为结构体的字段数量。</p>
<p>还有一个方法<code>Elem()</code>，返回Type的子元素的Type。举个例子，若Type为指针，那么<code>Elem()</code>返回指针所指向的Type，若为切片，则<code>Elem()</code>返回切片元素的类型Type。例如<code>*[]int</code>，它的<code>Elem()</code>方法返回<code>[]int</code>的Type。而<code>[]int</code>的<code>Elem()</code>方法返回<code>int</code>的Type。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> A []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printInfo</span><span class="params">(t reflect.Type)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"Kind = %s\tName = %s\n"</span>, t.Kind(), t.Name())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := &amp;A&#123;&#125;</span><br><span class="line">	printInfo(reflect.TypeOf(a))</span><br><span class="line">	printInfo(reflect.TypeOf(a).Elem())</span><br><span class="line">	printInfo(reflect.TypeOf(a).Elem().Elem())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Kind = ptr      Name = </span><br><span class="line">Kind = slice    Name = A</span><br><span class="line">Kind = int      Name = int</span><br></pre></td></tr></table></figure>
<h2 id="Value"><a href="#Value" class="headerlink" title="Value"></a>Value</h2><p>而<code>Value</code>描述了在Go运行时某个对象的值，我们可以针对它进行增删改查之类的操作，一般通过<code>ValueOf</code>方法来获取对象的<code>Value</code>。</p>
<p>通常情况下，我们可以通过<code>Set()</code>方法来修改变量的值。例如下述代码</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">val := reflect.ValueOf(&amp;a)</span><br><span class="line">val.Elem().Set(reflect.ValueOf(<span class="number">2</span>))</span><br><span class="line">fmt.Printf(<span class="string">"a = %d"</span>, a)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = 2</span><br></pre></td></tr></table></figure>
<p>可以看到，变量a的值由1被修改为2了。</p>
<h2 id="使用举例"><a href="#使用举例" class="headerlink" title="使用举例"></a>使用举例</h2><h4 id="动态初始化结构体"><a href="#动态初始化结构体" class="headerlink" title="动态初始化结构体"></a>动态初始化结构体</h4><p>实际工作中，<code>struct</code>通常用来表示某种数据结构(或对象)，是十分简洁易懂的。然而，缺点也很明显，即其表达能力很有限，比如，你想指定某个字段的默认值，你不得不在构造函数中手动指定。这种方式虽然可行，但是不够优雅，可读性也很差。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DS <span class="keyword">struct</span> &#123;</span><br><span class="line">	FieldOne <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDS</span><span class="params">()</span> *<span class="title">DS</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;DS&#123;</span><br><span class="line">		FieldOne: <span class="string">"something"</span>,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么该如何优化呢？很简单，即利用字段的tag信息。例如，下述代码，我在tag中设置了默认值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DS <span class="keyword">struct</span> &#123;</span><br><span class="line">	FieldOne <span class="keyword">string</span> <span class="string">`default:"something"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，我使用一个初始化函数<code>initStruct()</code>来读取tag并设置字段默认值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDS</span><span class="params">()</span> *<span class="title">DS</span></span> &#123;</span><br><span class="line">	ds := &amp;DS&#123;&#125;</span><br><span class="line">	initStruct(ds)</span><br><span class="line">	fmt.Printf(<span class="string">"FieldOne = %s"</span>, ds.FieldOne)</span><br><span class="line">	<span class="keyword">return</span> ds</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initStruct</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   e := reflect.Indirect(reflect.ValueOf(v))</span><br><span class="line">   <span class="keyword">if</span> e.Kind() != reflect.Struct &#123;</span><br><span class="line">      <span class="keyword">return</span> errors.New(<span class="string">"v must be struct"</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   et, ev := e.Type(), e</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; et.NumField(); i++ &#123;</span><br><span class="line">      field, val := et.Field(i), ev.Field(i)</span><br><span class="line">      defaultValue, ok := field.Tag.Lookup(<span class="string">"default"</span>)</span><br><span class="line">      <span class="keyword">if</span> !ok &#123;</span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">switch</span> field.Type.Kind() &#123;</span><br><span class="line">      <span class="keyword">case</span> reflect.String:</span><br><span class="line">         val.SetString(defaultValue)</span><br><span class="line">      <span class="keyword">case</span> reflect.Int:</span><br><span class="line">         <span class="keyword">if</span> x, err := strconv.ParseInt(defaultValue, <span class="number">10</span>, <span class="number">64</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            val.SetInt(x)</span><br><span class="line">         &#125;</span><br><span class="line">      <span class="comment">// 针对不同Kind，将defaultValue转换为对应类型并赋值</span></span><br><span class="line">      ...</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，我们就可以既方便又优雅地给结构体设置默认值了，当然，你还可以在tag中设置其他动态属性来动态更改结构体。</p>
<h4 id="动态创建Map"><a href="#动态创建Map" class="headerlink" title="动态创建Map"></a>动态创建Map</h4><p>通常情况下，我们是通过<code>make</code>来创建一个map，而有了<code>reflect</code>包后，我们也可以通过<code>reflet</code>包来动态地创建一个map。</p>
<p>这里，我们有个需求，需要将一个代表长方形的结构体转换为一个map，并且存在额外要求，例如浮点字段只保留两位小数且转换为字符串。</p>
<p>首先，定义一个名为<code>Rectangle</code>的结构体来代表一个长方形</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> Rectangle <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name   <span class="keyword">string</span></span><br><span class="line">	Unit   <span class="keyword">string</span></span><br><span class="line">	Length <span class="keyword">float64</span></span><br><span class="line">	Width  <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，使用一个<code>convert</code>函数，将其转换为map。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convert</span><span class="params">(rectangle *Rectangle)</span> <span class="params">(res <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>, err error)</span></span> &#123;</span><br><span class="line">	e := reflect.Indirect(reflect.ValueOf(rectangle))</span><br><span class="line">	<span class="keyword">if</span> e.Kind() != reflect.Struct &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"v must be struct"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	et, ev := e.Type(), e</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> mapStringType = reflect.TypeOf(<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>))</span><br><span class="line">	mapReflect := reflect.MakeMap(mapStringType)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; et.NumField(); i++ &#123;</span><br><span class="line">		field, val := et.Field(i), ev.Field(i)</span><br><span class="line">		<span class="keyword">switch</span> field.Type.Kind() &#123;</span><br><span class="line">		<span class="keyword">case</span> reflect.String:</span><br><span class="line">			mapReflect.SetMapIndex(reflect.ValueOf(field.Name), reflect.ValueOf(val.String()))</span><br><span class="line">		<span class="keyword">case</span> reflect.Float64:</span><br><span class="line">			s := strconv.FormatFloat(val.Float(), <span class="string">'f'</span>, <span class="number">2</span>, <span class="number">64</span>)</span><br><span class="line">			mapReflect.SetMapIndex(reflect.ValueOf(field.Name), reflect.ValueOf(s))</span><br><span class="line">		<span class="comment">// other cases</span></span><br><span class="line">		...</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> mapReflect.Interface().(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，我们可以打印出转换后的map。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	res, _ := convert(&amp;Rectangle&#123;</span><br><span class="line">		Name: <span class="string">"rec-1"</span>,</span><br><span class="line">		Unit: <span class="string">"cm"</span>,</span><br><span class="line">		Length: <span class="number">12.121764</span>,</span><br><span class="line">		Width: <span class="number">5.989681</span>,</span><br><span class="line">	&#125;)</span><br><span class="line">	fmt.Printf(<span class="string">"res = %+v"</span>, res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res = map[Length:12.12 Name:rec-1 Unit:cm Width:5.99]</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，对于<code>reflect</code>的简单介绍已完毕，相信你已经有了一个大概的认知了。是不是觉得这个包很强大，想跃跃欲试呢？但是，在此之前，还是要提醒你要铭记以下注意点。</p>
<ol>
<li><code>reflect</code>大多只能适用于动态数据类型的场景，且较为危险，因此能使用原生类型尽量使用原生类型。</li>
<li>书写要小心，错误使用reflect很容易panic，你需要确保你的类型使用了正确的相关方法，并提前返回错误。</li>
<li>编程界没有银弹，因此<code>reflect</code>也不是万能，例如你无法动态创建结构体的方法。</li>
</ol>
<p><em>本人才疏学浅，文章难免有些不足之处，非常欢迎大家评论指出。</em></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://medium.com/capital-one-tech/learning-to-use-go-reflection-822a0aed74b7" target="_blank" rel="noopener">Learning to Use Go Reflection - Capital One Tech - Medium</a></li>
<li><p><a href="https://blog.golang.org/laws-of-reflection" target="_blank" rel="noopener">The Laws of Reflection - The Go Blog - Golang</a></p>
</li>
<li><p><a href="https://golangbot.com/reflection/" target="_blank" rel="noopener">Reflection in Golang - golangbot.com</a></p>
</li>
<li><a href="https://draveness.me/golang-reflect/" target="_blank" rel="noopener">Go 语言反射的实现原理| Go 语言设计与实现 - 面向信仰编程</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://erenming.com/2020/02/01/map-in-go/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Eren Ming">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eren with you">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/01/map-in-go/" itemprop="url">Golang中的map实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-01T17:28:15+08:00">
                2020-02-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/源码学习/" itemprop="url" rel="index">
                    <span itemprop="name">源码学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/02/01/map-in-go/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/02/01/map-in-go/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>总所周知，大多数语言中，字典的底层是哈希表，而且其算法也是十分清晰的。无论采用链表法还是开放寻址法，我们都能实现一个简单的哈希表结构。对于Go来说，它是具体如何实现哈希表的呢？以及，采取了哪些优化策略呢？</p>
<h2 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h2><p>map在内存的总体结构如下图所示。</p>
<p><img src="https://blog-1300816757.cos.ap-shanghai.myqcloud.com/img/Snipaste_2020-02-26_15-54-40.png"></p>
<h4 id="头部结构体hmap"><a href="#头部结构体hmap" class="headerlink" title="头部结构体hmap"></a>头部结构体<code>hmap</code></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">	count     <span class="keyword">int</span> <span class="comment">// 键值对个数</span></span><br><span class="line">	flags     <span class="keyword">uint8</span></span><br><span class="line">	B         <span class="keyword">uint8</span>  <span class="comment">// 2^B = 桶数量</span></span><br><span class="line">	noverflow <span class="keyword">uint16</span> <span class="comment">// 溢出桶的个数</span></span><br><span class="line">	hash0     <span class="keyword">uint32</span> <span class="comment">// hash seed</span></span><br><span class="line"></span><br><span class="line">	buckets    unsafe.Pointer <span class="comment">// 哈希桶</span></span><br><span class="line">	oldbuckets unsafe.Pointer <span class="comment">// 原哈希桶，扩容时为非空</span></span><br><span class="line">	nevacuate  <span class="keyword">uintptr</span>        <span class="comment">// 扩容进度，地址小于它的桶已被迁移了</span></span><br><span class="line"></span><br><span class="line">	extra *mapextra <span class="comment">// optional fields</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>hmap</code>即为map编译后的内存表示，这里需要注意的有两点。</p>
<ol>
<li>B的值是根据负载因子(LoadFactor)以及存储的键值对数量，在创建或扩容时动态改变</li>
<li>buckets是一个指针，它指向一个<code>bmap</code>结构</li>
</ol>
<h4 id="桶结构体bmap"><a href="#桶结构体bmap" class="headerlink" title="桶结构体bmap"></a>桶结构体<code>bmap</code></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// tophash数组可以看做键值对的索引</span></span><br><span class="line">	tophash [bucketCnt]<span class="keyword">uint8</span></span><br><span class="line">	<span class="comment">// 实际上编译器会动态添加下述属性</span></span><br><span class="line">  <span class="comment">// keys     [8]keytype</span></span><br><span class="line">  <span class="comment">// values   [8]valuetype</span></span><br><span class="line">  <span class="comment">// padding  uinptr</span></span><br><span class="line">  <span class="comment">// overflow uinptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然<code>bmap</code>结构体中只有一个tophash数组，但实际上，其后跟着8个key的槽位、8个value的槽位、padding以及一个<code>overflow</code>指针。如下图所示</p>
<p><img src="https://blog-1300816757.cos.ap-shanghai.myqcloud.com/img/Snipaste_2020-02-26_16-51-15.png" style="float:center; width:200px;height:50 px"></p>
<p>这里，Go做了优化。</p>
<ol>
<li>这里并没有把key/value作为一个entry，而是分开存储。主要是为了节省内存，有时可以避免使用padding(额外的内存)来对齐，比如<code>map[int64]int8</code>就完全不需要padding。</li>
</ol>
<h2 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h2><p>查找操作总体和链表法的哈希表查找类似，即key —&gt; hashFunc(key) —&gt; mask(hash) —&gt; 桶的位置 —&gt; 遍历链表。其主要代码如下所示</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapaccess1</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">	alg := t.key.alg</span><br><span class="line">	hash := alg.hash(key, <span class="keyword">uintptr</span>(h.hash0))</span><br><span class="line">	m := bucketMask(h.B)</span><br><span class="line">	<span class="comment">// 计算得到桶的位置bucket-k</span></span><br><span class="line">	b := (*bmap)(add(h.buckets, (hash&amp;m)*<span class="keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line">  <span class="comment">// 若正在扩容，老buckets则为非空</span></span><br><span class="line">	<span class="comment">// 若bucket-k在老的buckets数组中，未被迁移，则使用老的</span></span><br><span class="line">	<span class="keyword">if</span> c := h.oldbuckets; c != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> !h.sameSizeGrow() &#123;</span><br><span class="line">			<span class="comment">// There used to be half as many buckets; mask down one more power of two.</span></span><br><span class="line">			m &gt;&gt;= <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">		oldb := (*bmap)(add(c, (hash&amp;m)*<span class="keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line">		<span class="keyword">if</span> !evacuated(oldb) &#123;</span><br><span class="line">			b = oldb</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 根据tophash(hash), 在bucket-k中的tophash中查找key</span></span><br><span class="line">	top := tophash(hash)</span><br><span class="line">  <span class="comment">// 找到对应的bucket后，遍历查找对应的key/value</span></span><br><span class="line">bucketloop:</span><br><span class="line">	<span class="keyword">for</span> ; b != <span class="literal">nil</span>; b = b.overflow(t) &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="keyword">uintptr</span>(<span class="number">0</span>); i &lt; bucketCnt; i++ &#123;</span><br><span class="line">			...</span><br><span class="line">			<span class="comment">// 计算第i个位置的key的地址</span></span><br><span class="line">			k := add(unsafe.Pointer(b), dataOffset+i*<span class="keyword">uintptr</span>(t.keysize))</span><br><span class="line">			<span class="keyword">if</span> t.indirectkey() &#123;</span><br><span class="line">				k = *((*unsafe.Pointer)(k))</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 比较tophash[i]上的k是否与目标key相等</span></span><br><span class="line">			<span class="keyword">if</span> alg.equal(key, k) &#123;</span><br><span class="line">        <span class="comment">// 计算value的地址</span></span><br><span class="line">				v := add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="keyword">uintptr</span>(t.keysize)+i*<span class="keyword">uintptr</span>(t.valuesize))</span><br><span class="line">				<span class="keyword">if</span> t.indirectvalue() &#123;</span><br><span class="line">					v = *((*unsafe.Pointer)(v))</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> v</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 若最终还是没找到，则返回nil</span></span><br><span class="line">	<span class="keyword">return</span> unsafe.Pointer(&amp;zeroVal[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，Go通过对应类型的<code>alg.hash</code>计算得到hash值（<a href="!https://github.com/golang/go/blob/master/src/runtime/alg.go">各种类型的hash&amp;equal函数定义</a>），取后B位作为buckets数组的下标(实际上为取余)，取高8位作为tophash的下标。</p>
<p>然后，通过一个嵌套循环查找目标key：外层循环是遍历一个<code>bmap</code>单链表，它们通过<code>overflow</code>指针相连；内层循环则遍历tophash数组，逐个比较，当匹配成功时，则计算得到实际key的地址，比较两者，成功则返回。如下图所示</p>
<p><img src="https://blog-1300816757.cos.ap-shanghai.myqcloud.com/img/Snipaste_2020-02-26_16-32-59.png"></p>
<p>这里，Go做了如下优化。</p>
<ol>
<li>使用tophash数组，作为索引，用以判断key是否存在该bmap中，若确实存在，再使用较为耗时的比较算法判断key是否相等。</li>
</ol>
<p>除了查找操作，map的插入、删除以及扩容操作也十分值得学习，大家可以去查阅相关<a href="!https://github.com/golang/go/blob/master/src/runtime/map.go">源码</a></p>
<p><em>本人才疏学浅，文章难免有些不足之处，非常欢迎大大们评论指出。</em></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics#easy-footnote-1-3224" target="_blank" rel="noopener">https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics#easy-footnote-1-3224</a></li>
<li><a href="https://github.com/golang/go/blob/master/src/runtime/map.go" target="_blank" rel="noopener">https://github.com/golang/go/blob/master/src/runtime/map.go</a></li>
<li><a href="https://studygolang.com/articles/25134" target="_blank" rel="noopener">https://studygolang.com/articles/25134</a></li>
<li><a href="https://www.linkinstar.wiki/2019/06/03/golang/source-code/graphic-golang-map/" target="_blank" rel="noopener">https://www.linkinstar.wiki/2019/06/03/golang/source-code/graphic-golang-map/</a></li>
<li><a href="https://github.com/qcrao/Go-Questions/blob/master/map/map 的底层实现原理是什么.md" target="_blank" rel="noopener">https://github.com/qcrao/Go-Questions/blob/master/map/map%20%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88.md</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://erenming.com/2019/12/20/understand-middleware/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Eren Ming">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eren with you">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/20/understand-middleware/" itemprop="url">用Golang实现并理解Web中间件</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-20T14:39:21+08:00">
                2019-12-20
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/20/understand-middleware/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/12/20/understand-middleware/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>在编写web应用中，我们常常会遇到这样的需求，比如，我们需要上报每个API的运行时间到运维监控系统。这时候你可以像下述代码一样将统计的逻辑写到每个路由函数中。<br>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2019/12/20/understand-middleware/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </p></div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://erenming.com/2019/12/11/string-in-golang/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Eren Ming">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eren with you">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/11/string-in-golang/" itemprop="url">Golang中的string实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-11T21:31:47+08:00">
                2019-12-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/源码学习/" itemprop="url" rel="index">
                    <span itemprop="name">源码学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/11/string-in-golang/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/12/11/string-in-golang/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>说到<code>string</code>类型，我们往往都能很熟练地对它进行各种处理，包括迭代、随机访问和匹配等等操作。然而在工作中，我发现迭代一个字符串产生的字符的类型与随机访问一个字符的类型却并不相同，为什么会这么奇怪呢？于是我决定一探究竟<br>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2019/12/11/string-in-golang/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </p></div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://erenming.com/2019/10/03/slice-in-go/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Eren Ming">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eren with you">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/03/slice-in-go/" itemprop="url">Golang中的slice实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-03T11:53:20+08:00">
                2019-10-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Golang/" itemprop="url" rel="index">
                    <span itemprop="name">Golang</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/10/03/slice-in-go/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/10/03/slice-in-go/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>最近闲来无事，深入研究了slice在Golang中的实现并简要阅读了其相关的底层实现代码后，对于实际工作中的一些slice相关代码的写法与Bug有了一种豁然开朗的感觉。故记录下来，与君分享。<br>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2019/10/03/slice-in-go/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </p></div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Eren Ming</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/erenming" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:erenming233@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  #<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Eren Ming</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://erenming.disqus.com/count.js" async></script>
    

    

  




	





  














  





  

  

  

  
  

  

  

  

</body>
</html>
